# å¤šä»“ä½å¹¶è¡Œç­–ç•¥

## æ ¸å¿ƒç†å¿µ

**åŒæ–¹å‘å¯ä»¥åŒæ—¶æŒæœ‰å¤šä¸ªä»“ä½ï¼Œå› ä¸ºç ´ä½æœºä¼šä¸æ˜¯çº¿æ€§ç­‰å¾…çš„ï¼Œè€Œæ˜¯é›†ä¸­çˆ†å‘çš„**

---

## ğŸ¯ ä¸ºä»€ä¹ˆè¦å…è®¸å¤šä»“ä½

### 1. æœºä¼šé›†ä¸­çˆ†å‘

```
Big4ç ´ä½æ—¶é—´çº¿:
08:00 â†’ BTC/ETH/BNB/SOL åŒæ—¶ç ´ä½å‘ä¸‹
08:01 â†’ DOGEè·Ÿéšç ´ä½
08:03 â†’ SHIBè·Ÿéšç ´ä½
08:05 â†’ PEPEè·Ÿéšç ´ä½
08:07 â†’ ARBè·Ÿéšç ´ä½
08:10 â†’ MATICè·Ÿéšç ´ä½

å¦‚æœåªèƒ½æŒæœ‰1ä¸ªå•:
âœ“ 08:01 å¼€ä»“DOGE
âœ— 08:03 è·³è¿‡SHIB (å·²æœ‰ä»“ä½)
âœ— 08:05 è·³è¿‡PEPE (å·²æœ‰ä»“ä½)
âœ— 08:07 è·³è¿‡ARB (å·²æœ‰ä»“ä½)
âœ— 08:10 è·³è¿‡MATIC (å·²æœ‰ä»“ä½)

ç»“æœ: é”™è¿‡80%çš„æœºä¼š
```

### 2. åˆ†æ•£é£é™©

```
æ–¹æ¡ˆA: å•å¸ç§æ»¡ä»“
DOGE 100%ä»“ä½ â†’ å¦‚æœDOGEæ’é’ˆæ­¢æŸ â†’ å…¨äº

æ–¹æ¡ˆB: å¤šå¸ç§åˆ†ä»“
DOGE 33%
SHIB 33%
PEPE 34%
â†’ å³ä½¿DOGEæ­¢æŸï¼Œè¿˜æœ‰SHIBå’ŒPEPE
â†’ é£é™©åˆ†æ•£ï¼Œæ›´ç¨³å¥
```

### 3. æé«˜æ”¶ç›Š

```
ç ´ä½è¡Œæƒ…ä¸­:
- BTCè·Œ3%
- DOGEè·Œ8%
- SHIBè·Œ12%
- PEPEè·Œ10%

å•ä»“DOGE: æ”¶ç›Š +8%
ä¸‰ä»“DOGE+SHIB+PEPE: æ”¶ç›Š (8%+12%+10%)/3 = +10%
```

---

## ğŸ“Š å¤šä»“ä½ç®¡ç†ç­–ç•¥

### åŸºæœ¬é…ç½®

```python
POSITION_CONFIG = {
    'max_same_direction': 5,      # åŒæ–¹å‘æœ€å¤š5ä¸ªä»“ä½
    'total_capital_usage': 0.8,   # æœ€å¤šä½¿ç”¨80%èµ„é‡‘
    'per_position_limit': 0.25,   # å•ä¸ªä»“ä½æœ€å¤š25%
    'min_position_interval': 180, # æœ€å°å¼€ä»“é—´éš”3åˆ†é’Ÿ
}
```

### å®ç°é€»è¾‘

```python
class MultiPositionManager:
    """å¤šä»“ä½ç®¡ç†å™¨"""

    def __init__(self, total_capital):
        self.total_capital = total_capital
        self.positions = {}  # å½“å‰æŒä»“
        self.config = POSITION_CONFIG

    def can_open_new_position(self, direction):
        """
        åˆ¤æ–­æ˜¯å¦å¯ä»¥å¼€æ–°ä»“

        Args:
            direction: 'LONG' | 'SHORT'

        Returns:
            bool, str: (æ˜¯å¦å¯ä»¥, åŸå› )
        """
        # 1. æ£€æŸ¥åŒæ–¹å‘ä»“ä½æ•°é‡
        same_direction_count = sum([
            1 for p in self.positions.values()
            if p['side'] == direction
        ])

        if same_direction_count >= self.config['max_same_direction']:
            return False, f"åŒæ–¹å‘ä»“ä½å·²è¾¾ä¸Šé™({self.config['max_same_direction']})"

        # 2. æ£€æŸ¥æ€»èµ„é‡‘ä½¿ç”¨ç‡
        total_used = sum([p['margin'] for p in self.positions.values()])
        usage_ratio = total_used / self.total_capital

        if usage_ratio >= self.config['total_capital_usage']:
            return False, f"èµ„é‡‘ä½¿ç”¨ç‡å·²è¾¾{usage_ratio:.1%}"

        # 3. æ£€æŸ¥æœ€å°å¼€ä»“é—´éš”
        last_open_time = max([
            p['open_time'] for p in self.positions.values()
            if p['side'] == direction
        ], default=None)

        if last_open_time:
            elapsed = (datetime.now() - last_open_time).total_seconds()
            if elapsed < self.config['min_position_interval']:
                return False, f"è·ä¸Šæ¬¡å¼€ä»“ä»…{elapsed:.0f}ç§’ï¼Œéœ€ç­‰å¾…{self.config['min_position_interval']}ç§’"

        return True, "å¯ä»¥å¼€ä»“"

    def calculate_position_size(self, signal, current_positions):
        """
        è®¡ç®—æ–°ä»“ä½å¤§å°

        Args:
            signal: äº¤æ˜“ä¿¡å·
            current_positions: å½“å‰åŒæ–¹å‘æŒä»“åˆ—è¡¨

        Returns:
            float: ä»“ä½å¤§å°
        """
        # 1. è®¡ç®—å¯ç”¨èµ„é‡‘
        total_used = sum([p['margin'] for p in self.positions.values()])
        available = self.total_capital * self.config['total_capital_usage'] - total_used

        # 2. è®¡ç®—å•ä»“ä½é™é¢
        per_position_limit = self.total_capital * self.config['per_position_limit']

        # 3. æ ¹æ®ä¿¡å·è¯„åˆ†è°ƒæ•´
        score_ratio = min(signal['score'] / 100, 1.0)  # è¯„åˆ†è¶Šé«˜ï¼Œä»“ä½è¶Šå¤§

        # 4. æ ¹æ®ç°æœ‰ä»“ä½æ•°é‡è°ƒæ•´ï¼ˆä»“ä½è¶Šå¤šï¼Œæ–°ä»“è¶Šå°ï¼‰
        position_count = len(current_positions)
        count_factor = 1.0 / (position_count + 1)  # é€’å‡å› å­

        # 5. ç»¼åˆè®¡ç®—
        allocated = min(
            available,
            per_position_limit
        ) * score_ratio * count_factor

        return allocated

    def open_position(self, signal):
        """
        å¼€æ–°ä»“

        Args:
            signal: äº¤æ˜“ä¿¡å·

        Returns:
            dict: è®¢å•ä¿¡æ¯
        """
        # æ£€æŸ¥æ˜¯å¦å¯ä»¥å¼€ä»“
        can_open, reason = self.can_open_new_position(signal['direction'])

        if not can_open:
            logger.warning(f"[å¼€ä»“æ‹’ç»] {signal['symbol']}: {reason}")
            return None

        # è·å–åŒæ–¹å‘ç°æœ‰ä»“ä½
        current_positions = [
            p for p in self.positions.values()
            if p['side'] == signal['direction']
        ]

        # è®¡ç®—ä»“ä½å¤§å°
        position_size = self.calculate_position_size(signal, current_positions)

        # æ‰§è¡Œå¼€ä»“
        order = exchange.create_order(
            symbol=signal['symbol'],
            side='BUY' if signal['direction'] == 'LONG' else 'SELL',
            type='MARKET',
            quantity=position_size / signal['entry_price']
        )

        # è®°å½•ä»“ä½
        self.positions[signal['symbol']] = {
            'symbol': signal['symbol'],
            'side': signal['direction'],
            'entry_price': signal['entry_price'],
            'quantity': position_size / signal['entry_price'],
            'margin': position_size,
            'open_time': datetime.now(),
            'order_id': order['id']
        }

        logger.info(f"[å¼€ä»“æˆåŠŸ] {signal['symbol']} {signal['direction']}: {position_size}U")

        return order
```

---

## ğŸ“ˆ åŠ¨æ€ä»“ä½åˆ†é…

### ç­–ç•¥1: ç­‰æƒåˆ†é…

```python
def equal_weight_allocation(total_capital, position_count, max_positions):
    """
    ç­‰æƒåˆ†é…

    Args:
        total_capital: æ€»èµ„é‡‘
        position_count: å½“å‰ä»“ä½æ•°
        max_positions: æœ€å¤§ä»“ä½æ•°

    Returns:
        float: å•ä¸ªä»“ä½é‡‘é¢
    """
    usable = total_capital * 0.8  # ä½¿ç”¨80%
    per_position = usable / max_positions
    return per_position

# ç¤ºä¾‹
total_capital = 10000
max_positions = 5

# æ¯ä¸ªä»“ä½
per_position = equal_weight_allocation(10000, 0, 5)
# = 10000 * 0.8 / 5 = 1600

# å¼€ä»“é¡ºåº:
# 1. DOGE: 1600
# 2. SHIB: 1600
# 3. PEPE: 1600
# 4. ARB: 1600
# 5. MATIC: 1600
```

### ç­–ç•¥2: é€’å‡åˆ†é…

```python
def decreasing_allocation(total_capital, position_count, max_positions):
    """
    é€’å‡åˆ†é… - è¶Šæ™šå¼€çš„ä»“ä½è¶Šå°

    Args:
        total_capital: æ€»èµ„é‡‘
        position_count: å½“å‰ä»“ä½æ•°
        max_positions: æœ€å¤§ä»“ä½æ•°

    Returns:
        float: å•ä¸ªä»“ä½é‡‘é¢
    """
    usable = total_capital * 0.8
    base = usable / max_positions

    # é€’å‡å› å­
    factor = 1.0 - (position_count / max_positions) * 0.5

    return base * factor

# ç¤ºä¾‹
# 1. DOGE: 1600 * 1.0 = 1600
# 2. SHIB: 1600 * 0.9 = 1440
# 3. PEPE: 1600 * 0.8 = 1280
# 4. ARB: 1600 * 0.7 = 1120
# 5. MATIC: 1600 * 0.6 = 960
```

### ç­–ç•¥3: è¯„åˆ†åŠ æƒåˆ†é…

```python
def score_weighted_allocation(total_capital, signals, max_positions):
    """
    è¯„åˆ†åŠ æƒåˆ†é… - è¯„åˆ†é«˜çš„ä»“ä½å¤§

    Args:
        total_capital: æ€»èµ„é‡‘
        signals: ä¿¡å·åˆ—è¡¨
        max_positions: æœ€å¤§ä»“ä½æ•°

    Returns:
        dict: å„å¸ç§åˆ†é…é‡‘é¢
    """
    usable = total_capital * 0.8

    # å–å‰Nä¸ªä¿¡å·
    top_signals = sorted(signals, key=lambda x: x['score'], reverse=True)[:max_positions]

    # è®¡ç®—æ€»è¯„åˆ†
    total_score = sum([s['score'] for s in top_signals])

    # åŠ æƒåˆ†é…
    allocations = {}
    for sig in top_signals:
        weight = sig['score'] / total_score
        allocations[sig['symbol']] = usable * weight

    return allocations

# ç¤ºä¾‹
signals = [
    {'symbol': 'DOGE', 'score': 100},
    {'symbol': 'SHIB', 'score': 90},
    {'symbol': 'PEPE', 'score': 80},
    {'symbol': 'ARB', 'score': 70},
    {'symbol': 'MATIC', 'score': 60}
]

allocations = score_weighted_allocation(10000, signals, 5)
# {
#     'DOGE': 2000  (100/400 * 8000)
#     'SHIB': 1800  (90/400 * 8000)
#     'PEPE': 1600  (80/400 * 8000)
#     'ARB': 1400   (70/400 * 8000)
#     'MATIC': 1200 (60/400 * 8000)
# }
```

---

## â±ï¸ å¼€ä»“æ—¶æœºæ§åˆ¶

### 1. é›†ä¸­å¼€ä»“æ¨¡å¼ï¼ˆç ´ä½æ—¶ï¼‰

```python
class BatchOpeningMode:
    """æ‰¹é‡å¼€ä»“æ¨¡å¼ - ç”¨äºç ´ä½ç­‰é›†ä¸­ä¿¡å·"""

    def __init__(self, position_manager):
        self.manager = position_manager

    def batch_open(self, signals, time_window=300):
        """
        æ‰¹é‡å¼€ä»“

        Args:
            signals: ä¿¡å·åˆ—è¡¨
            time_window: æ—¶é—´çª—å£ï¼ˆç§’ï¼‰

        Returns:
            list: è®¢å•åˆ—è¡¨
        """
        # æŒ‰è¯„åˆ†æ’åº
        sorted_signals = sorted(signals, key=lambda x: x['score'], reverse=True)

        # å–å‰5ä¸ª
        top_signals = sorted_signals[:5]

        orders = []

        for i, sig in enumerate(top_signals):
            # è®¡ç®—å»¶è¿Ÿï¼ˆé¿å…åŒæ—¶ä¸‹å•ï¼‰
            delay = i * 10  # æ¯ä¸ªé—´éš”10ç§’

            # å»¶è¿Ÿåå¼€ä»“
            time.sleep(delay)

            order = self.manager.open_position(sig)
            if order:
                orders.append(order)

            # æ£€æŸ¥æ˜¯å¦è¶…å‡ºæ—¶é—´çª—å£
            if delay >= time_window:
                break

        return orders

# ä½¿ç”¨
# Big4ç ´ä½ï¼Œç”Ÿæˆ12ä¸ªä¿¡å·
signals = generate_signals()  # 12ä¸ªåšç©ºä¿¡å·

# æ‰¹é‡å¼€ä»“
batch_mode = BatchOpeningMode(position_manager)
orders = batch_mode.batch_open(signals, time_window=300)

# ç»“æœ:
# 08:00 DOGEå¼€ä»“
# 08:00:10 SHIBå¼€ä»“
# 08:00:20 PEPEå¼€ä»“
# 08:00:30 ARBå¼€ä»“
# 08:00:40 MATICå¼€ä»“
```

### 2. åˆ†æ‰¹å¼€ä»“æ¨¡å¼ï¼ˆè¶‹åŠ¿å»¶ç»­ï¼‰

```python
class GraduatedOpeningMode:
    """åˆ†æ‰¹å¼€ä»“æ¨¡å¼ - ç”¨äºè¶‹åŠ¿å»¶ç»­"""

    def __init__(self, position_manager):
        self.manager = position_manager

    def graduated_open(self, signals):
        """
        åˆ†æ‰¹å¼€ä»“

        Args:
            signals: ä¿¡å·åˆ—è¡¨

        Returns:
            list: è®¢å•åˆ—è¡¨
        """
        orders = []

        # ç¬¬ä¸€æ‰¹: ç«‹å³å¼€2ä¸ª
        batch1 = signals[:2]
        for sig in batch1:
            order = self.manager.open_position(sig)
            if order:
                orders.append(order)

        # ç­‰å¾…5åˆ†é’Ÿï¼Œè§‚å¯Ÿè¶‹åŠ¿
        time.sleep(5 * 60)

        # æ£€æŸ¥è¶‹åŠ¿æ˜¯å¦å»¶ç»­
        if self.is_trend_continuing():
            # ç¬¬äºŒæ‰¹: å†å¼€2ä¸ª
            batch2 = signals[2:4]
            for sig in batch2:
                order = self.manager.open_position(sig)
                if order:
                    orders.append(order)

            # å†ç­‰å¾…5åˆ†é’Ÿ
            time.sleep(5 * 60)

            # è¶‹åŠ¿åŠ é€Ÿ
            if self.is_trend_accelerating():
                # ç¬¬ä¸‰æ‰¹: æœ€å1ä¸ª
                batch3 = signals[4:5]
                for sig in batch3:
                    order = self.manager.open_position(sig)
                    if order:
                        orders.append(order)

        return orders
```

---

## ğŸ›¡ï¸ é£é™©æ§åˆ¶

### 1. æ€»ä»“ä½é™åˆ¶

```python
# ç¡¬æ€§é™åˆ¶
MAX_TOTAL_USAGE = 0.8  # æœ€å¤šä½¿ç”¨80%èµ„é‡‘

# æ£€æŸ¥
total_used = sum([p['margin'] for p in positions.values()])
if total_used >= total_capital * MAX_TOTAL_USAGE:
    reject_new_position()
```

### 2. å•å¸ç§é™åˆ¶

```python
# å•ä¸ªå¸ç§æœ€å¤šå 25%
MAX_PER_POSITION = 0.25

# æ£€æŸ¥
if position_size > total_capital * MAX_PER_POSITION:
    position_size = total_capital * MAX_PER_POSITION
```

### 3. ç›¸å…³æ€§æ£€æŸ¥

```python
def check_correlation(new_symbol, existing_positions):
    """
    æ£€æŸ¥ç›¸å…³æ€§ - é¿å…æŒæœ‰é«˜åº¦ç›¸å…³çš„å¸ç§

    Args:
        new_symbol: æ–°å¸ç§
        existing_positions: ç°æœ‰æŒä»“

    Returns:
        bool: æ˜¯å¦å¯ä»¥å¼€ä»“
    """
    # é«˜åº¦ç›¸å…³çš„å¸ç§ç»„
    correlated_groups = [
        ['DOGE/USDT', 'SHIB/USDT', 'PEPE/USDT'],  # Memeå¸
        ['ARB/USDT', 'OP/USDT'],                  # L2å¸
        ['LINK/USDT', 'UNI/USDT', 'AAVE/USDT']   # DeFiå¸
    ]

    # æŸ¥æ‰¾æ–°å¸ç§æ‰€å±ç»„
    new_group = None
    for group in correlated_groups:
        if new_symbol in group:
            new_group = group
            break

    if not new_group:
        return True  # ä¸åœ¨ç›¸å…³ç»„ï¼Œå¯ä»¥å¼€ä»“

    # æ£€æŸ¥ç°æœ‰æŒä»“ä¸­æ˜¯å¦å·²æœ‰åŒç»„å¸ç§
    same_group_count = sum([
        1 for p in existing_positions
        if p['symbol'] in new_group
    ])

    # åŒç»„æœ€å¤š2ä¸ª
    if same_group_count >= 2:
        return False

    return True

# ä½¿ç”¨
if not check_correlation('SHIB/USDT', existing_positions):
    logger.warning("SHIBä¸ç°æœ‰æŒä»“é«˜åº¦ç›¸å…³ï¼Œè·³è¿‡")
    skip()
```

### 4. åŠ¨æ€è°ƒæ•´

```python
class DynamicPositionAdjuster:
    """åŠ¨æ€ä»“ä½è°ƒæ•´å™¨"""

    def adjust_max_positions(self, market_condition):
        """
        æ ¹æ®å¸‚åœºçŠ¶å†µåŠ¨æ€è°ƒæ•´æœ€å¤§ä»“ä½æ•°

        Args:
            market_condition: å¸‚åœºçŠ¶å†µ

        Returns:
            int: æœ€å¤§ä»“ä½æ•°
        """
        if market_condition['volatility'] == 'HIGH':
            # é«˜æ³¢åŠ¨ï¼Œå‡å°‘ä»“ä½æ•°
            return 3
        elif market_condition['volatility'] == 'MEDIUM':
            # ä¸­ç­‰æ³¢åŠ¨ï¼Œæ­£å¸¸ä»“ä½æ•°
            return 5
        else:
            # ä½æ³¢åŠ¨ï¼Œå¯ä»¥å¢åŠ ä»“ä½æ•°
            return 7

# ä½¿ç”¨
market = analyze_market_condition()
max_positions = adjuster.adjust_max_positions(market)

if market['volatility'] == 'HIGH':
    logger.warning(f"å¸‚åœºé«˜æ³¢åŠ¨ï¼Œé™åˆ¶ä»“ä½æ•°ä¸º{max_positions}")
```

---

## ğŸ“Š å®æˆ˜ç¤ºä¾‹

### åœºæ™¯: 2026-02-06 08:00 Big4ç ´ä½

```python
# åˆå§‹çŠ¶æ€
capital = 10000
position_manager = MultiPositionManager(capital)

# Big4ç ´ä½æ£€æµ‹
big4_result = big4_detector.detect_market_direction()
# æ–¹å‘: SHORT, å¼ºåº¦: 95

# ç”Ÿæˆä¿¡å·
signals = signal_generator.generate_signals(all_symbols)
# æ‰¾åˆ°12ä¸ªåšç©ºä¿¡å·

# æŒ‰è¯„åˆ†æ’åº
sorted_signals = sorted(signals, key=lambda x: x['score'], reverse=True)

print("ä¿¡å·åˆ—è¡¨:")
for i, sig in enumerate(sorted_signals[:8], 1):
    print(f"{i}. {sig['symbol']}: {sig['score']}åˆ†")

# è¾“å‡º:
# 1. DOGE/USDT: 110åˆ†
# 2. SHIB/USDT: 105åˆ†
# 3. PEPE/USDT: 100åˆ†
# 4. ARB/USDT: 95åˆ†
# 5. MATIC/USDT: 90åˆ†
# 6. LINK/USDT: 88åˆ†
# 7. UNI/USDT: 85åˆ†
# 8. AVAX/USDT: 82åˆ†

# æ‰¹é‡å¼€ä»“ï¼ˆå‰5ä¸ªï¼‰
batch_mode = BatchOpeningMode(position_manager)
orders = batch_mode.batch_open(sorted_signals[:5])

# å¼€ä»“ç»“æœ:
print("\nå¼€ä»“ç»“æœ:")
for symbol, position in position_manager.positions.items():
    print(f"{symbol}: {position['margin']}U")

# è¾“å‡º:
# DOGE/USDT: 1760U (110/500 * 8000)
# SHIB/USDT: 1680U (105/500 * 8000)
# PEPE/USDT: 1600U (100/500 * 8000)
# ARB/USDT: 1520U (95/500 * 8000)
# MATIC/USDT: 1440U (90/500 * 8000)
# æ€»è®¡: 8000U (80%èµ„é‡‘)

# å‡è®¾è¡Œæƒ…:
# DOGE: -8%
# SHIB: -12%
# PEPE: -10%
# ARB: -6%
# MATIC: -9%

# æ”¶ç›Šè®¡ç®—:
pnl = (
    1760 * 0.08 +
    1680 * 0.12 +
    1600 * 0.10 +
    1520 * 0.06 +
    1440 * 0.09
)
# = 140.8 + 201.6 + 160 + 91.2 + 129.6 = 723.2U

print(f"\næ€»æ”¶ç›Š: {pnl}U ({pnl/10000*100:.2f}%)")
# æ€»æ”¶ç›Š: 723.2U (7.23%)

# å¯¹æ¯”å•ä»“:
# å¦‚æœåªåšDOGE 8000U:
# æ”¶ç›Š = 8000 * 0.08 = 640U (6.4%)

# ç»“è®º: å¤šä»“æ”¶ç›Šæ›´é«˜ï¼Œé£é™©æ›´åˆ†æ•£
```

---

## ğŸ“ é…ç½®å»ºè®®

### ä¿å®ˆå‹

```python
CONFIG_CONSERVATIVE = {
    'max_same_direction': 3,      # æœ€å¤š3ä¸ªåŒå‘ä»“ä½
    'total_capital_usage': 0.6,   # ä½¿ç”¨60%èµ„é‡‘
    'per_position_limit': 0.3,    # å•ä»“æœ€å¤š30%
    'min_position_interval': 300, # æœ€å°é—´éš”5åˆ†é’Ÿ
}
```

### å¹³è¡¡å‹ï¼ˆæ¨èï¼‰

```python
CONFIG_BALANCED = {
    'max_same_direction': 5,      # æœ€å¤š5ä¸ªåŒå‘ä»“ä½
    'total_capital_usage': 0.8,   # ä½¿ç”¨80%èµ„é‡‘
    'per_position_limit': 0.25,   # å•ä»“æœ€å¤š25%
    'min_position_interval': 180, # æœ€å°é—´éš”3åˆ†é’Ÿ
}
```

### æ¿€è¿›å‹

```python
CONFIG_AGGRESSIVE = {
    'max_same_direction': 7,      # æœ€å¤š7ä¸ªåŒå‘ä»“ä½
    'total_capital_usage': 0.9,   # ä½¿ç”¨90%èµ„é‡‘
    'per_position_limit': 0.2,    # å•ä»“æœ€å¤š20%
    'min_position_interval': 60,  # æœ€å°é—´éš”1åˆ†é’Ÿ
}
```

---

## ğŸ¯ æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **åŒæ–¹å‘å¯ä»¥æŒæœ‰å¤šä¸ªä»“ä½** (3-5ä¸ª)
   - æœºä¼šé›†ä¸­çˆ†å‘ï¼Œä¸æ˜¯çº¿æ€§ç­‰å¾…
   - åˆ†æ•£é£é™©
   - æé«˜æ”¶ç›Š

2. **æ€»ä»“ä½å¿…é¡»æ§åˆ¶** (â‰¤80%)
   - é¿å…è¿‡åº¦æ æ†
   - ä¿ç•™åº”æ€¥èµ„é‡‘

3. **å•å¸ç§æœ‰é™é¢** (â‰¤25%)
   - é¿å…å•ä¸€æ ‡çš„é£é™©
   - ç¡®ä¿åˆ†æ•£

4. **åŠ¨æ€è°ƒæ•´å¾ˆé‡è¦**
   - æ ¹æ®å¸‚åœºæ³¢åŠ¨è°ƒæ•´ä»“ä½æ•°
   - æ ¹æ®ä¿¡å·è¯„åˆ†åˆ†é…èµ„é‡‘
   - æ ¹æ®ç›¸å…³æ€§é¿å…é‡å¤

5. **å¼€ä»“æ—¶æœºè¦æ§åˆ¶**
   - ç ´ä½æ—¶æ‰¹é‡å¼€ä»“
   - è¶‹åŠ¿å»¶ç»­æ—¶åˆ†æ‰¹å¼€ä»“
   - é¿å…åŒæ—¶ä¸‹å•
