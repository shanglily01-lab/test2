# è¶…çº§å¤§è„‘å®Œæ•´ä¼˜åŒ–å®æ–½æ–¹æ¡ˆ

> **åˆ›å»ºæ—¥æœŸ**: 2026-02-08
> **çŠ¶æ€**: ğŸš€ ç«‹å³æ‰§è¡Œ
> **ç›®æ ‡**: è§£å†³"ä¸èµšé’±ã€èµšå¾—å°‘ã€äºå¾—å¤š"çš„æ ¸å¿ƒé—®é¢˜
> **é¢„æœŸæ”¹å–„**: +7,800U/æœˆ

---

## ğŸ“Š Executive Summary

### å½“å‰é—®é¢˜
- âŒ æ—¥å‡äºæŸ -2,700U
- âŒ èƒœç‡ä»…34.66%
- âŒ è·Ÿè¿›å»è¢«åè½¬
- âŒ æœºä¼šæ²¡æŠ“ä½ï¼ˆè¿½é«˜ä¹°å…¥ï¼Œé”™è¿‡å›è°ƒï¼‰

### æˆåŠŸæ¡ˆä¾‹ï¼ˆ2æœˆ5æ—¥ï¼‰
- âœ… Big4å•å‘çœ‹ç©º â†’ ä¸€ç›´åšç©º
- âœ… èƒœç‡74.81% â†’ +2,995U

### ä¼˜åŒ–åç›®æ ‡
- âœ… æ—¥äº¤æ˜“150ç¬”ï¼ˆä»200+é™ä½ï¼‰
- âœ… æŒä»“3å°æ—¶ï¼ˆä»4å°æ—¶ç¼©çŸ­ï¼‰
- âœ… æ—¥ç›ˆäº +50~200U
- âœ… æœˆåº¦ç›ˆåˆ© +1,500~6,000U

---

## ğŸ¯ æ ¸å¿ƒç­–ç•¥è°ƒæ•´

### å®æˆ˜ç»éªŒæ€»ç»“

**æœ€ä½³å¼€ä»“æ—¶æœº**:
1. ä»·æ ¼çªç„¶æ‹‰èµ·/ä¸‹è·Œ + æ”¾é‡ â†’ ç«‹å³è·Ÿè¿› â­â­â­â­â­
2. å·²ç»æ¶¨èµ·æ¥çš„ â†’ ç­‰å›è°ƒå†ä¹°å…¥ â­â­â­â­â­

**äº¤æ˜“èŠ‚å¥**:
- 15Mä¸ºä¸»å¯¼ï¼ˆå¿«é€Ÿå“åº”ï¼‰
- Big4çœ‹é‡å¤§äº‹ä»¶ï¼ˆä¿ç•™å¦å†³æƒï¼‰
- 3å°æ—¶æŒä»“å‘¨æœŸ

---

## ğŸš€ ç¬¬ä¸€é˜¶æ®µ: å¿«é€Ÿä¿®å¤ï¼ˆ1å¤©ï¼‰

### ä¼˜åŒ–1.1: åŠ¨æ€åè½¬æ­¢æŸ â­â­â­â­â­

**é—®é¢˜**: è·Ÿè¿›å»è¢«åè½¬ â†’ ç­‰-3%æ­¢æŸå¤ªæ…¢ â†’ äºæŸæ‰©å¤§

**è§£å†³æ–¹æ¡ˆ**: æ£€æµ‹åˆ°åè½¬ä¿¡å· â†’ ç«‹å³æ­¢æŸ-1%

#### æ ¸å¿ƒé€»è¾‘

```python
æ£€æµ‹åè½¬æ¡ä»¶:
1. æŒä»“LONGï¼Œä½†è¿ç»­2æ ¹5Mé˜´çº¿ + æ”¾é‡1.3x + è·Œå¹…0.8%
2. æŒä»“SHORTï¼Œä½†è¿ç»­2æ ¹5Mé˜³çº¿ + æ”¾é‡1.3x + æ¶¨å¹…0.8%
3. å½“å‰æµ®ç›ˆ < 1%

â†’ ç«‹å³æ­¢æŸ-1%
```

#### å®ç°ä»£ç 

**æ–‡ä»¶**: `app/services/dynamic_stop_loss_v2.py` (æ–°å»º)

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
åŠ¨æ€æ­¢æŸç®¡ç†å™¨ V2.0
é˜²æ­¢"è·Ÿè¿›å»è¢«åè½¬"
"""

import asyncio
from datetime import datetime
from typing import Dict, Optional


class DynamicStopLossV2:
    """åŠ¨æ€æ­¢æŸç®¡ç†å™¨ - é˜²æ­¢è¢«åè½¬"""

    def __init__(self):
        self.fixed_stop_loss = 0.03      # å›ºå®šæ­¢æŸ-3%
        self.reversal_stop_loss = 0.01   # åè½¬æ­¢æŸ-1%
        self.reversal_volume_ratio = 1.3  # åè½¬é‡èƒ½é˜ˆå€¼
        self.reversal_price_change = 0.008  # åè½¬ä»·æ ¼å˜åŒ–é˜ˆå€¼0.8%

    def check_reversal_signal(self, position: Dict, klines_5m: list, current_price: float) -> Dict:
        """
        æ£€æµ‹åè½¬ä¿¡å·

        Args:
            position: æŒä»“ä¿¡æ¯
            klines_5m: æœ€è¿‘5æ ¹5M Kçº¿
            current_price: å½“å‰ä»·æ ¼

        Returns:
            {
                'detected': True/False,
                'reason': 'è¿ç»­2æ ¹5Mé˜´çº¿+æ”¾é‡1.3x+è·Œå¹…0.85%',
                'should_close': True/False,
                'reversal_strength': 0-100
            }
        """
        position_side = position['position_side']
        entry_price = position['avg_entry_price']

        # è®¡ç®—å½“å‰ç›ˆäº
        if position_side == 'LONG':
            pnl_pct = (current_price - entry_price) / entry_price
        else:
            pnl_pct = (entry_price - current_price) / entry_price

        # å¦‚æœå·²ç»ç›ˆåˆ©>1%ï¼Œä¸ç”¨åè½¬æ­¢æŸï¼ˆè®©åˆ©æ¶¦å¥”è·‘ï¼‰
        if pnl_pct > 0.01:
            return {'detected': False, 'reason': 'æµ®ç›ˆ>1%, è®©åˆ©æ¶¦å¥”è·‘'}

        if len(klines_5m) < 5:
            return {'detected': False, 'reason': 'Kçº¿æ•°æ®ä¸è¶³'}

        # æœ€è¿‘2æ ¹Kçº¿
        recent_2 = klines_5m[:2]

        # è®¡ç®—é‡èƒ½æ¯”ç‡
        recent_volume = sum(k['volume'] for k in recent_2) / 2
        baseline_volume = sum(k['volume'] for k in klines_5m[2:5]) / 3
        volume_ratio = recent_volume / baseline_volume if baseline_volume > 0 else 0

        # åšå¤šåœºæ™¯ï¼šæ£€æµ‹è¿ç»­é˜´çº¿
        if position_side == 'LONG':
            # æ£€æŸ¥æ˜¯å¦éƒ½æ˜¯é˜´çº¿
            is_reversal = all(k['close'] < k['open'] for k in recent_2)

            if is_reversal and volume_ratio >= self.reversal_volume_ratio:
                # è®¡ç®—2æ ¹Kçº¿çš„è·Œå¹…
                price_drop = sum((k['open'] - k['close']) / k['open'] for k in recent_2)

                if price_drop >= self.reversal_price_change:
                    strength = min(100, int(volume_ratio * 30 + price_drop * 1000))
                    return {
                        'detected': True,
                        'reason': f'è¿ç»­2æ ¹5Mé˜´çº¿+æ”¾é‡{volume_ratio:.1f}x+è·Œå¹…{price_drop*100:.2f}%',
                        'should_close': True,
                        'reversal_strength': strength,
                        'volume_ratio': volume_ratio,
                        'price_change': -price_drop
                    }

        # åšç©ºåœºæ™¯ï¼šæ£€æµ‹è¿ç»­é˜³çº¿
        elif position_side == 'SHORT':
            is_reversal = all(k['close'] > k['open'] for k in recent_2)

            if is_reversal and volume_ratio >= self.reversal_volume_ratio:
                price_rise = sum((k['close'] - k['open']) / k['open'] for k in recent_2)

                if price_rise >= self.reversal_price_change:
                    strength = min(100, int(volume_ratio * 30 + price_rise * 1000))
                    return {
                        'detected': True,
                        'reason': f'è¿ç»­2æ ¹5Mé˜³çº¿+æ”¾é‡{volume_ratio:.1f}x+æ¶¨å¹…{price_rise*100:.2f}%',
                        'should_close': True,
                        'reversal_strength': strength,
                        'volume_ratio': volume_ratio,
                        'price_change': price_rise
                    }

        return {'detected': False}

    def calculate_stop_loss_price(self, position: Dict) -> Dict:
        """
        è®¡ç®—æ­¢æŸä»·æ ¼

        Returns:
            {
                'fixed_stop': 97000.0,      # å›ºå®šæ­¢æŸ-3%
                'reversal_stop': 99000.0    # åè½¬æ­¢æŸ-1%
            }
        """
        entry_price = position['avg_entry_price']
        position_side = position['position_side']

        if position_side == 'LONG':
            fixed_stop = entry_price * (1 - self.fixed_stop_loss)
            reversal_stop = entry_price * (1 - self.reversal_stop_loss)
        else:
            fixed_stop = entry_price * (1 + self.fixed_stop_loss)
            reversal_stop = entry_price * (1 + self.reversal_stop_loss)

        return {
            'fixed_stop': fixed_stop,
            'reversal_stop': reversal_stop
        }
```

#### é›†æˆåˆ°ä¸»æœåŠ¡

**æ–‡ä»¶**: `smart_trader_service.py` (ä¿®æ”¹)

åœ¨æŒä»“ç›‘æ§å¾ªç¯ä¸­æ·»åŠ åè½¬æ£€æµ‹:

```python
from app.services.dynamic_stop_loss_v2 import DynamicStopLossV2

class SmartTraderService:
    def __init__(self):
        # ... ç°æœ‰ä»£ç 
        self.dynamic_stop_loss = DynamicStopLossV2()

    async def monitor_position(self, position):
        """æŒä»“ç›‘æ§å¾ªç¯"""
        while True:
            current_price = self.get_current_price(position['symbol'])

            # 1. æ£€æŸ¥å›ºå®šæ­¢æŸæ­¢ç›ˆ
            # ... ç°æœ‰ä»£ç 

            # 2. ğŸ”¥ æ£€æŸ¥åè½¬æ­¢æŸ (æ–°å¢)
            klines_5m = self.exchange.get_klines(position['symbol'], '5m', 5)
            reversal = self.dynamic_stop_loss.check_reversal_signal(
                position, klines_5m, current_price
            )

            if reversal['detected'] and reversal['should_close']:
                logger.warning(
                    f"[åè½¬æ­¢æŸ] {position['symbol']} {position['position_side']} "
                    f"{reversal['reason']}"
                )

                # è®¡ç®—åè½¬æ­¢æŸä»·
                stop_prices = self.dynamic_stop_loss.calculate_stop_loss_price(position)

                # æ£€æŸ¥æ˜¯å¦è§¦å‘åè½¬æ­¢æŸ
                if position['position_side'] == 'LONG':
                    if current_price <= stop_prices['reversal_stop']:
                        await self.close_position(
                            position['id'],
                            current_price,
                            f"åè½¬æ­¢æŸ-1%: {reversal['reason']}"
                        )
                        break
                else:
                    if current_price >= stop_prices['reversal_stop']:
                        await self.close_position(
                            position['id'],
                            current_price,
                            f"åè½¬æ­¢æŸ-1%: {reversal['reason']}"
                        )
                        break

            # 3. æ£€æŸ¥ç§»åŠ¨æ­¢ç›ˆ
            # ... ç°æœ‰ä»£ç 

            await asyncio.sleep(30)  # æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
```

#### é¢„æœŸæ•ˆæœ
- å‡å°‘æ¯ç¬”äºæŸ: 3% â†’ 1% (å‡å°‘2%)
- æœˆåº¦å‡å°‘äºæŸ: **~800U**

---

### ä¼˜åŒ–1.2: è¯„åˆ†é˜ˆå€¼è°ƒæ•´

**æ–‡ä»¶**: `app/strategies/signal_scorer_v3.py`

```python
# è¡Œå·çº¦34
self.min_score_to_trade = 25  # å½“å‰

# ä¿®æ”¹ä¸º
self.min_score_to_trade = 26  # æå‡1åˆ†ï¼Œç­›é™¤è¾¹ç¼˜ä¿¡å·
```

#### é¢„æœŸæ•ˆæœ
- æœˆåº¦æ”¹å–„: **+300U**

---

### ä¼˜åŒ–1.3: æŒä»“æ—¶é—´ç¼©çŸ­åˆ°3å°æ—¶

**æ–‡ä»¶**: `smart_trader_service.py`, `coin_futures_trader_service.py`

```python
# æœç´¢ max_hold_minutes
max_hold_minutes = 240  # å½“å‰4å°æ—¶

# ä¿®æ”¹ä¸º
max_hold_minutes = 180  # 3å°æ—¶

# åŒæ—¶è°ƒæ•´è¶…æ—¶æ£€æŸ¥:
def check_timeout_close(self, position, holding_minutes):
    """è¶…æ—¶æ£€æŸ¥"""
    unrealized_pnl_pct = position['unrealized_pnl_pct']

    # 1Hæ£€æŸ¥: äºæŸ > 1%
    if holding_minutes >= 60:
        if unrealized_pnl_pct < -0.01:
            return True, "1Hè¶…æ—¶-äºæŸ>1%"

    # 2Hæ£€æŸ¥: äºæŸ > 0%
    if holding_minutes >= 120:
        if unrealized_pnl_pct < 0:
            return True, "2Hè¶…æ—¶-æœªç›ˆåˆ©"

    # 3Hå¼ºåˆ¶å¹³ä»“
    if holding_minutes >= 180:
        return True, "3Hè¶…æ—¶-å¼ºåˆ¶å¹³ä»“"

    return False, None
```

#### é¢„æœŸæ•ˆæœ
- æœˆåº¦æ”¹å–„: **+200U**

---

**ç¬¬ä¸€é˜¶æ®µæ€»é¢„æœŸ**: **+1,300U/æœˆ**

---

## ğŸ”¥ ç¬¬äºŒé˜¶æ®µ: æ ¸å¿ƒåŠŸèƒ½ï¼ˆ2-3å¤©ï¼‰

### ä¼˜åŒ–2.1: çªç„¶æ‹‰å‡æ£€æµ‹å™¨ â­â­â­â­â­

**ç›®æ ‡**: æŠ“ä½ä»·æ ¼çªç„¶æ‹‰èµ·/ä¸‹è·Œ + æ”¾é‡ â†’ ç«‹å³è·Ÿè¿›

#### æ ¸å¿ƒé€»è¾‘

```python
æ£€æµ‹æ¡ä»¶:
1. 5Mæˆ–15Mæ—¶é—´å‘¨æœŸ
2. æœ€è¿‘1-3æ ¹Kçº¿ä»·æ ¼å˜åŒ– >= 1%
3. é‡èƒ½æ¯”ç‡ >= 1.5x
4. Big4ä¸å¼ºçƒˆç›¸åï¼ˆå¼ºåº¦<10æ—¶å¿½ç•¥ï¼‰

å¼€ä»“æ¡ä»¶:
- æ‹‰å‡å¼ºåº¦ >= 30
- å¦‚æœBig4ç›¸åï¼Œå¼ºåº¦éœ€ >= 60
```

#### å®ç°ä»£ç 

**æ–‡ä»¶**: `app/detectors/sudden_move_detector.py` (æ–°å»º)

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
çªç„¶æ‹‰å‡/ä¸‹è·Œæ£€æµ‹å™¨
"""

from typing import Dict, Optional, List
import logging

logger = logging.getLogger(__name__)


class SuddenMoveDetector:
    """çªç„¶æ‹‰å‡/ä¸‹è·Œæ£€æµ‹å™¨"""

    def __init__(self):
        self.timeframes = ['5m', '15m']
        self.min_price_change = 0.01      # æœ€å°ä»·æ ¼å˜åŒ–1%
        self.min_volume_ratio = 1.5       # æœ€å°é‡èƒ½æ¯”1.5x
        self.min_strength = 30            # æœ€å°å¼ºåº¦30
        self.veto_threshold = 60          # Big4å¦å†³éœ€è¦çš„å¼ºåº¦

    def detect_sudden_move(self, symbol: str, exchange) -> Dict:
        """
        æ£€æµ‹çªç„¶æ‹‰å‡/ä¸‹è·Œ

        Returns:
            {
                'detected': True/False,
                'direction': 'LONG'/'SHORT',
                'strength': 0-100,
                'timeframe': '5m'/'15m',
                'window': 1-3,  # å‡ æ ¹Kçº¿
                'price_change': 0.015,
                'volume_ratio': 2.3
            }
        """
        result = {'detected': False}

        for tf in self.timeframes:
            # è·å–æœ€è¿‘5æ ¹Kçº¿
            klines = exchange.get_klines(symbol, tf, limit=8)
            if len(klines) < 8:
                continue

            # æ£€æŸ¥ä¸åŒçª—å£ï¼ˆ1æ ¹ã€2æ ¹ã€3æ ¹Kçº¿ï¼‰
            for window in [1, 2, 3]:
                recent = klines[:window]

                # è®¡ç®—ä»·æ ¼å˜åŒ–
                if window == 1:
                    price_change = (recent[0]['close'] - recent[0]['open']) / recent[0]['open']
                else:
                    price_change = (recent[0]['close'] - recent[-1]['open']) / recent[-1]['open']

                # è®¡ç®—é‡èƒ½æ¯”ç‡
                recent_volume = sum(k['volume'] for k in recent) / window
                baseline_volume = sum(k['volume'] for k in klines[window:window+5]) / 5
                volume_ratio = recent_volume / baseline_volume if baseline_volume > 0 else 0

                # åšå¤šåœºæ™¯ï¼šçªç„¶æ‹‰å‡
                if price_change >= self.min_price_change and volume_ratio >= self.min_volume_ratio:
                    strength = min(100, int(abs(price_change) * 100 * volume_ratio))

                    result = {
                        'detected': True,
                        'direction': 'LONG',
                        'strength': strength,
                        'timeframe': tf,
                        'window': window,
                        'price_change': price_change,
                        'volume_ratio': volume_ratio
                    }

                    logger.info(
                        f"[çªç„¶æ‹‰å‡] {symbol} {tf} {window}æ ¹Kçº¿ "
                        f"æ¶¨å¹…{price_change*100:.2f}% é‡èƒ½{volume_ratio:.1f}x å¼ºåº¦{strength}"
                    )
                    return result

                # åšç©ºåœºæ™¯ï¼šçªç„¶ä¸‹è·Œ
                elif price_change <= -self.min_price_change and volume_ratio >= self.min_volume_ratio:
                    strength = min(100, int(abs(price_change) * 100 * volume_ratio))

                    result = {
                        'detected': True,
                        'direction': 'SHORT',
                        'strength': strength,
                        'timeframe': tf,
                        'window': window,
                        'price_change': price_change,
                        'volume_ratio': volume_ratio
                    }

                    logger.info(
                        f"[çªç„¶ä¸‹è·Œ] {symbol} {tf} {window}æ ¹Kçº¿ "
                        f"è·Œå¹…{abs(price_change)*100:.2f}% é‡èƒ½{volume_ratio:.1f}x å¼ºåº¦{strength}"
                    )
                    return result

        return result

    def should_open_position(
        self,
        sudden_move: Dict,
        big4_signal: Optional[Dict] = None
    ) -> tuple[bool, Optional[Dict]]:
        """
        åˆ¤æ–­æ˜¯å¦åº”è¯¥å¼€ä»“

        Args:
            sudden_move: æ‹‰å‡æ£€æµ‹ç»“æœ
            big4_signal: Big4ä¿¡å· {'signal': 'BULLISH', 'strength': 65}

        Returns:
            (should_open, reason)
        """
        if not sudden_move.get('detected'):
            return False, None

        # å¼ºåº¦æ£€æŸ¥
        if sudden_move['strength'] < self.min_strength:
            return False, {'reason': f"å¼ºåº¦ä¸è¶³({sudden_move['strength']}<{self.min_strength})"}

        # Big4æ£€æŸ¥
        if big4_signal and big4_signal.get('strength', 0) >= 10:
            big4_direction = 'LONG' if 'BULL' in big4_signal['signal'].upper() else 'SHORT'

            if big4_direction != sudden_move['direction']:
                # Big4ç›¸åï¼Œéœ€è¦æ›´é«˜çš„å¼ºåº¦
                if sudden_move['strength'] < self.veto_threshold:
                    return False, {
                        'reason': f"Big4ç›¸åä¸”å¼ºåº¦ä¸è¶³({sudden_move['strength']}<{self.veto_threshold})"
                    }

        # é€šè¿‡æ‰€æœ‰æ£€æŸ¥
        return True, {
            'signal_type': 'sudden_move',
            'direction': sudden_move['direction'],
            'timeframe': sudden_move['timeframe'],
            'window': sudden_move['window'],
            'price_change': sudden_move['price_change'],
            'volume_ratio': sudden_move['volume_ratio'],
            'strength': sudden_move['strength']
        }
```

#### é›†æˆåˆ°ä¸»æœåŠ¡

**æ–‡ä»¶**: `smart_trader_service.py`

```python
from app.detectors.sudden_move_detector import SuddenMoveDetector

class SmartTraderService:
    def __init__(self):
        # ... ç°æœ‰ä»£ç 
        self.sudden_move_detector = SuddenMoveDetector()

    async def evaluate_opportunities(self):
        """è¯„ä¼°å¼€ä»“æœºä¼š"""
        opportunities = []

        for symbol in self.active_symbols:
            # 1. ğŸ”¥ ä¼˜å…ˆæ£€æµ‹çªç„¶æ‹‰å‡ï¼ˆæ–°å¢ï¼‰
            sudden_move = self.sudden_move_detector.detect_sudden_move(
                symbol, self.exchange
            )

            if sudden_move['detected']:
                big4 = self.get_latest_big4_signal()
                should_open, signal_info = self.sudden_move_detector.should_open_position(
                    sudden_move, big4
                )

                if should_open:
                    opportunities.append({
                        'symbol': symbol,
                        'side': sudden_move['direction'],
                        'signal_type': 'sudden_move',
                        'score': sudden_move['strength'],  # å¼ºåº¦ä½œä¸ºåˆ†æ•°
                        'signal_info': signal_info,
                        'priority': 100  # æœ€é«˜ä¼˜å…ˆçº§
                    })
                    logger.info(f"[çªç„¶æ‹‰å‡ä¿¡å·] {symbol} {sudden_move['direction']}")
                    continue  # æ‰¾åˆ°æ‹‰å‡ä¿¡å·å°±è·³è¿‡å¸¸è§„è¯„åˆ†

            # 2. å¸¸è§„è¯„åˆ†ç³»ç»Ÿ
            # ... ç°æœ‰ä»£ç 

        return opportunities
```

#### é¢„æœŸæ•ˆæœ
- æ—©æœŸå…¥åœºï¼Œæˆæœ¬ä¼˜åŠ¿1-2%
- æœˆåº¦å¢åŠ ç›ˆåˆ©: **+1,500U**

---

### ä¼˜åŒ–2.2: å›è°ƒä¹°å…¥æ£€æµ‹å™¨ â­â­â­â­â­

**ç›®æ ‡**: æ¶¨èµ·æ¥çš„ â†’ ç­‰å›è°ƒå†ä¹°å…¥

#### æ ¸å¿ƒé€»è¾‘

```python
æ£€æµ‹æ¡ä»¶:
1. æœ€è¿‘2Hå†…æœ‰æœ€é«˜ä»·/æœ€ä½ä»·
2. å½“å‰ä»·æ ¼å›è°ƒ1.5-4%
3. å‡ºç°ç¬¬ä¸€æ ¹5Måå¼¹Kçº¿
4. Big4ä¸å¼ºçƒˆç›¸å
5. ä»·æ ¼ä½ç½®åœ¨24HåŒºé—´30-70%
```

#### å®ç°ä»£ç 

**æ–‡ä»¶**: `app/detectors/pullback_detector.py` (æ–°å»º)

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
å›è°ƒä¹°å…¥æ£€æµ‹å™¨
"""

from typing import Dict, Optional
import logging

logger = logging.getLogger(__name__)


class PullbackDetector:
    """å›è°ƒä¹°å…¥æ£€æµ‹å™¨"""

    def __init__(self):
        self.min_pullback = 0.015      # æœ€å°å›è°ƒ1.5%
        self.max_pullback = 0.04       # æœ€å¤§å›è°ƒ4%
        self.min_quality = 40          # æœ€å°å…¥åœºè´¨é‡

    def detect_pullback_opportunity(self, symbol: str, exchange) -> Dict:
        """
        æ£€æµ‹å›è°ƒä¹°å…¥æœºä¼š

        Returns:
            {
                'detected': True/False,
                'direction': 'LONG'/'SHORT',
                'pullback_pct': 0.025,
                'bounce_confirmed': True,
                'entry_quality': 0-100,
                'high_2h': 102000,
                'current_price': 100500
            }
        """
        # 1. è·å–æœ€è¿‘2Hçš„5M Kçº¿ï¼ˆ24æ ¹ï¼‰
        klines_5m = exchange.get_klines(symbol, '5m', limit=24)
        if len(klines_5m) < 24:
            return {'detected': False}

        # 2. è®¡ç®—2Hæœ€é«˜ä»·å’Œæœ€ä½ä»·
        high_2h = max(k['high'] for k in klines_5m)
        low_2h = min(k['low'] for k in klines_5m)
        current_price = klines_5m[0]['close']

        # 3. åšå¤šåœºæ™¯ï¼šä»æœ€é«˜ç‚¹å›è°ƒ
        pullback_from_high = (high_2h - current_price) / high_2h

        if self.min_pullback <= pullback_from_high <= self.max_pullback:
            # æ£€æŸ¥æ˜¯å¦æœ‰åå¼¹ç¡®è®¤ï¼ˆæœ€æ–°Kçº¿æ˜¯é˜³çº¿ï¼‰
            latest_candle = klines_5m[0]
            is_bounce = latest_candle['close'] > latest_candle['open']

            if is_bounce:
                # è®¡ç®—å…¥åœºè´¨é‡
                bounce_strength = (latest_candle['close'] - latest_candle['open']) / latest_candle['open']
                quality = min(100, int(pullback_from_high * 100 * 20 + bounce_strength * 100 * 10))

                logger.info(
                    f"[å›è°ƒä¹°å…¥-åšå¤š] {symbol} "
                    f"ä»{high_2h:.2f}å›è°ƒ{pullback_from_high*100:.2f}%è‡³{current_price:.2f} "
                    f"è´¨é‡{quality}"
                )

                return {
                    'detected': True,
                    'direction': 'LONG',
                    'pullback_pct': pullback_from_high,
                    'bounce_confirmed': True,
                    'entry_quality': quality,
                    'high_2h': high_2h,
                    'low_2h': low_2h,
                    'current_price': current_price,
                    'bounce_strength': bounce_strength
                }

        # 4. åšç©ºåœºæ™¯ï¼šä»æœ€ä½ç‚¹åå¼¹
        pullback_from_low = (current_price - low_2h) / low_2h

        if self.min_pullback <= pullback_from_low <= self.max_pullback:
            latest_candle = klines_5m[0]
            is_bounce = latest_candle['close'] < latest_candle['open']

            if is_bounce:
                bounce_strength = (latest_candle['open'] - latest_candle['close']) / latest_candle['open']
                quality = min(100, int(pullback_from_low * 100 * 20 + bounce_strength * 100 * 10))

                logger.info(
                    f"[å›è°ƒä¹°å…¥-åšç©º] {symbol} "
                    f"ä»{low_2h:.2f}åå¼¹{pullback_from_low*100:.2f}%è‡³{current_price:.2f} "
                    f"è´¨é‡{quality}"
                )

                return {
                    'detected': True,
                    'direction': 'SHORT',
                    'pullback_pct': pullback_from_low,
                    'bounce_confirmed': True,
                    'entry_quality': quality,
                    'high_2h': high_2h,
                    'low_2h': low_2h,
                    'current_price': current_price,
                    'bounce_strength': bounce_strength
                }

        return {'detected': False}

    def should_open_position(
        self,
        pullback: Dict,
        big4_signal: Optional[Dict] = None,
        position_in_24h: Optional[float] = None
    ) -> tuple[bool, Optional[Dict]]:
        """
        åˆ¤æ–­æ˜¯å¦åº”è¯¥å¼€ä»“

        Args:
            pullback: å›è°ƒæ£€æµ‹ç»“æœ
            big4_signal: Big4ä¿¡å·
            position_in_24h: ä»·æ ¼åœ¨24HåŒºé—´çš„ä½ç½®(0-100)

        Returns:
            (should_open, reason)
        """
        if not pullback.get('detected'):
            return False, None

        # è´¨é‡æ£€æŸ¥
        if pullback['entry_quality'] < self.min_quality:
            return False, {'reason': f"å…¥åœºè´¨é‡ä¸è¶³({pullback['entry_quality']}<{self.min_quality})"}

        # Big4æ£€æŸ¥
        if big4_signal and big4_signal.get('strength', 0) >= 10:
            big4_direction = 'LONG' if 'BULL' in big4_signal['signal'].upper() else 'SHORT'
            if big4_direction != pullback['direction']:
                return False, {'reason': 'Big4æ–¹å‘ç›¸å'}

        # ä»·æ ¼ä½ç½®æ£€æŸ¥ï¼ˆé¿å…æç«¯ä½ç½®ï¼‰
        if position_in_24h is not None:
            if pullback['direction'] == 'LONG' and position_in_24h > 70:
                return False, {'reason': f"ä»·æ ¼ä½ç½®è¿‡é«˜({position_in_24h:.1f}%)"}
            elif pullback['direction'] == 'SHORT' and position_in_24h < 30:
                return False, {'reason': f"ä»·æ ¼ä½ç½®è¿‡ä½({position_in_24h:.1f}%)"}

        return True, {
            'signal_type': 'pullback_entry',
            'direction': pullback['direction'],
            'pullback_pct': pullback['pullback_pct'],
            'entry_quality': pullback['entry_quality'],
            'bounce_strength': pullback['bounce_strength']
        }
```

#### é›†æˆåˆ°ä¸»æœåŠ¡

```python
from app.detectors.pullback_detector import PullbackDetector

class SmartTraderService:
    def __init__(self):
        # ... ç°æœ‰ä»£ç 
        self.pullback_detector = PullbackDetector()

    async def evaluate_opportunities(self):
        """è¯„ä¼°å¼€ä»“æœºä¼š"""
        opportunities = []

        for symbol in self.active_symbols:
            # 1. çªç„¶æ‹‰å‡æ£€æµ‹
            # ...

            # 2. ğŸ”¥ å›è°ƒä¹°å…¥æ£€æµ‹ï¼ˆæ–°å¢ï¼‰
            pullback = self.pullback_detector.detect_pullback_opportunity(
                symbol, self.exchange
            )

            if pullback['detected']:
                big4 = self.get_latest_big4_signal()
                position_24h = self.calculate_price_position_24h(symbol)

                should_open, signal_info = self.pullback_detector.should_open_position(
                    pullback, big4, position_24h
                )

                if should_open:
                    opportunities.append({
                        'symbol': symbol,
                        'side': pullback['direction'],
                        'signal_type': 'pullback_entry',
                        'score': pullback['entry_quality'],
                        'signal_info': signal_info,
                        'priority': 90  # æ¬¡é«˜ä¼˜å…ˆçº§
                    })
                    logger.info(f"[å›è°ƒä¹°å…¥ä¿¡å·] {symbol} {pullback['direction']}")
                    continue

            # 3. å¸¸è§„è¯„åˆ†ç³»ç»Ÿ
            # ...

        return opportunities
```

#### é¢„æœŸæ•ˆæœ
- å…¥åœºæˆæœ¬ä¼˜åŒ–2-3%
- æœˆåº¦å¢åŠ ç›ˆåˆ©: **+1,200U**

---

### ä¼˜åŒ–2.3: è¯„åˆ†æƒé‡è°ƒæ•´

**ç›®æ ‡**: 15Mä¸»å¯¼ï¼ŒBig4ä¿ç•™å¦å†³æƒ

**æ–‡ä»¶**: `app/strategies/signal_scorer_v3.py`

```python
# è¡Œå·çº¦24-30
self.score_weights = {
    'big4': 3,
    '5h_trend': 7,
    '15m_signal': 12,
    'volume_price': 10,
    'technical': 10
}

# ä¿®æ”¹ä¸º
self.score_weights = {
    'big4': 5,          # 3 â†’ 5 (æå‡67%)
    '5h_trend': 6,      # 7 â†’ 6 (é™ä½14%)
    '15m_signal': 14,   # 12 â†’ 14 (æå‡17%) â† ä¸»å¯¼
    'volume_price': 10, # ä¿æŒ
    'technical': 7      # 10 â†’ 7 (é™ä½30%)
}

# æ€»åˆ†ä»ä¸º42åˆ†
# æ–°é˜ˆå€¼26åˆ†å·²åœ¨ä¼˜åŒ–1.2è®¾ç½®
```

**åŒæ—¶ä¿®å¤Big4å¼ºåº¦é˜ˆå€¼**:

```python
# è¡Œå·çº¦144-152
def score_big4(self, position_side, big4_signal, big4_strength):
    # å½“å‰é˜ˆå€¼
    if big4_strength >= 15:
        return 3.0
    elif big4_strength >= 10:
        return 2.4
    elif big4_strength >= 5:
        return 1.8

    # ä¿®æ”¹ä¸ºï¼ˆåŸºäºå®é™…è§‚å¯ŸBig4å¼ºåº¦åœ¨0-20ï¼‰
    if big4_strength >= 12:   # 15 â†’ 12
        return 5.0            # æ»¡åˆ†æ”¹ä¸º5åˆ†
    elif big4_strength >= 8:  # 10 â†’ 8
        return 4.0            # 2.4 â†’ 4.0
    elif big4_strength >= 4:  # 5 â†’ 4
        return 3.0            # 1.8 â†’ 3.0
    elif big4_strength >= 2:  # æ–°å¢
        return 2.0
    elif big4_strength > 0:
        return 1.0

    return 0.0
```

#### é¢„æœŸæ•ˆæœ
- æœˆåº¦æ”¹å–„: **+600U**

---

### ä¼˜åŒ–2.4: Big4å¦å†³æƒ

**ç›®æ ‡**: é‡å¤§äº‹ä»¶æ—¶Big4å¼ºåˆ¶å¦å†³

**æ–‡ä»¶**: `smart_trader_service.py`, `coin_futures_trader_service.py`

```python
def check_big4_veto(self, big4_signal, big4_strength, position_side):
    """
    Big4å¦å†³æœºåˆ¶

    å½“Big4å¼ºåº¦ >= 12ä¸”æ–¹å‘ç›¸åæ—¶ï¼Œç›´æ¥æ‹’ç»å¼€ä»“
    """
    if not big4_signal or big4_strength < 12:
        return False, None

    # åˆ¤æ–­Big4æ–¹å‘
    if 'BULL' in big4_signal.upper():
        big4_direction = 'LONG'
    elif 'BEAR' in big4_signal.upper():
        big4_direction = 'SHORT'
    else:
        return False, None  # NEUTRALä¸å¦å†³

    # å¦å†³é€»è¾‘
    if big4_direction != position_side:
        return True, f"Big4å¦å†³: {big4_signal}(å¼ºåº¦{big4_strength}), ç¦æ­¢{position_side}"

    return False, None

# åœ¨evaluate_opportunitiesä¸­ä½¿ç”¨
async def evaluate_opportunities(self):
    for opp in opportunities:
        # Big4å¦å†³æ£€æŸ¥
        big4 = self.get_latest_big4_signal()
        veto, reason = self.check_big4_veto(
            big4.get('signal'),
            big4.get('strength', 0),
            opp['side']
        )

        if veto:
            logger.warning(f"[BIG4-VETO] {opp['symbol']} {reason}")
            continue  # è·³è¿‡è¯¥ä¿¡å·

        # ... ç»§ç»­å¤„ç†
```

#### é¢„æœŸæ•ˆæœ
- æœˆåº¦æ”¹å–„: **+700U**

---

**ç¬¬äºŒé˜¶æ®µæ€»é¢„æœŸ**: **+4,000U/æœˆ**

---

## ğŸ’ ç¬¬ä¸‰é˜¶æ®µ: V4.0ç§»åŠ¨æ­¢ç›ˆï¼ˆ2å¤©ï¼‰

### æ ¸å¿ƒæ”¹è¿›

**é—®é¢˜**: V3.0ç§»åŠ¨æ­¢ç›ˆ
- 40Ué—¨æ§›å¤ªé«˜
- 10Uæ­¥è¿›å¤ªç²—ç³™
- éœ‡è¡å¸‚ä¸­åˆ©æ¶¦å›å98%

**V4.0è§£å†³æ–¹æ¡ˆ**:
- 20Uå¯åŠ¨é—¨æ§›ï¼ˆé™ä½50%ï¼‰
- åˆ†æ®µä¿æŠ¤50%-80%
- ç¼“å†²ç©ºé—´æå‡937å€

### å®ç°ä»£ç 

**æ–‡ä»¶**: `app/services/trailing_stop_v4.py` (æ–°å»º)

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ç§»åŠ¨æ­¢ç›ˆç®¡ç†å™¨ V4.0
åˆ†æ®µé€’è¿›ä¿æŠ¤ + åŠ¨æ€ç¼“å†²
"""

from typing import Dict, Optional
import logging

logger = logging.getLogger(__name__)


class TrailingStopV4:
    """V4.0ç§»åŠ¨æ­¢ç›ˆç®¡ç†å™¨"""

    def __init__(self):
        # å¹³è¡¡å‹æ–¹æ¡ˆï¼ˆé»˜è®¤ï¼‰
        self.scheme = {
            'name': 'balanced',
            'threshold': 20,  # 20Uå¯åŠ¨
            'stages': [
                (0, 20, 0.0),      # 0-20U: 0%ä¿æŠ¤
                (20, 40, 0.5),     # 20-40U: 50%ä¿æŠ¤
                (40, 80, 0.6),     # 40-80U: 60%ä¿æŠ¤
                (80, 120, 0.7),    # 80-120U: 70%ä¿æŠ¤
                (120, 9999, 0.8)   # 120U+: 80%ä¿æŠ¤
            ]
        }

    def calculate_trailing_stop(self, position: Dict, current_price: float) -> Optional[float]:
        """
        è®¡ç®—ç§»åŠ¨æ­¢æŸä»·æ ¼

        Args:
            position: æŒä»“ä¿¡æ¯
            current_price: å½“å‰ä»·æ ¼

        Returns:
            æ­¢æŸä»·æ ¼ï¼Œå¦‚æœæœªæ¿€æ´»è¿”å›None
        """
        entry_price = position['avg_entry_price']
        position_side = position['position_side']
        quantity = position['quantity']

        # è®¡ç®—å½“å‰æµ®ç›ˆï¼ˆUSDï¼‰
        if position_side == 'LONG':
            unrealized_pnl = (current_price - entry_price) * quantity
        else:
            unrealized_pnl = (entry_price - current_price) * quantity

        # è·å–å†å²æœ€é«˜æµ®ç›ˆ
        max_unrealized_pnl = position.get('max_unrealized_pnl', 0)
        if unrealized_pnl > max_unrealized_pnl:
            max_unrealized_pnl = unrealized_pnl

        # æ£€æŸ¥æ˜¯å¦è¾¾åˆ°å¯åŠ¨é—¨æ§›
        if max_unrealized_pnl < self.scheme['threshold']:
            return None  # æœªæ¿€æ´»

        # æ ¹æ®æœ€é«˜æµ®ç›ˆç¡®å®šä¿æŠ¤æ¯”ä¾‹
        protect_ratio = 0.0
        for min_pnl, max_pnl, ratio in self.scheme['stages']:
            if min_pnl <= max_unrealized_pnl < max_pnl:
                protect_ratio = ratio
                break

        # è®¡ç®—è¦ä¿æŠ¤çš„åˆ©æ¶¦
        protected_profit = max_unrealized_pnl * protect_ratio

        # è®¡ç®—æ­¢æŸä»·æ ¼
        if position_side == 'LONG':
            price_gain = protected_profit / quantity
            stop_price = entry_price + price_gain
        else:
            price_loss = protected_profit / quantity
            stop_price = entry_price - price_loss

        # è®¡ç®—ç¼“å†²ç©ºé—´
        if position_side == 'LONG':
            buffer = current_price - stop_price
            buffer_pct = (buffer / current_price) * 100
        else:
            buffer = stop_price - current_price
            buffer_pct = (buffer / current_price) * 100

        logger.info(
            f"[ç§»åŠ¨æ­¢ç›ˆV4] {position['symbol']} "
            f"æµ®ç›ˆ{unrealized_pnl:.2f}U æœ€é«˜{max_unrealized_pnl:.2f}U "
            f"ä¿æŠ¤{protected_profit:.2f}U({protect_ratio*100:.0f}%) "
            f"æ­¢æŸä»·{stop_price:.2f} ç¼“å†²{buffer:.2f}U({buffer_pct:.2f}%)"
        )

        return stop_price
```

### é›†æˆåˆ°ä¸»æœåŠ¡

```python
from app.services.trailing_stop_v4 import TrailingStopV4

class SmartTraderService:
    def __init__(self):
        # ... ç°æœ‰ä»£ç 
        self.trailing_stop_v4 = TrailingStopV4()

    async def monitor_position(self, position):
        """æŒä»“ç›‘æ§å¾ªç¯"""
        while True:
            current_price = self.get_current_price(position['symbol'])

            # ... å›ºå®šæ­¢æŸæ­¢ç›ˆ
            # ... åè½¬æ­¢æŸ

            # ğŸ”¥ V4.0ç§»åŠ¨æ­¢ç›ˆï¼ˆæ–°å¢ï¼‰
            trailing_stop_price = self.trailing_stop_v4.calculate_trailing_stop(
                position, current_price
            )

            if trailing_stop_price:
                # æ£€æŸ¥æ˜¯å¦è§¦å‘
                if position['position_side'] == 'LONG':
                    if current_price <= trailing_stop_price:
                        await self.close_position(
                            position['id'],
                            current_price,
                            f"ç§»åŠ¨æ­¢ç›ˆV4è§¦å‘"
                        )
                        break
                else:
                    if current_price >= trailing_stop_price:
                        await self.close_position(
                            position['id'],
                            current_price,
                            f"ç§»åŠ¨æ­¢ç›ˆV4è§¦å‘"
                        )
                        break

            await asyncio.sleep(30)
```

### é¢„æœŸæ•ˆæœ
- åˆ©æ¶¦å›åç‡: 98% â†’ 28%
- æœˆåº¦æ”¹å–„: **+2,100U**

---

## ğŸ¯ ç¬¬å››é˜¶æ®µ: å…¶ä»–ä¼˜åŒ–ï¼ˆ1å¤©ï¼‰

### ä¼˜åŒ–4.1: äº¤æ˜“é¢‘ç‡æ§åˆ¶

**ç›®æ ‡**: 200+ â†’ 150ç¬”

```python
# æ·»åŠ å¼€ä»“å†·å´
class SmartTraderService:
    def __init__(self):
        self.last_open_time = {}  # {symbol: timestamp}
        self.open_cooldown = 300  # 5åˆ†é’Ÿå†·å´

    def can_open_position(self, symbol):
        """æ£€æŸ¥å¼€ä»“å†·å´"""
        import time
        last_time = self.last_open_time.get(symbol, 0)
        current_time = time.time()

        if current_time - last_time < self.open_cooldown:
            return False, f"å¼€ä»“å†·å´ä¸­({int((self.open_cooldown-(current_time-last_time))/60)}åˆ†é’Ÿ)"

        return True, None

    async def open_position(self, symbol, side, signal_info):
        # æ£€æŸ¥å†·å´
        can_open, reason = self.can_open_position(symbol)
        if not can_open:
            logger.info(f"[å¼€ä»“å†·å´] {symbol} {reason}")
            return None

        # ... å¼€ä»“é€»è¾‘

        # è®°å½•å¼€ä»“æ—¶é—´
        import time
        self.last_open_time[symbol] = time.time()
```

### ä¼˜åŒ–4.2: ä¿¡å·ä¼˜å…ˆçº§æ’åº

```python
def prioritize_opportunities(self, opportunities):
    """
    ä¿¡å·ä¼˜å…ˆçº§æ’åº

    ä¼˜å…ˆçº§:
    1. çªç„¶æ‹‰å‡ (strength >= 50) â†’ 100åˆ†
    2. å›è°ƒä¹°å…¥ (quality >= 60) â†’ 90åˆ†
    3. é«˜åˆ†å¸¸è§„ä¿¡å· (score >= 30) â†’ 80åˆ†
    4. å…¶ä»– â†’ åŸå§‹åˆ†æ•°
    """
    priority_scores = []

    for opp in opportunities:
        if opp.get('signal_type') == 'sudden_move' and opp.get('strength', 0) >= 50:
            priority = 100
        elif opp.get('signal_type') == 'pullback_entry' and opp.get('entry_quality', 0) >= 60:
            priority = 90
        elif opp.get('score', 0) >= 30:
            priority = 80
        else:
            priority = opp.get('score', 0)

        priority_scores.append((priority, opp))

    # æŒ‰ä¼˜å…ˆçº§æ’åº
    priority_scores.sort(key=lambda x: x[0], reverse=True)

    return [opp for _, opp in priority_scores]
```

### é¢„æœŸæ•ˆæœ
- æ—¥äº¤æ˜“: 220 â†’ 150ç¬”
- æœˆåº¦æ”¹å–„: **+400U**

---

## ğŸ“Š æ€»ä½“ä¼˜åŒ–æ•ˆæœ

### ä¼˜åŒ–å‰ï¼ˆ2æœˆ6-7æ—¥å¹³å‡ï¼‰
```
æ—¥äº¤æ˜“: 220ç¬”
èƒœç‡: 34.66%
æ—¥ç›ˆäº: -2,703U
```

### ä¼˜åŒ–åï¼ˆä¿å®ˆä¼°è®¡ï¼‰

| é˜¶æ®µ | ä¼˜åŒ–é¡¹ | æœˆåº¦æ”¹å–„ | æ—¶é—´ |
|-----|-------|---------|------|
| **ç¬¬ä¸€é˜¶æ®µ** | åŠ¨æ€åè½¬æ­¢æŸ | +800U | 2h |
| | è¯„åˆ†é˜ˆå€¼è°ƒæ•´ | +300U | 5min |
| | æŒä»“æ—¶é—´ç¼©çŸ­ | +200U | 10min |
| | **å°è®¡** | **+1,300U** | **1å¤©** |
| **ç¬¬äºŒé˜¶æ®µ** | çªç„¶æ‹‰å‡æ£€æµ‹å™¨ | +1,500U | 4h |
| | å›è°ƒä¹°å…¥æ£€æµ‹å™¨ | +1,200U | 4h |
| | è¯„åˆ†æƒé‡è°ƒæ•´ | +600U | 1h |
| | Big4å¦å†³æƒ | +700U | 30min |
| | **å°è®¡** | **+4,000U** | **2-3å¤©** |
| **ç¬¬ä¸‰é˜¶æ®µ** | V4.0ç§»åŠ¨æ­¢ç›ˆ | +2,100U | 2å¤© |
| **ç¬¬å››é˜¶æ®µ** | äº¤æ˜“é¢‘ç‡æ§åˆ¶ | +400U | 1å¤© |
| | **æ€»è®¡** | **+7,800U** | **6-7å¤©** |

```
ä¼˜åŒ–åé¢„æœŸ:
æ—¥äº¤æ˜“: 150ç¬”
èƒœç‡: 42-45%
æ—¥ç›ˆäº: +50 ~ +200U
æœˆåº¦ç›ˆåˆ©: +1,500 ~ +6,000U âœ…
```

---

## ğŸ—“ï¸ å®æ–½æ—¶é—´è¡¨

### Week 1: å…¨é‡å®Œæˆ

**Day 1**: ç¬¬ä¸€é˜¶æ®µ
- ä¸Šåˆ: åŠ¨æ€åè½¬æ­¢æŸ (2h)
- ä¸­åˆ: è¯„åˆ†é˜ˆå€¼ + æŒä»“æ—¶é—´ (1h)
- ä¸‹åˆ: æµ‹è¯•éªŒè¯ (2h)
- **æ™šä¸Šä¸Šçº¿ç¬¬ä¸€é˜¶æ®µ**

**Day 2-3**: ç¬¬äºŒé˜¶æ®µPart 1
- Day 2: çªç„¶æ‹‰å‡æ£€æµ‹å™¨ (4h) + æµ‹è¯• (2h)
- Day 3: å›è°ƒä¹°å…¥æ£€æµ‹å™¨ (4h) + æµ‹è¯• (2h)

**Day 4**: ç¬¬äºŒé˜¶æ®µPart 2
- ä¸Šåˆ: è¯„åˆ†æƒé‡è°ƒæ•´ + Big4å¦å†³æƒ (2h)
- ä¸‹åˆ: é›†æˆæµ‹è¯• (3h)
- **æ™šä¸Šä¸Šçº¿ç¬¬äºŒé˜¶æ®µ**

**Day 5-6**: ç¬¬ä¸‰é˜¶æ®µ
- Day 5: V4.0ç§»åŠ¨æ­¢ç›ˆå®ç° (6h)
- Day 6: V4.0æµ‹è¯•éªŒè¯ (4h)
- **æ™šä¸Šä¸Šçº¿ç¬¬ä¸‰é˜¶æ®µ**

**Day 7**: ç¬¬å››é˜¶æ®µ + æ”¶å°¾
- ä¸Šåˆ: äº¤æ˜“é¢‘ç‡æ§åˆ¶ + ä¼˜å…ˆçº§æ’åº (3h)
- ä¸‹åˆ: å…¨é‡æµ‹è¯• (2h)
- **æ™šä¸Šå…¨éƒ¨ä¸Šçº¿å®Œæˆ**

---

## âœ… éªŒæ”¶æ ‡å‡†

### åŠŸèƒ½éªŒæ”¶
- [ ] åŠ¨æ€åè½¬æ­¢æŸ: æ£€æµ‹åˆ°è¿ç»­2æ ¹åå‘Kçº¿+æ”¾é‡æ—¶-1%æ­¢æŸ
- [ ] çªç„¶æ‹‰å‡æ£€æµ‹: 5åˆ†é’Ÿæ‹‰å‡1%+æ”¾é‡1.5xç«‹å³è§¦å‘å¼€ä»“
- [ ] å›è°ƒä¹°å…¥æ£€æµ‹: å›è°ƒ2%åå‡ºç°åå¼¹Kçº¿è§¦å‘å¼€ä»“
- [ ] Big4å¦å†³æƒ: å¼ºåº¦12+ä¸”æ–¹å‘ç›¸åæ—¶æ‹’ç»å¼€ä»“
- [ ] V4.0ç§»åŠ¨æ­¢ç›ˆ: æµ®ç›ˆ20Uæ¿€æ´»ï¼Œåˆ†æ®µä¿æŠ¤50-80%
- [ ] äº¤æ˜“é¢‘ç‡: æ—¥å‡150ç¬”å·¦å³

### æ€§èƒ½éªŒæ”¶
- [ ] èƒœç‡ >= 40%
- [ ] æ—¥ç›ˆäº >= 0U
- [ ] å¹³å‡æŒä»“æ—¶é—´ 2-3å°æ—¶
- [ ] åè½¬æ­¢æŸè§¦å‘ç‡ < 10%
- [ ] ç§»åŠ¨æ­¢ç›ˆåˆ©æ¶¦å›åç‡ < 35%

### æ•°æ®éªŒæ”¶
**å›æµ‹éªŒè¯** (2æœˆ5-7æ—¥):
- [ ] 2æœˆ5æ—¥: ä¿æŒç›ˆåˆ©
- [ ] 2æœˆ6-7æ—¥: äºæŸå‡å°‘50%+

**å®ç›˜éªŒè¯** (å°è§„æ¨¡1å¤©):
- [ ] 5ä¸ªä¼˜è´¨äº¤æ˜“å¯¹æµ‹è¯•
- [ ] å•ä»“200Ué™ä½é£é™©
- [ ] æ–°åŠŸèƒ½æ­£å¸¸è§¦å‘

---

## ğŸš¨ é£é™©é¢„æ¡ˆ

### é£é™©1: çªç„¶æ‹‰å‡è¯¯åˆ¤
**åœºæ™¯**: è™šå‡çªç ´
**é¢„æ¡ˆ**:
- åè½¬æ­¢æŸ-1%ä¿æŠ¤
- é™åˆ¶æ—¥è§¦å‘30æ¬¡
- èƒœç‡<35%æš‚åœ

### é£é™©2: å›è°ƒä¹°å…¥æŠ„åº•å¤±è´¥
**åœºæ™¯**: è¶‹åŠ¿åè½¬
**é¢„æ¡ˆ**:
- Big4æ–¹å‘æ£€æŸ¥
- ä»·æ ¼ä½ç½®30-70%é™åˆ¶
- åè½¬æ­¢æŸä¿æŠ¤

### é£é™©3: ä»£ç Bug
**é¢„æ¡ˆ**:
- å……åˆ†å•å…ƒæµ‹è¯•
- å°è§„æ¨¡å®ç›˜éªŒè¯
- è¯¦ç»†æ—¥å¿—
- æ¯æ—¥æ£€æŸ¥

---

## ğŸ“ å®æ–½æ£€æŸ¥æ¸…å•

### å¼€å‘å‰
- [ ] å¤‡ä»½å½“å‰ä»£ç 
- [ ] åˆ›å»ºåˆ†æ”¯ `feature/super-brain-optimization`
- [ ] å‡†å¤‡æµ‹è¯•æ•°æ®

### æ¯ä¸ªä»»åŠ¡å
- [ ] å•å…ƒæµ‹è¯•é€šè¿‡
- [ ] ä»£ç Review
- [ ] æ—¥å¿—å®Œæ•´
- [ ] æ–‡æ¡£æ›´æ–°

### ä¸Šçº¿å‰
- [ ] æ‰€æœ‰éªŒæ”¶æ ‡å‡†é€šè¿‡
- [ ] å›æµ‹ç¬¦åˆé¢„æœŸ
- [ ] å°è§„æ¨¡å®ç›˜éªŒè¯
- [ ] ç›‘æ§å‘Šè­¦é…ç½®

### ä¸Šçº¿å
- [ ] æ¯æ—¥æ£€æŸ¥æ—¥å¿—
- [ ] æ¯æ—¥ç»Ÿè®¡è§¦å‘æ¬¡æ•°
- [ ] æ¯æ—¥ç›ˆäºæ£€æŸ¥
- [ ] æ¯å‘¨Reviewæ•ˆæœ

---

## ğŸ¯ ç«‹å³æ‰§è¡Œ

**ä¸‹ä¸€æ­¥**: å¼€å§‹ç¬¬ä¸€é˜¶æ®µ - åŠ¨æ€åè½¬æ­¢æŸ

**é¢„è®¡æ—¶é—´**: 2å°æ—¶

**æ–‡ä»¶**:
1. åˆ›å»º `app/services/dynamic_stop_loss_v2.py`
2. ä¿®æ”¹ `smart_trader_service.py`
3. ä¿®æ”¹ `coin_futures_trader_service.py`

**å¼€å§‹æ‰§è¡Œï¼** ğŸš€

---

**æ–‡æ¡£ç‰ˆæœ¬**: V1.0 Final
**åˆ›å»ºæ—¥æœŸ**: 2026-02-08
**çŠ¶æ€**: âœ… å®Œæˆï¼Œç«‹å³æ‰§è¡Œ
