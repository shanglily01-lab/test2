# 加密货币智能交易系统 - 完整逻辑文档

## 目录
1. [系统概述](#系统概述)
2. [开仓信号生成系统](#开仓信号生成系统)
3. [智能平仓系统](#智能平仓系统)
4. [自适应优化系统](#自适应优化系统)
5. [数据库配置表](#数据库配置表)
6. [完整决策流程图](#完整决策流程图)

---

## 系统概述

本系统是一个多维度信号融合的自适应加密货币合约交易系统，核心特点：

- **多维信号叠加**: 8大类信号组件，最高评分195分
- **动态自学习**: 根据历史表现自动调整权重、评级、超时等参数
- **分层风控**: 8个优先级的平仓条件，确保风险可控
- **智能分批**: 支持分批建仓和分批平仓
- **实时监控**: 每秒检查持仓状态，多级价格获取降级策略

---

## 开仓信号生成系统

### 1. 核心信号评分机制

#### 1.1 信号组件及权重

系统采用**多维度组件叠加法**，每个组件为不同方向（LONG/SHORT）贡献评分：

| 信号类别 | 信号名称 | 触发条件 | LONG权重 | SHORT权重 |
|---------|---------|---------|---------|----------|
| **位置评分** | position_low | 价格在72H区间<30% | +20 | 0 |
| | position_mid | 价格在72H区间30-70% | +5 | +5 |
| | position_high | 价格在72H区间>70% | 0 | +20 |
| **短期动量** | momentum_down_3pct | 24H跌幅>3% | 0 | +15 |
| | momentum_up_3pct | 24H涨幅>3% | +15 | 0 |
| **1小时趋势** | trend_1h_bull | 最近48根1H K线阳线>62.5% | +20 | 0 |
| | trend_1h_bear | 最近48根1H K线阴线>62.5% | 0 | +20 |
| **波动率** | volatility_high | 24H振幅>5% | +10 | +10 |
| **连续趋势** | consecutive_bull | 最近10根1H K线≥7根阳线且涨幅<5% | +15 | 0 |
| | consecutive_bear | 最近10根1H K线≥7根阴线且跌幅>-5% | 0 | +15 |
| **量能分析** | volume_power_bull | 1H和15M都≥2的强力阳K | +25 | 0 |
| | volume_power_bear | 1H和15M都≤-2的强力阴K | 0 | +25 |
| | volume_power_1h_bull | 仅1H≥3的阳K | +15 | 0 |
| | volume_power_1h_bear | 仅1H≤-3的阴K | 0 | +15 |
| **突破/破位** | breakout_long | position>70% + 量能支撑 | +20 | 0 |
| | breakdown_short | position<30% + 量能压制 | 0 | +20 |
| **大趋势** | trend_1d_bull | 30D阳线>18根 + 多头倾向 | +10 | 0 |
| | trend_1d_bear | 30D阴线>18根 + 空头倾向 | 0 | +10 |

**理论最高分**: 195分（所有信号同向叠加）

#### 1.2 开仓阈值

```python
threshold = 35分

# 评分规则
if long_score >= 35 or short_score >= 35:
    if long_score > short_score:
        开仓方向 = LONG
        开仓评分 = long_score
    elif short_score >= long_score:
        开仓方向 = SHORT
        开仓评分 = short_score
else:
    不开仓
```

#### 1.3 信号权重配置

权重配置存储在数据库表 `signal_scoring_weights`：

```sql
CREATE TABLE signal_scoring_weights (
    signal_component VARCHAR(100) PRIMARY KEY,
    weight_long INT DEFAULT 0,
    weight_short INT DEFAULT 0,
    base_weight INT DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE
);
```

- 系统启动时从数据库加载权重
- 如果数据库表不存在，使用代码中的硬编码默认值
- 支持动态调整，无需重启服务

---

### 2. 信号过滤机制

信号生成后需要通过多层过滤才能最终开仓。

#### 2.1 黑名单过滤（三层机制）

**A. 交易对黑名单 (trading_blacklist表)**

```sql
CREATE TABLE trading_blacklist (
    symbol VARCHAR(50) PRIMARY KEY,
    level INT DEFAULT 1,  -- 黑名单等级 (1或2)
    reason TEXT,
    is_active BOOLEAN DEFAULT TRUE
);
```

- 完全黑名单交易对使用小仓位
  - Level 1: 100 USDT (正常的25%)
  - Level 2: 50 USDT (正常的12.5%)
- **四大天王 (BTC/ETH/BNB/SOL) 永不拉黑**

**B. 信号组合黑名单 (signal_blacklist表)**

```sql
CREATE TABLE signal_blacklist (
    signal_type VARCHAR(500),
    position_side VARCHAR(10),  -- LONG或SHORT
    reason VARCHAR(500),
    is_active BOOLEAN DEFAULT TRUE,
    UNIQUE KEY (signal_type, position_side)
);
```

记录格式示例：
- `"position_low + volume_power_bull_LONG"` - 禁用此信号组合的做多
- `"breakdown_short + momentum_down_3pct + position_low_SHORT"` - 禁用此信号组合的做空

**C. 3级评级制度 (symbol_rating_level表)**

```sql
CREATE TABLE symbol_rating_level (
    symbol VARCHAR(50) PRIMARY KEY,
    level INT DEFAULT 0,  -- 0=白名单, 1-3=黑名单级别
    reason TEXT
);
```

| Level | 名称 | 仓位倍数 | 实际仓位 |
|-------|------|---------|---------|
| 0 | 白名单 | 100% | 400 USDT |
| 1 | 黑名单L1 | 25% | 100 USDT |
| 2 | 黑名单L2 | 12.5% | 50 USDT |
| 3 | 永久禁止 | 0% | 禁止交易 |

#### 2.2 防追高/追跌过滤

```python
def check_anti_fomo_filter(symbol, current_price, side):
    """防止在极端位置开仓"""

    # 计算价格在24H区间的位置百分比
    position_pct = (current_price - low_24h) / (high_24h - low_24h) * 100

    # 做多防追高
    if side == 'LONG' and position_pct > 80:
        return False, "防追高: 价格在24H高位区域"

    # 做空防杀跌
    if side == 'SHORT' and position_pct < 20:
        return False, "防杀跌: 价格在24H低位区域"

    # 额外严格检查
    change_24h = (current_price - open_24h) / open_24h * 100

    # 24H大涨且在高位 -> 拒绝做多
    if side == 'LONG' and change_24h > 15 and position_pct > 70:
        return False, "防追高: 24H大涨且在高位"

    # 24H大跌且在低位 -> 拒绝做空
    if side == 'SHORT' and change_24h < -15 and position_pct < 30:
        return False, "防杀跌: 24H大跌且在低位"

    return True, ""
```

#### 2.3 时间框架一致性验证

确保信号组件之间不矛盾：

```python
def validate_signal_consistency(signal_components, side):
    """验证信号时间框架一致性"""

    if side == 'LONG':
        # 做多信号不能包含空头趋势
        if 'trend_1h_bear' in signal_components:
            return False, "做多信号包含1H空头趋势"
        if 'trend_1d_bear' in signal_components:
            return False, "做多信号包含1D空头趋势"

    elif side == 'SHORT':
        # 做空信号不能包含多头趋势
        if 'trend_1h_bull' in signal_components:
            return False, "做空信号包含1H多头趋势"
        if 'trend_1d_bull' in signal_components:
            return False, "做空信号包含1D多头趋势"

    return True, ""
```

#### 2.4 position_high额外验证

对 `position_high + SHORT` 信号的额外检查：

```python
def validate_position_high_short(klines_1h):
    """验证高位做空信号的有效性"""

    recent_10 = klines_1h[-10:]

    # 检查1: 不能伴随momentum_up_3pct信号
    # (动能未衰竭，可能继续上涨)

    # 检查2: 最近10根K线上影线比例 >= 30%
    upper_shadow_ratio = calculate_upper_shadow_ratio(recent_10)
    if upper_shadow_ratio < 0.30:
        return False, "上影线不足，顶部特征不明显"

    # 检查3: 成交量萎缩
    recent_5_vol = sum([k['volume'] for k in recent_10[-5:]])
    prev_5_vol = sum([k['volume'] for k in recent_10[-10:-5]])
    if recent_5_vol > prev_5_vol * 1.2:
        return False, "成交量未萎缩，可能继续上涨"

    return True, ""
```

#### 2.5 平仓后冷却期检查

```python
def check_cooldown_period(symbol, side):
    """检查是否在冷却期内"""

    # 查询该交易对最近的平仓记录
    last_close = get_last_closed_position(symbol, side)

    if last_close:
        minutes_since_close = (now - last_close.close_time).total_seconds() / 60
        if minutes_since_close < 60:  # 1小时冷却期
            return False, f"冷却期内: {60 - minutes_since_close:.0f}分钟后可重新开仓"

    return True, ""
```

---

### 3. Big4趋势检测对开仓的影响

四大天王 (BTC, ETH, BNB, SOL) 的整体趋势会影响开仓决策。

#### 3.1 Big4趋势检测

```python
def detect_market_trend():
    """检测市场整体趋势"""

    big4_symbols = ['BTC/USDT', 'ETH/USDT', 'BNB/USDT', 'SOL/USDT']
    bullish_count = 0
    bearish_count = 0

    for symbol in big4_symbols:
        signal = generate_signal(symbol)
        if signal['long_score'] > signal['short_score']:
            bullish_count += 1
        elif signal['short_score'] > signal['long_score']:
            bearish_count += 1

    # 判断整体市场趋势
    if bullish_count >= 3:
        return 'BULLISH'
    elif bearish_count >= 3:
        return 'BEARISH'
    else:
        return 'NEUTRAL'
```

#### 3.2 仓位倍数动态调整

```python
def calculate_position_multiplier(market_signal, side):
    """根据市场信号调整仓位倍数"""

    if market_signal == 'BULLISH' and side == 'LONG':
        return 1.2  # 市场看多，做多加仓20%
    elif market_signal == 'BEARISH' and side == 'SHORT':
        return 1.2  # 市场看空，做空加仓20%
    else:
        return 1.0  # 其他情况正常仓位
```

最终仓位计算：

```python
base_position_size = 400  # USDT

# 评级倍数
if rating_level == 0:
    rating_multiplier = 1.0
elif rating_level == 1:
    rating_multiplier = 0.25
elif rating_level == 2:
    rating_multiplier = 0.125
else:  # level 3
    rating_multiplier = 0.0  # 禁止交易

# Big4倍数
position_multiplier = calculate_position_multiplier(market_signal, side)

# 最终仓位
final_position_size = base_position_size * rating_multiplier * position_multiplier
```

---

### 4. 智能分批建仓执行

#### 4.1 SmartEntryExecutor 架构

```python
class SmartEntryExecutor:
    """智能分批建仓执行器"""

    def __init__(self, exchange_client, db_manager):
        self.price_sampler = PriceSampler()
        self.batch_config = {
            'strong': [0.30, 0.30, 0.40],   # 强势信号: 30%/30%/40%
            'normal': [0.30, 0.30, 0.40],   # 正常信号
            'weak': [0.30, 0.30, 0.40]      # 弱势信号
        }
```

#### 4.2 建仓流程

```
阶段0: 信号验证 (0-5分钟)
  ├─ 启动价格采样器 (PriceSampler)
  ├─ 建立5分钟滚动窗口基线
  └─ 收集: min_price, max_price, p50, 趋势方向

阶段1: 第1批建仓 (30%)
  ├─ 强势信号: 15分钟内
  ├─ 正常信号: 20分钟内
  └─ 弱势信号: 30分钟内

阶段2: 第2批建仓 (30%)
  ├─ 强势信号: 25分钟内
  ├─ 正常信号: 40分钟内
  └─ 弱势信号: 60分钟内

阶段3: 第3批建仓 (40%)
  ├─ 强势信号: 35分钟内
  ├─ 正常信号: 60分钟内
  └─ 弱势信号: 90分钟内
```

#### 4.3 建仓时机判断

```python
def is_good_entry_point(current_price, baseline, side):
    """判断是否是好的建仓点位"""

    price_score = calculate_price_score(current_price, baseline, side)

    # 评分系统
    # 100分: 极佳点位 (立即执行)
    # 85分: 优秀点位 (立即执行)
    # 70分: 良好点位 (可以执行)
    # 60分: 一般点位 (接近窗口上限可执行)
    # <60分: 较差点位 (继续等待)

    if price_score >= 85:
        return True, "极佳/优秀建仓点位"
    elif price_score >= 70:
        return True, "良好建仓点位"
    elif price_score >= 60 and elapsed_time > window_upper_limit * 0.8:
        return True, "接近窗口上限，执行建仓"
    else:
        return False, "点位不佳，继续等待"
```

**价格评分规则（LONG为例）**：

```python
def calculate_price_score(price, baseline, side='LONG'):
    """计算价格评分 (0-100分)"""

    if side == 'LONG':
        # 做多希望在低位建仓
        if price <= baseline.min_price:
            score = 100  # 跌破基线最低价
        elif price <= baseline.p25:
            score = 95   # 25分位以下
        elif price <= baseline.p50:
            score = 85   # 50分位以下
        elif price <= baseline.p75:
            score = 70   # 75分位以下
        else:
            score = 50   # 高于75分位

        # 趋势加成
        if baseline.trend == 'down':
            score += 10  # 下跌趋势，更好的买点
        elif baseline.trend == 'up':
            score -= 10  # 上涨趋势，追高风险

    elif side == 'SHORT':
        # 做空希望在高位建仓
        if price >= baseline.max_price:
            score = 100  # 突破基线最高价
        elif price >= baseline.p75:
            score = 95   # 75分位以上
        elif price >= baseline.p50:
            score = 85   # 50分位以上
        elif price >= baseline.p25:
            score = 70   # 25分位以上
        else:
            score = 50   # 低于25分位

        # 趋势加成
        if baseline.trend == 'up':
            score += 10  # 上涨趋势，更好的卖点
        elif baseline.trend == 'down':
            score -= 10  # 下跌趋势，追跌风险

    return max(0, min(100, score))
```

---

### 5. 信号组件和开仓记录

开仓时在数据库 `futures_positions` 表记录以下信息：

```python
position_record = {
    'symbol': 'BTC/USDT',
    'position_side': 'LONG',
    'entry_signal_type': 'position_low + volume_power_bull + trend_1h_bull',
    'entry_score': 65,
    'signal_components': {
        'position_low': 20,
        'volume_power_bull': 25,
        'trend_1h_bull': 20
    },
    'entry_price': 45000.0,
    'quantity': 0.01,
    'position_value': 450.0,
    'leverage': 10,
    'stop_loss_price': 44100.0,
    'take_profit_price': 45900.0,
    'timeout_at': '2024-01-30 12:00:00',  # 动态计算
    'planned_close_time': '2024-01-30 11:46:00',  # 分批建仓结束时间
    'status': 'open',
    'created_at': '2024-01-30 10:46:00'
}
```

---

## 智能平仓系统

### 1. SmartExitOptimizer 核心架构

#### 1.1 监控流程

```python
class SmartExitOptimizer:
    """智能平仓优化器"""

    def start_monitoring(self, position_id):
        """启动持仓监控"""
        asyncio.create_task(self._monitor_position(position_id))

    async def _monitor_position(self, position_id):
        """监控循环 - 每秒检查一次"""
        while True:
            # 1. 获取持仓信息
            position = self.get_position(position_id)
            if not position or position.status != 'open':
                break

            # 2. 获取实时价格 (多级降级)
            current_price = await self.get_current_price(position.symbol)

            # 3. 计算当前盈亏
            pnl_pct = self.calculate_pnl_pct(position, current_price)

            # 4. 更新最高盈利记录
            self.update_max_profit(position, pnl_pct, current_price)

            # 5. 检查兜底平仓条件
            should_close, reason = self.check_exit_conditions(
                position, current_price, pnl_pct
            )

            if should_close:
                await self.close_position(position, reason)
                break

            # 6. 每15分钟检查一次K线强度衰减
            if minutes_held % 15 == 0:
                await self.check_momentum_decay(position)

            # 7. 检查智能分批平仓 (T-30分钟窗口)
            if position.planned_close_time:
                await self.check_smart_exit_window(position, current_price)

            await asyncio.sleep(1)
```

#### 1.2 价格获取的多级降级策略

```python
async def get_current_price(self, symbol):
    """获取实时价格 - 多级降级"""

    try:
        # 优先级1: WebSocket实时价格
        price = self.ws_price_cache.get(symbol)
        if price and self.is_price_fresh(price, max_age=5):
            return price['last']
    except Exception as e:
        logger.warning(f"WS价格获取失败: {e}")

    try:
        # 优先级2: REST API实时价格
        ticker = await self.exchange.fetch_ticker(symbol)
        return ticker['last']
    except Exception as e:
        logger.warning(f"REST API价格获取失败: {e}")

    try:
        # 优先级3: 5分钟K线收盘价 (降级)
        klines = await self.exchange.fetch_ohlcv(symbol, '5m', limit=1)
        logger.warning(f"{symbol} 价格获取降级到5m K线")
        return klines[0][4]  # close price
    except Exception as e:
        logger.error(f"所有价格获取方式失败: {e}")
        return None
```

---

### 2. 平仓条件优先级（分层逻辑）

#### 优先级0: 最小持仓时间限制

```python
MIN_HOLDING_MINUTES = 120  # 2小时

def check_min_holding_time(position):
    """检查最小持仓时间"""
    minutes_held = (datetime.now() - position.created_at).total_seconds() / 60

    if minutes_held < MIN_HOLDING_MINUTES:
        # 未满2小时，只允许止损和止盈，不允许其他原因平仓
        return False, "未满最小持仓时间"

    return True, ""
```

#### 优先级1: 固定止损检查（无时间限制）

```python
def check_stop_loss(position, current_price):
    """检查固定止损 - 任何时刻都生效"""

    if position.position_side == 'LONG':
        if current_price <= position.stop_loss_price:
            return True, "触发止损"
    else:  # SHORT
        if current_price >= position.stop_loss_price:
            return True, "触发止损"

    return False, ""
```

#### 优先级2: 固定止盈检查

```python
def check_take_profit(position, current_price):
    """检查固定止盈"""

    if position.position_side == 'LONG':
        if current_price >= position.take_profit_price:
            return True, "触发止盈"
    else:  # SHORT
        if current_price <= position.take_profit_price:
            return True, "触发止盈"

    return False, ""
```

#### 优先级3: 分批建仓恢复的持仓处理

```python
def check_recovered_position(position):
    """检查是否是恢复的分批建仓持仓"""

    if not position.planned_close_time:
        # 没有planned_close_time，说明是恢复的持仓
        # 只检查止损止盈，不执行智能分批平仓
        return True, "恢复的持仓，仅监控止损止盈"

    return False, ""
```

---

#### 优先级4: 智能顶底识别（替代固定止盈）

```python
def check_top_bottom_reversal(position, klines_1h, klines_4h, pnl_pct):
    """智能顶底识别 - 需满足2小时最小持仓时间"""

    if not self.check_min_holding_time(position):
        return False, ""

    # 计算1H和4H K线强度
    strength_1h = self.calculate_kline_strength(klines_1h[-20:])
    strength_4h = self.calculate_kline_strength(klines_4h[-10:])

    if position.position_side == 'LONG':
        # 多头识别顶部: 盈利>=2% + 1H和4H都强烈看空
        if pnl_pct >= 2.0:
            if strength_1h <= -15 and strength_4h <= -10:
                return True, "智能顶部识别: 1H和4H都转为强烈看空"

    else:  # SHORT
        # 空头识别底部: 盈利>=2% + 1H和4H都强烈看多
        if pnl_pct >= 2.0:
            if strength_1h >= 15 and strength_4h >= 10:
                return True, "智能底部识别: 1H和4H都转为强烈看多"

    return False, ""
```

#### 优先级5: 动态超时检查

```python
def check_dynamic_timeout(position):
    """检查动态超时时间"""

    if not self.check_min_holding_time(position):
        return False, ""

    if datetime.utcnow() >= position.timeout_at:
        return True, "到达动态超时时间"

    return False, ""
```

**动态超时时间计算**：

```python
def calculate_timeout_by_score(entry_score):
    """根据评分计算超时时间"""

    if entry_score >= 80:
        return 480  # 8小时
    elif entry_score >= 70:
        return 360  # 6小时
    elif entry_score >= 60:
        return 240  # 4小时
    elif entry_score >= 50:
        return 180  # 3小时
    elif entry_score >= 40:
        return 120  # 2小时
    else:
        return 60   # 1小时

timeout_minutes = calculate_timeout_by_score(position.entry_score)
timeout_at = position.created_at + timedelta(minutes=timeout_minutes)
```

#### 优先级6: 分阶段超时检查

```python
def check_staged_timeout(position, pnl_pct, minutes_held):
    """分阶段超时检查 - 根据持仓时长和盈亏"""

    if not self.check_min_holding_time(position):
        return False, ""

    # 1小时: 亏损 > -2.5% -> 平仓
    if minutes_held >= 60 and pnl_pct < -2.5:
        return True, "持仓1H且亏损>2.5%"

    # 2小时: 亏损 > -2.0% -> 平仓
    if minutes_held >= 120 and pnl_pct < -2.0:
        return True, "持仓2H且亏损>2.0%"

    # 3小时: 亏损 > -1.5% -> 平仓
    if minutes_held >= 180 and pnl_pct < -1.5:
        return True, "持仓3H且亏损>1.5%"

    # 4小时: 亏损 > -1.0% -> 平仓
    if minutes_held >= 240 and pnl_pct < -1.0:
        return True, "持仓4H且亏损>1.0%"

    return False, ""
```

#### 优先级7: 6小时绝对时间托底

```python
def check_max_holding_time(position, minutes_held):
    """检查最大持仓时间"""

    MAX_HOLD_MINUTES = 360  # 6小时

    if minutes_held >= MAX_HOLD_MINUTES:
        return True, "到达最大持仓时间(6H)"

    return False, ""
```

#### 优先级8: K线强度衰减检查（分阶段平仓）

```python
def check_momentum_decay(position, klines_1h, pnl_pct, minutes_held):
    """K线强度衰减检查 - 每15分钟检查一次"""

    if not self.check_min_holding_time(position):
        return None

    current_strength = self.calculate_kline_strength(klines_1h[-20:])
    entry_strength = position.entry_kline_strength  # 开仓时的K线强度

    # 获取当前部分平仓阶段
    stage = position.partial_close_stage or 0

    # 阶段0 → 1: 盈利>=2% + K线强度大幅减弱
    if stage == 0:
        if pnl_pct >= 2.0 and current_strength < entry_strength * 0.6:
            return {
                'action': 'partial_close',
                'percentage': 0.50,  # 平仓50%
                'new_stage': 1,
                'reason': '盈利>=2%且K线强度大幅减弱'
            }

    # 阶段1 → 2: 盈利>=4% + 强度减弱 OR 持仓4H + 强度<15
    elif stage == 1:
        if pnl_pct >= 4.0 and current_strength < entry_strength * 0.8:
            return {
                'action': 'partial_close',
                'percentage': 0.70,  # 再平仓70%
                'new_stage': 2,
                'reason': '盈利>=4%且K线强度减弱'
            }
        elif minutes_held >= 240 and current_strength < 15:
            return {
                'action': 'partial_close',
                'percentage': 0.70,
                'new_stage': 2,
                'reason': '持仓4H且K线强度<15'
            }

    # 阶段2 → 3: 持仓5H OR K线强度<10
    elif stage == 2:
        if minutes_held >= 300:
            return {
                'action': 'full_close',
                'percentage': 1.0,
                'new_stage': 3,
                'reason': '持仓5H，全部平仓'
            }
        elif current_strength < 10:
            return {
                'action': 'full_close',
                'percentage': 1.0,
                'new_stage': 3,
                'reason': 'K线强度<10，全部平仓'
            }

    # 特殊条件: 亏损>1% + 方向反转
    if pnl_pct < -1.0:
        if position.position_side == 'LONG' and current_strength < -10:
            return {
                'action': 'full_close',
                'percentage': 1.0,
                'reason': '亏损>1%且方向反转(转为看空)'
            }
        elif position.position_side == 'SHORT' and current_strength > 10:
            return {
                'action': 'full_close',
                'percentage': 1.0,
                'reason': '亏损>1%且方向反转(转为看多)'
            }

    # 特殊条件: 15M强力反转 + 亏损
    strength_15m = self.calculate_kline_strength_15m(symbol)
    if pnl_pct < 0:
        if position.position_side == 'LONG' and strength_15m <= -3:
            return {
                'action': 'full_close',
                'percentage': 1.0,
                'reason': '15M强力反转向下且持仓亏损'
            }
        elif position.position_side == 'SHORT' and strength_15m >= 3:
            return {
                'action': 'full_close',
                'percentage': 1.0,
                'reason': '15M强力反转向上且持仓亏损'
            }

    return None
```

---

### 3. 智能分批平仓时间窗口

#### 3.1 计划平仓时间窗口

当持仓有 `planned_close_time` 字段时，启动智能分批平仓监控。

**时间窗口示例**（假设 planned_close_time = 11:46）：

```
10:46 (T+0):   分批建仓完成，启动监控
11:16 (T-30):  进入智能平仓监控窗口
11:16-11:26:   前10分钟建立价格基线
11:26 (T-20):  基线建立完成
11:26-11:46:   20分钟内寻找最佳平仓价格
11:46 (T+0):   计划平仓时间，必须强制执行
```

#### 3.2 价格基线建立

```python
class PriceBaseline:
    """价格基线（用于平仓决策）"""

    def __init__(self):
        self.min_price = None
        self.max_price = None
        self.p25 = None
        self.p50 = None
        self.p75 = None
        self.trend = None  # 'up', 'down', 'neutral'
        self.strength = 0  # 趋势强度 0-1

    def build_baseline(self, prices):
        """建立基线 (10分钟的价格数据)"""
        self.min_price = min(prices)
        self.max_price = max(prices)
        self.p25 = np.percentile(prices, 25)
        self.p50 = np.percentile(prices, 50)
        self.p75 = np.percentile(prices, 75)

        # 计算趋势
        slope, _ = np.polyfit(range(len(prices)), prices, 1)
        self.strength = abs(slope) / self.p50  # 归一化强度

        if slope > 0.0001:
            self.trend = 'up'
        elif slope < -0.0001:
            self.trend = 'down'
        else:
            self.trend = 'neutral'
```

#### 3.3 平仓决策（一次性100%）

```python
def check_smart_exit_window(position, current_price, baseline, elapsed_minutes):
    """智能平仓窗口检查"""

    # 还未进入窗口
    time_to_close = (position.planned_close_time - datetime.utcnow()).total_seconds() / 60
    if time_to_close > 30:
        return False, ""

    # 前10分钟建立基线
    if time_to_close > 20:
        # 收集价格数据
        return False, "建立价格基线中"

    # 基线建立完成，开始寻找最佳出场点
    if not baseline:
        baseline = self.build_baseline_from_history()

    # 计算当前价格评分
    score = self.calculate_exit_price_score(current_price, baseline, position.position_side)

    # LONG头寸平仓条件
    if position.position_side == 'LONG':
        # 条件1: 极佳卖点
        if score >= 95:
            return True, "极佳卖点(评分>=95)"

        # 条件2: 优秀卖点
        if score >= 85:
            return True, "优秀卖点(评分>=85)"

        # 条件3: 突破基线最高价
        if current_price >= baseline.max_price * 1.001:
            return True, "突破基线最高价"

        # 条件4: 强下跌趋势
        if baseline.trend == 'down' and baseline.strength > 0.6:
            return True, "强下跌趋势，及时止损"

        # 条件5: 接近截止时间
        if elapsed_minutes >= 20 and score >= 60:
            return True, "接近截止时间，必须平仓"

        # 条件6: 到达planned_close_time
        if time_to_close <= 0:
            return True, "到达计划平仓时间，强制平仓"

    # SHORT头寸平仓条件
    elif position.position_side == 'SHORT':
        # 条件1: 极佳买点
        if score >= 95:
            return True, "极佳买点(评分>=95)"

        # 条件2: 优秀买点
        if score >= 85:
            return True, "优秀买点(评分>=85)"

        # 条件3: 跌破基线最低价
        if current_price <= baseline.min_price * 0.999:
            return True, "跌破基线最低价"

        # 条件4: 强上涨趋势
        if baseline.trend == 'up' and baseline.strength > 0.6:
            return True, "强上涨趋势，及时止损"

        # 条件5: 接近截止时间
        if elapsed_minutes >= 20 and score >= 60:
            return True, "接近截止时间，必须平仓"

        # 条件6: 到达planned_close_time
        if time_to_close <= 0:
            return True, "到达计划平仓时间，强制平仓"

    return False, ""
```

**平仓价格评分规则**（LONG为例）：

```python
def calculate_exit_price_score(price, baseline, side='LONG'):
    """计算平仓价格评分 (0-100分)"""

    if side == 'LONG':
        # 做多希望在高位平仓
        if price >= baseline.max_price:
            score = 100  # 突破基线最高价
        elif price >= baseline.p75:
            score = 95   # 75分位以上
        elif price >= baseline.p50:
            score = 85   # 50分位以上
        elif price >= baseline.p25:
            score = 70   # 25分位以上
        else:
            score = 50   # 低于25分位

        # 趋势减分
        if baseline.trend == 'down':
            score -= 10  # 下跌趋势，降低评分
        elif baseline.trend == 'up':
            score += 10  # 上涨趋势，提高评分

    elif side == 'SHORT':
        # 做空希望在低位平仓
        if price <= baseline.min_price:
            score = 100  # 跌破基线最低价
        elif price <= baseline.p25:
            score = 95   # 25分位以下
        elif price <= baseline.p50:
            score = 85   # 50分位以下
        elif price <= baseline.p75:
            score = 70   # 75分位以下
        else:
            score = 50   # 高于75分位

        # 趋势减分
        if baseline.trend == 'up':
            score -= 10  # 上涨趋势，降低评分
        elif baseline.trend == 'down':
            score += 10  # 下跌趋势，提高评分

    return max(0, min(100, score))
```

---

### 4. 波动率动态止盈配置

#### 4.1 symbol_volatility_profile 表

```sql
CREATE TABLE symbol_volatility_profile (
    symbol VARCHAR(50) PRIMARY KEY,
    long_fixed_tp_pct DECIMAL(5, 2),   -- LONG头寸止盈百分比
    short_fixed_tp_pct DECIMAL(5, 2),  -- SHORT头寸止盈百分比
    avg_15m_bull_pct DECIMAL(5, 2),    -- 平均15M阳线涨幅%
    avg_15m_bear_pct DECIMAL(5, 2),    -- 平均15M阴线跌幅%
    updated_at TIMESTAMP
);
```

#### 4.2 使用逻辑

```python
def get_take_profit_pct(symbol, side):
    """获取止盈百分比"""

    # 1. 优先使用波动率配置
    profile = db.query(
        "SELECT * FROM symbol_volatility_profile WHERE symbol = %s",
        (symbol,)
    )

    if profile:
        if side == 'LONG':
            return profile.long_fixed_tp_pct
        else:
            return profile.short_fixed_tp_pct

    # 2. 回退到自适应参数
    adaptive_params = db.query(
        "SELECT * FROM adaptive_params WHERE symbol = %s AND side = %s",
        (symbol, side)
    )

    if adaptive_params:
        return adaptive_params.take_profit_pct

    # 3. 使用默认值
    return 3.0  # 默认3%
```

#### 4.3 VolatilityProfileUpdater 定期更新

```python
class VolatilityProfileUpdater:
    """波动率配置更新器"""

    def update_all_symbols(self):
        """更新所有交易对的波动率配置"""

        for symbol in self.get_active_symbols():
            # 获取最近100根15M K线
            klines = self.fetch_klines(symbol, '15m', limit=100)

            # 计算阳线和阴线的平均涨跌幅
            bull_candles = [k for k in klines if k['close'] > k['open']]
            bear_candles = [k for k in klines if k['close'] < k['open']]

            avg_bull_pct = np.mean([
                (k['close'] - k['open']) / k['open'] * 100
                for k in bull_candles
            ]) if bull_candles else 2.0

            avg_bear_pct = np.mean([
                (k['close'] - k['open']) / k['open'] * 100
                for k in bear_candles
            ]) if bear_candles else -2.0

            # 止盈设置为平均涨跌幅的1.5倍
            long_tp = avg_bull_pct * 1.5
            short_tp = abs(avg_bear_pct) * 1.5

            # 更新数据库
            db.execute("""
                INSERT INTO symbol_volatility_profile
                (symbol, long_fixed_tp_pct, short_fixed_tp_pct,
                 avg_15m_bull_pct, avg_15m_bear_pct, updated_at)
                VALUES (%s, %s, %s, %s, %s, NOW())
                ON DUPLICATE KEY UPDATE
                    long_fixed_tp_pct = %s,
                    short_fixed_tp_pct = %s,
                    avg_15m_bull_pct = %s,
                    avg_15m_bear_pct = %s,
                    updated_at = NOW()
            """, (symbol, long_tp, short_tp, avg_bull_pct, avg_bear_pct,
                  long_tp, short_tp, avg_bull_pct, avg_bear_pct))
```

**更新频率**: 每小时执行一次

---

### 5. 波动率调整的止损倍数

```python
def calculate_stop_loss_pct(signal_components, base_sl_pct):
    """计算波动率调整的止损百分比"""

    if 'volatility_high' in signal_components:
        # 高波动环境: 止损扩大1.5倍
        adjusted_sl = base_sl_pct * 1.5
        logger.info(f"高波动环境，止损从{base_sl_pct}%扩大到{adjusted_sl}%")
        return adjusted_sl
    else:
        return base_sl_pct

# 使用示例
base_stop_loss = 2.0  # 默认2%
adjusted_stop_loss = calculate_stop_loss_pct(
    position.signal_components,
    base_stop_loss
)
# 如果有volatility_high信号: adjusted_stop_loss = 3.0%
```

---

## 自适应优化系统

### 1. 评分权重动态调整

#### 1.1 ScoringWeightOptimizer

```python
class ScoringWeightOptimizer:
    """信号评分权重优化器"""

    def run_weekly_optimization(self):
        """每周执行一次权重优化"""

        # 1. 统计最近7天各信号组件的表现
        signal_stats = self.analyze_signal_performance(days=7)

        for signal_component, stats in signal_stats.items():
            # 2. 计算综合评分
            performance_score = self.calculate_performance_score(stats)

            # 3. 决定权重调整
            adjustment = self.get_weight_adjustment(performance_score)

            # 4. 更新数据库
            self.update_weight(signal_component, adjustment)
```

#### 1.2 性能评分公式

```python
def calculate_performance_score(stats):
    """计算信号组件性能评分"""

    win_rate = stats['wins'] / stats['total'] if stats['total'] > 0 else 0.5
    avg_pnl = stats['total_pnl'] / stats['total'] if stats['total'] > 0 else 0

    # 胜率评分 (基准50%)
    win_rate_score = (win_rate - 0.50) * 100
    # 平均盈亏评分 (每$5 = 100分)
    pnl_score = avg_pnl / 5 * 100

    # 综合评分 (胜率60%权重 + 盈亏40%权重)
    performance_score = win_rate_score * 0.6 + pnl_score * 0.4

    return performance_score
```

#### 1.3 权重调整规则

```python
def get_weight_adjustment(performance_score):
    """根据性能评分决定权重调整"""

    if performance_score > 10:
        return +3  # 优秀，增加3分
    elif performance_score > 5:
        return +2  # 良好，增加2分
    elif performance_score > 0:
        return +1  # 正常，增加1分
    elif performance_score > -5:
        return 0   # 保持不变
    elif performance_score > -10:
        return -2  # 较差，减少2分
    else:
        return -3  # 很差，减少3分

def update_weight(signal_component, adjustment):
    """更新权重"""

    current_weight = self.get_current_weight(signal_component)
    new_weight = current_weight + adjustment

    # 权重范围限制: 5-30分
    new_weight = max(5, min(30, new_weight))

    db.execute("""
        UPDATE signal_scoring_weights
        SET base_weight = %s, updated_at = NOW()
        WHERE signal_component = %s
    """, (new_weight, signal_component))
```

---

### 2. 交易对3级评级自动调整

#### 2.1 SymbolRatingManager

```python
class SymbolRatingManager:
    """交易对评级管理器"""

    def daily_rating_check(self):
        """每天凌晨2点自动运行"""

        for symbol in self.get_active_symbols():
            # 1. 分析最近7天表现
            stats = self.analyze_symbol_performance(symbol, days=7)

            # 2. 检查是否需要升级
            if self.should_upgrade(stats):
                self.upgrade_rating(symbol)

            # 3. 检查是否需要降级
            elif self.should_downgrade(stats):
                self.downgrade_rating(symbol)
```

#### 2.2 降级触发条件

```python
def should_downgrade(stats):
    """检查是否需要降级"""

    current_level = stats['rating_level']

    # Level 0 → 1
    if current_level == 0:
        if stats['hard_stop_loss_count'] >= 2:
            return True, "连续2次硬止损"
        if stats['total_pnl'] <= -20:
            return True, "累计亏损>=$20"

    # Level 1 → 2
    elif current_level == 1:
        if stats['hard_stop_loss_count'] >= 3:
            return True, "连续3次硬止损"
        if stats['total_pnl'] <= -50:
            return True, "累计亏损>=$50"

    # Level 2 → 3
    elif current_level == 2:
        if stats['hard_stop_loss_count'] >= 4:
            return True, "连续4次硬止损"
        if stats['total_pnl'] <= -100:
            return True, "累计亏损>=$100"

    return False, ""
```

#### 2.3 升级触发条件

```python
def should_upgrade(stats):
    """检查是否需要升级"""

    current_level = stats['rating_level']

    # 只有黑名单可以升级
    if current_level == 0:
        return False, "已是白名单"

    # Level 3 → 2
    if current_level == 3:
        if stats['win_rate_7d'] >= 0.60 and stats['pnl_7d'] >= 50:
            return True, "7天胜率>=60%且盈利>=$50"

    # Level 2 → 1
    elif current_level == 2:
        if stats['win_rate_7d'] >= 0.55 and stats['pnl_7d'] >= 30:
            return True, "7天胜率>=55%且盈利>=$30"

    # Level 1 → 0
    elif current_level == 1:
        if stats['win_rate_7d'] >= 0.52 and stats['pnl_7d'] >= 20:
            return True, "7天胜率>=52%且盈利>=$20"

    return False, ""
```

---

### 3. 信号组合黑名单自动维护

#### 3.1 每4小时自动优化流程

```python
def run_4hourly_optimization():
    """每4小时执行一次 (在main.py中配置)"""

    # 1. 分析最近24小时信号质量
    subprocess.run(['python', 'analyze_24h_signals.py'])

    # 2. 生成优化建议 (optimization_actions.json)
    # analyze_24h_signals.py 会自动生成这个文件

    # 3. 执行优化操作
    subprocess.run(['python', 'execute_brain_optimization.py'])
```

#### 3.2 analyze_24h_signals.py 逻辑

```python
def analyze_24h_signals():
    """分析最近24小时信号质量"""

    positions = db.query("""
        SELECT * FROM futures_positions
        WHERE created_at >= NOW() - INTERVAL 24 HOUR
    """)

    # 按信号组合+方向分组统计
    signal_stats = defaultdict(lambda: {
        'total': 0,
        'wins': 0,
        'losses': 0,
        'total_pnl': 0,
        'avg_score': 0
    })

    for pos in positions:
        key = f"{pos.entry_signal_type}_{pos.position_side}"
        signal_stats[key]['total'] += 1

        if pos.realized_pnl > 0:
            signal_stats[key]['wins'] += 1
        else:
            signal_stats[key]['losses'] += 1

        signal_stats[key]['total_pnl'] += pos.realized_pnl
        signal_stats[key]['avg_score'] += pos.entry_score

    # 生成优化建议
    actions = []
    for key, stats in signal_stats.items():
        win_rate = stats['wins'] / stats['total']
        avg_pnl = stats['total_pnl'] / stats['total']

        # 触发黑名单条件
        if stats['total'] >= 5:  # 至少5笔交易
            if win_rate < 0.35 or stats['total_pnl'] < -100:
                signal_type, side = key.rsplit('_', 1)
                actions.append({
                    'action': 'BLACKLIST_SIGNAL',
                    'signal_type': signal_type,
                    'side': side,
                    'reason': f"24H胜率{win_rate*100:.1f}%,亏损${stats['total_pnl']:.2f}"
                })

        # 触发提高阈值条件
        if stats['total'] >= 3 and win_rate < 0.45:
            signal_type, side = key.rsplit('_', 1)
            actions.append({
                'action': 'RAISE_THRESHOLD',
                'signal_type': signal_type,
                'side': side,
                'current_avg_score': stats['avg_score'] / stats['total'],
                'reason': f"24H胜率{win_rate*100:.1f}%,需提高阈值"
            })

    # 保存到文件
    with open('optimization_actions.json', 'w') as f:
        json.dump({'actions': actions}, f, indent=2)
```

#### 3.3 execute_brain_optimization.py 逻辑

```python
def execute_optimization():
    """执行优化操作"""

    # 1. 读取优化建议
    with open('optimization_actions.json', 'r') as f:
        data = json.load(f)

    actions = data.get('actions', [])

    for action in actions:
        if action['action'] == 'BLACKLIST_SIGNAL':
            # 添加到信号黑名单
            db.execute("""
                INSERT INTO signal_blacklist
                (signal_type, position_side, reason, is_active)
                VALUES (%s, %s, %s, TRUE)
                ON DUPLICATE KEY UPDATE
                    is_active = TRUE,
                    reason = %s,
                    updated_at = NOW()
            """, (
                action['signal_type'],
                action['side'],
                action['reason'],
                action['reason']
            ))

        elif action['action'] == 'RAISE_THRESHOLD':
            # 提高信号阈值
            current_avg = action['current_avg_score']
            new_threshold = max(50, current_avg + 10)

            db.execute("""
                INSERT INTO signal_threshold_overrides
                (signal_type, position_side, min_score, reason, is_active)
                VALUES (%s, %s, %s, %s, TRUE)
                ON DUPLICATE KEY UPDATE
                    min_score = %s,
                    reason = %s,
                    is_active = TRUE,
                    updated_at = NOW()
            """, (
                action['signal_type'],
                action['side'],
                new_threshold,
                action['reason'],
                new_threshold,
                action['reason']
            ))
```

---

## 数据库配置表

### 1. signal_scoring_weights - 信号评分权重

```sql
CREATE TABLE signal_scoring_weights (
    signal_component VARCHAR(100) PRIMARY KEY,  -- 信号组件名称
    weight_long INT DEFAULT 0,                  -- LONG方向权重
    weight_short INT DEFAULT 0,                 -- SHORT方向权重
    base_weight INT DEFAULT 0,                  -- 基础权重
    is_active BOOLEAN DEFAULT TRUE,             -- 是否激活
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 示例数据
INSERT INTO signal_scoring_weights VALUES
('position_low', 20, 0, 20, TRUE),
('momentum_down_3pct', 0, 15, 15, TRUE),
('volume_power_bull', 25, 0, 25, TRUE);
```

### 2. signal_blacklist - 信号组合黑名单

```sql
CREATE TABLE signal_blacklist (
    id INT AUTO_INCREMENT PRIMARY KEY,
    signal_type VARCHAR(500),                   -- 信号组合名称
    position_side VARCHAR(10),                  -- LONG或SHORT
    reason VARCHAR(500),                        -- 拉黑原因
    is_active BOOLEAN DEFAULT TRUE,             -- 是否激活
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY uk_signal_side (signal_type, position_side)
);

-- 示例数据
INSERT INTO signal_blacklist (signal_type, position_side, reason) VALUES
('position_low + volume_power_bull', 'LONG', '24H胜率20.0%,亏损$-268.19'),
('breakdown_short + momentum_down_3pct + position_low', 'LONG', '24H胜率21.7%,亏损$-703.58');
```

### 3. trading_blacklist - 交易对黑名单

```sql
CREATE TABLE trading_blacklist (
    symbol VARCHAR(50) PRIMARY KEY,
    level INT DEFAULT 1,                        -- 黑名单等级 (1或2)
    reason TEXT,                                -- 拉黑原因
    is_active BOOLEAN DEFAULT TRUE,             -- 是否激活
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 示例数据
INSERT INTO trading_blacklist (symbol, level, reason) VALUES
('FHE/USDT', 1, '频繁亏损'),
('RIVER/USDT', 2, '严重亏损');
```

### 4. symbol_rating_level - 交易对评级

```sql
CREATE TABLE symbol_rating_level (
    symbol VARCHAR(50) PRIMARY KEY,
    level INT DEFAULT 0,                        -- 0=白名单, 1-3=黑名单级别
    reason TEXT,                                -- 变更原因
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 示例数据
INSERT INTO symbol_rating_level (symbol, level, reason) VALUES
('BTC/USDT', 0, '四大天王'),
('ETH/USDT', 0, '四大天王'),
('DOGE/USDT', 1, '连续2次硬止损');
```

### 5. futures_positions - 核心持仓表

```sql
CREATE TABLE futures_positions (
    id INT AUTO_INCREMENT PRIMARY KEY,
    symbol VARCHAR(50),
    position_side VARCHAR(10),                  -- LONG或SHORT
    entry_signal_type VARCHAR(500),             -- 信号组合名称
    entry_score INT,                            -- 开仓评分
    signal_components JSON,                     -- 信号组件详情
    entry_price DECIMAL(20, 8),
    quantity DECIMAL(20, 8),
    position_value DECIMAL(20, 8),
    leverage INT DEFAULT 10,
    stop_loss_price DECIMAL(20, 8),
    take_profit_price DECIMAL(20, 8),
    mark_price DECIMAL(20, 8),                  -- 当前标记价格
    unrealized_pnl DECIMAL(20, 8),              -- 未实现盈亏
    unrealized_pnl_pct DECIMAL(10, 4),          -- 未实现盈亏百分比
    realized_pnl DECIMAL(20, 8),                -- 已实现盈亏
    max_profit_pct DECIMAL(10, 4),              -- 最高盈利百分比
    max_profit_price DECIMAL(20, 8),            -- 最高盈利时的价格
    max_profit_time TIMESTAMP,                  -- 最高盈利时间
    timeout_at TIMESTAMP,                       -- 动态超时时间
    planned_close_time TIMESTAMP,               -- 计划平仓时间
    partial_close_stage INT DEFAULT 0,          -- 部分平仓阶段 (0-3)
    status VARCHAR(20) DEFAULT 'open',          -- open, closed
    close_time TIMESTAMP,
    close_reason VARCHAR(200),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_symbol_status (symbol, status),
    INDEX idx_status_created (status, created_at)
);
```

### 6. symbol_volatility_profile - 波动率配置

```sql
CREATE TABLE symbol_volatility_profile (
    symbol VARCHAR(50) PRIMARY KEY,
    long_fixed_tp_pct DECIMAL(5, 2),            -- LONG头寸止盈%
    short_fixed_tp_pct DECIMAL(5, 2),           -- SHORT头寸止盈%
    avg_15m_bull_pct DECIMAL(5, 2),             -- 平均15M阳线涨幅%
    avg_15m_bear_pct DECIMAL(5, 2),             -- 平均15M阴线跌幅%
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 示例数据
INSERT INTO symbol_volatility_profile VALUES
('BTC/USDT', 2.5, 2.3, 1.67, -1.53, NOW()),
('ETH/USDT', 3.1, 2.9, 2.07, -1.93, NOW());
```

### 7. signal_threshold_overrides - 信号阈值覆盖

```sql
CREATE TABLE signal_threshold_overrides (
    id INT AUTO_INCREMENT PRIMARY KEY,
    signal_type VARCHAR(500),
    position_side VARCHAR(10),
    min_score INT,                              -- 最低评分要求
    reason VARCHAR(500),
    is_active BOOLEAN DEFAULT TRUE,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY uk_signal_side (signal_type, position_side)
);

-- 示例数据
INSERT INTO signal_threshold_overrides (signal_type, position_side, min_score, reason) VALUES
('position_low + trend_1d_bull', 'LONG', 50, '24H胜率42.0%,需提高阈值');
```

### 8. adaptive_params - 自适应参数（已废弃，保留兼容）

```sql
CREATE TABLE adaptive_params (
    symbol VARCHAR(50),
    position_side VARCHAR(10),
    stop_loss_pct DECIMAL(5, 2),
    take_profit_pct DECIMAL(5, 2),
    min_holding_minutes INT,
    position_size_multiplier DECIMAL(5, 2),
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (symbol, position_side)
);
```

---

## 完整决策流程图

### 开仓流程

```
1. 信号生成
   ├─ 计算8大类信号组件评分
   ├─ 叠加得到 long_score 和 short_score
   └─ 判断: score >= 35 ?
       ├─ Yes → 继续
       └─ No  → 不开仓

2. 信号过滤
   ├─ A. 黑名单检查
   │   ├─ 交易对黑名单 (trading_blacklist)
   │   ├─ 信号组合黑名单 (signal_blacklist)
   │   └─ 3级评级 (symbol_rating_level)
   │       └─ Level 3 → 禁止交易
   ├─ B. 防追高/追跌过滤
   │   ├─ LONG: position_pct > 80% → 拒绝
   │   └─ SHORT: position_pct < 20% → 拒绝
   ├─ C. 时间框架一致性
   │   ├─ LONG不能有trend_1h_bear/trend_1d_bear
   │   └─ SHORT不能有trend_1h_bull/trend_1d_bull
   ├─ D. position_high额外验证
   │   └─ 检查上影线比例、成交量萎缩
   └─ E. 冷却期检查
       └─ 1小时内平仓过 → 拒绝

3. Big4趋势检测
   ├─ 检测市场整体趋势 (BULLISH/BEARISH/NEUTRAL)
   └─ 调整仓位倍数
       ├─ 顺势: 1.2x
       └─ 其他: 1.0x

4. 仓位计算
   ├─ 基础仓位: 400 USDT
   ├─ 评级倍数: level 0=1.0x, 1=0.25x, 2=0.125x
   ├─ Big4倍数: 1.0x 或 1.2x
   └─ 最终仓位 = 基础 × 评级 × Big4

5. 动态参数计算
   ├─ 动态超时时间 (根据entry_score)
   ├─ 止盈% (从volatility_profile或adaptive_params)
   ├─ 止损% (波动率调整: volatility_high → 1.5倍)
   └─ 计划平仓时间 (分批建仓结束时间)

6. 执行开仓
   ├─ 选择: 分批建仓 or 一次性开仓
   ├─ 分批建仓:
   │   ├─ 启动价格采样 (5分钟基线)
   │   ├─ 第1批: 30% (强15m/正常20m/弱30m)
   │   ├─ 第2批: 30% (强25m/正常40m/弱60m)
   │   └─ 第3批: 40% (强35m/正常60m/弱90m)
   └─ 一次性开仓: 100%

7. 启动监控
   └─ SmartExitOptimizer.start_monitoring(position_id)
```

### 平仓流程

```
监控循环 (每秒检查)
   ├─ 获取实时价格 (WS → REST → K线)
   ├─ 计算当前盈亏
   └─ 更新最高盈利记录

优先级0: 最小持仓时间检查 (2小时)
   └─ 未满2小时 → 只检查止损止盈

优先级1: 固定止损 (无时间限制)
   ├─ LONG: price <= stop_loss_price → 平仓
   └─ SHORT: price >= stop_loss_price → 平仓

优先级2: 固定止盈
   ├─ LONG: price >= take_profit_price → 平仓
   └─ SHORT: price <= take_profit_price → 平仓

优先级3: 分批建仓恢复的持仓
   └─ 无planned_close_time → 仅监控止损止盈

[满足2小时最小持仓时间后...]

优先级4: 智能顶底识别
   ├─ LONG: 盈利>=2% + 1H和4H都强烈看空 → 平仓
   └─ SHORT: 盈利>=2% + 1H和4H都强烈看多 → 平仓

优先级5: 动态超时检查
   └─ now >= timeout_at → 平仓

优先级6: 分阶段超时
   ├─ 1H: 亏损>-2.5% → 平仓
   ├─ 2H: 亏损>-2.0% → 平仓
   ├─ 3H: 亏损>-1.5% → 平仓
   └─ 4H: 亏损>-1.0% → 平仓

优先级7: 6小时绝对托底
   └─ 持仓>=6H → 平仓

优先级8: K线强度衰减 (每15分钟检查)
   ├─ 阶段0→1: 盈利>=2% + 强度大幅减弱 → 平仓50%
   ├─ 阶段1→2: 盈利>=4% + 强度减弱 OR 持仓4H → 平仓70%
   ├─ 阶段2→3: 持仓5H OR 强度<10 → 平仓100%
   ├─ 特殊: 亏损>1% + 方向反转 → 平仓100%
   └─ 特殊: 15M强力反转 + 亏损 → 平仓100%

智能分批平仓窗口 (T-30到T+0)
   ├─ T-30 to T-20: 建立10分钟价格基线
   ├─ T-20 to T+0: 寻找最佳平仓点
   │   ├─ 评分>=95 → 立即平仓
   │   ├─ 评分>=85 → 立即平仓
   │   ├─ 突破基线极值 → 立即平仓
   │   ├─ 强反向趋势 → 及时止损
   │   └─ 接近截止 → 必须平仓
   └─ T+0: 强制平仓
```

---

## 系统核心设计理念

### 1. 多维度信号融合
- 不依赖单一指标，而是8大类信号组件叠加
- 理论最高评分195分，实际开仓阈值35分
- 权重可动态调整，根据历史表现自学习

### 2. 分层风控体系
- 8个优先级的平仓条件
- 最小持仓时间保护（2小时）
- 分阶段超时机制（1H/2H/3H/4H/6H）
- 固定止损止盈 + 智能顶底识别

### 3. 时间感知交易
- 不同阶段不同规则
- 避免过早平仓和过度持仓
- 动态超时时间（根据entry_score）

### 4. 实时监控与降级
- 每秒检查一次持仓状态
- 多级价格获取降级策略（WS → REST → K线）
- 确保系统稳定性和可靠性

### 5. 自适应优化
- 每4小时分析信号质量
- 每周调整评分权重
- 每天检查交易对评级
- 自动维护黑名单

### 6. 智能分批执行
- 支持分批建仓（30%/30%/40%）
- 根据K线强度调整建仓速度
- 计划平仓窗口内寻找最佳出场点

---

## 关键参数配置

| 参数 | 默认值 | 说明 |
|------|-------|------|
| 开仓阈值 | 35分 | long_score或short_score需>=35 |
| 基础仓位 | 400 USDT | 白名单交易对 |
| 杠杆倍数 | 10x | 合约杠杆 |
| 最小持仓时间 | 2小时 | 保护期，仅止损止盈生效 |
| 最大持仓时间 | 6小时 | 绝对托底 |
| 默认止损 | 2.0% | 可根据波动率调整到3.0% |
| 默认止盈 | 3.0% | 可根据波动率配置动态调整 |
| 监控频率 | 1秒 | 持仓监控循环 |
| K线强度检查 | 15分钟 | 检查衰减和部分平仓 |
| 信号分析 | 4小时 | 自动优化频率 |
| 权重优化 | 每周 | ScoringWeightOptimizer |
| 评级检查 | 每天凌晨2点 | SymbolRatingManager |
| 波动率更新 | 每小时 | VolatilityProfileUpdater |

---

## 总结

本系统通过**多维度信号融合、分层风控、时间感知、实时监控、自适应优化、智能分批**六大核心机制，构建了一个完整的自动化交易系统。所有关键参数都可在数据库中配置和实时调整，无需重启服务。

系统的自学习能力体现在：
- 信号评分权重根据历史表现自动调整
- 交易对评级根据盈亏和止损次数自动升降级
- 信号组合黑名单根据最近表现自动维护
- 止盈止损参数根据交易对波动率自动调整

这种设计使系统能够持续优化，适应市场变化。
