# 超级大脑合约交易完整方案

> **文档创建时间**: 2026-01-23
> **重大更新**: 2026-01-26 - 集成高级信号检测系统
> **当前交易表现**: 30笔交易，胜率56.7%，总盈亏$31.64，盈亏比1.60:1
> **优化目标**: 提升胜率到65%+，盈亏比到2.0+，降低无效亏损，捕捉反转信号

---

## 📚 目录

- [第一部分: 质量优化方案 (2026-01-23)](#第一部分-质量优化方案-2026-01-23)
  - [问题1: TIMEOUT_4H](#问题1-timeout_4h-持仓4小时超时)
  - [问题2: hard_stop_loss](#问题2-hard_stop_loss-硬止损---黑名单分级制度)
  - [问题3: hedge_loss_cut](#问题3-hedge_loss_cut-对冲止损---降低对冲成本)
  - [问题4: 止盈触发率低](#问题4-止盈触发率低---基于15m-k线阳线阴线统计)

- [第二部分: 高级信号检测系统 (2026-01-26)](#第二部分-高级信号检测系统-2026-01-26)
  - [背景问题](#背景问题)
  - [高级信号类型](#高级信号类型)
  - [系统架构](#系统架构)
  - [集成方案](#集成方案)
  - [分批建仓流程](#分批建仓流程)

---

# 第一部分: 质量优化方案 (2026-01-23)

## 📊 问题诊断汇总

从 `analyze_recent_trades.py` 分析的最近24小时数据来看：

| 问题分类 | 交易数 | 胜率 | 平均盈亏 | 总盈亏 | 严重程度 |
|---------|--------|------|---------|--------|---------|
| **TIMEOUT_4H** (4小时超时) | 47笔 | 51.1% | $0.85 | $39.87 | 🔴 高 |
| **hard_stop_loss** (硬止损) | 10笔 | 0% | -$41.13 | -$411.30 | 🔴 高 |
| **hedge_loss_cut** (对冲止损) | 8笔 | 0% | -$15.69 | -$125.50 | 🔴 高 |
| **止盈触发** (移动止盈) | 1笔 | 100% | $24.82 | $24.82 | 🟡 中 |

---

## ✅ 问题1: TIMEOUT_4H (持仓4小时超时)

### 问题描述

- **当前逻辑**: 硬编码4小时超时，强制平仓
- **数据表现**: 47笔交易，胜率仅51.1%，总盈亏$39.87
- **核心问题**:
  - 很多单子持仓4小时仍未盈利，被动平仓
  - 最差交易多数是4小时超时亏损
  - 盈利单也可能在4小时被强制平仓，错失更大利润

### 优化方案

#### **方案1: 动态超时时间（基于评分和盈利状态）**

```python
def get_timeout_minutes(entry_score, current_pnl_pct, elapsed_minutes):
    """根据开仓评分和当前盈亏动态计算超时时间"""
    # 基于评分确定基础超时
    if entry_score >= 40:
        base_timeout = 360  # 高评分6小时
    elif entry_score >= 35:
        base_timeout = 300  # 5小时
    elif entry_score >= 30:
        base_timeout = 240  # 4小时
    else:
        base_timeout = 180  # 低评分3小时

    # 根据盈亏状态调整
    if current_pnl_pct > 1.0:  # 盈利>1%
        adjusted_timeout = base_timeout * 1.5  # 延长50%，让利润奔跑
    elif current_pnl_pct < -0.5:  # 亏损>0.5%
        adjusted_timeout = base_timeout * 0.7  # 缩短30%，及时止损
    else:
        adjusted_timeout = base_timeout

    return adjusted_timeout
```

#### **方案2: 分阶段超时策略**

```python
def check_stage_timeout(position):
    """分阶段检查持仓，不同时间点有不同的平仓条件"""
    elapsed_hours = (datetime.utcnow() - position['created_at']).total_seconds() / 3600
    current_pnl_pct = calculate_current_pnl_pct(position)

    # 盈利单不受超时限制
    if current_pnl_pct > 0:
        return False  # 转移动止盈管理

    # 分阶段检查（只针对亏损单）
    if elapsed_hours >= 4:
        if current_pnl_pct <= -0.5:  # 4小时亏损>0.5%
            return True
    elif elapsed_hours >= 3:
        if current_pnl_pct <= -1.0:  # 3小时亏损>1%
            return True
    # ...

    return False
```

---

## ✅ 问题2: hard_stop_loss (硬止损) - 黑名单分级制度

### 问题描述

- **当前表现**: 10笔硬止损，**胜率0%**，平均亏损$-41.13，总亏损$-411.30
- **核心认知**: 硬止损本来就不可能盈利，这是**结果不是原因**
- **真正问题**: 哪些交易对经常触发硬止损？应该降低或停止交易

### 优化方案

#### **交易对黑名单3级制度（动态升降级）**

```
【白名单】正常交易
- 保证金: 400 USDT (100%)
- 开仓阈值: 30分

【黑名单1级】表现不佳
- 保证金: 100 USDT (25%)
- 开仓阈值: 35分 (+5分)
- 进入条件: 硬止损3-5次/7天 或 亏损-100~-200 USDT

【黑名单2级】表现很差
- 保证金: 50 USDT (12.5%)
- 开仓阈值: 40分 (+10分)
- 进入条件: 硬止损5-8次/7天 或 亏损-200~-300 USDT

【黑名单3级】永久禁止交易
- 保证金: 0 USDT (禁止)
- 进入条件: 硬止损>8次/7天 或 亏损<-300 USDT
- ❌ 无法升级，永久禁止
```

---

## ✅ 问题3: hedge_loss_cut (对冲止损) - 降低对冲成本

### 问题描述

- **当前表现**: 8笔对冲止损，**胜率0%**，平均亏损$-15.69，总亏损$-125.50
- **当前问题**: 对冲单保证金400U，成本太高

### 优化方案

#### **方案1: 降低反转阈值（从30分降到15分）**

```python
# 修改代码
if new_score > old_score + 15:  # 从30改为15
    # 反转平仓
    close_position_by_side(opposite_side, reason='reverse_signal')
    # 开新方向
    open_position(opp)
```

#### **方案2: 降低对冲保证金（400U → 100U）**

```python
# 降低对冲单保证金到25%
opp['margin'] = base_margin * 0.25
opp['is_hedge'] = True
```

### 预期效果

| 指标 | 当前 | 优化后 | 改善 |
|-----|------|--------|------|
| 对冲数量 | 80笔/周 | 40笔/周 | -50% |
| 单次成本 | 400U | 100U | -75% |
| 总亏损 | -$1,255/周 | -$157/周 | **-87.5%** |

---

## ✅ 问题4: 止盈触发率低 - 基于15M K线阳线/阴线统计

### 问题描述

- **当前表现**: 30笔交易只有1笔触发止盈，触发率<5%
- **当前配置**: 移动止盈激活阈值8%，回撤2%平仓
- **核心问题**: 8%激活阈值太高，很少达到

### 优化方案

#### **基于最近10根15M阳线/阴线统计波动幅度**

```python
def calculate_optimal_take_profit(symbol, period='15m', lookback_bars=20):
    """
    基于最近N根15M K线统计波动幅度
    做多只看阳线，做空只看阴线
    """
    klines = get_klines(symbol, '15m', limit=20)

    bullish_candles = []  # 阳线
    bearish_candles = []  # 阴线

    for kline in klines:
        if close_price > open_price:
            # 阳线：计算从开盘到最高点的涨幅
            long_range = (high_price - open_price) / open_price * 100
            bullish_candles.append(long_range)
        elif close_price < open_price:
            # 阴线：计算从开盘到最低点的跌幅
            short_range = (open_price - low_price) / open_price * 100
            bearish_candles.append(short_range)

    # 取最近10根
    recent_bullish = sorted(bullish_candles, reverse=True)[:10]
    recent_bearish = sorted(bearish_candles, reverse=True)[:10]

    # 计算平均值
    long_avg = np.mean(recent_bullish) if recent_bullish else 2.0
    short_avg = np.mean(recent_bearish) if recent_bearish else 2.0

    # 止盈策略
    long_take_profit = long_avg * 0.7  # 固定止盈：70%
    long_trailing_activation = long_avg * 0.5  # 移动激活：50%

    return {
        'long_take_profit': round(long_take_profit, 2),
        'long_trailing_activation': round(long_trailing_activation, 2),
        # ...
    }
```

### 预期效果

| 指标 | 当前 | 优化后 | 改善 |
|-----|------|--------|------|
| 移动止盈激活阈值 | 固定8% | 动态1.4-4% | -50% |
| 止盈触发率 | <5% | 30-40% | +600% |
| 平均盈利单盈利 | $4.96 | $8-12 | +100% |

---

# 第二部分: 高级信号检测系统 (2026-01-26)

## 🎯 背景问题

### 错过的两次重要交易机会

#### 机会1: 昨晚 23:45-00:30 做空机会

| 交易对 | 特征 | 原因 | 解决 |
|--------|------|------|------|
| ETH/USDT | -0.89% + 放量20x | 所有5个主流币被黑名单拦截 | ✅ 已修复 (白名单保护) |
| SOL/USDT | -2.27% + 放量260x | 同上 | ✅ 已修复 |

#### 机会2: 今晨 04:00-07:00 做多机会

| 交易对 | 特征 | 原因 | 解决 |
|--------|------|------|------|
| BTC/USDT | 525点下影线 + 5.71x量能 | 系统缺少反转信号检测 | ✅ 本次新增 |
| ETH/USDT | 长下影线 + 2.68x量能 | 同上 | ✅ 本次新增 |
| SOL/USDT | 长下影线 + 3.48x量能 | 同上 | ✅ 本次新增 |

---

## 🔍 高级信号类型

### 信号1: 上涨无力+突然下跌做空 (WEAK_RALLY_SHORT)

**触发条件**:

**1H 级别确认**:
- 前6小时上涨无力
  - 上涨K线 > 3根
  - 平均涨幅 < 0.3%
  - 价格振幅 < 2%

**15M 级别确认**:
- 最近2小时内至少有1根K线下探
  - 最低价 < 开盘价 * 0.99

**5M 级别触发 (二选一)**:

**条件A: 单根大幅下跌**
- 跌幅 > 0.4%
- 放量 > 2倍
- 实体占比 > 30% (非十字星)

**条件B: 连续下跌 (更可靠!)**
- 连续2根K线各跌幅 > 0.2%
- 累计跌幅 > 0.4%
- 至少一根放量 > 2倍
- **奖励**: +5分

**评分系统 (0-105分)**:
- 下跌幅度: 0-30分
- 成交量倍数: 0-40分
- 多周期确认: 0-30分
- 连续下跌奖励: +5分

**实际案例**:
```
昨晚 23:45 ETH/USDT
- 5M: -0.89% + 20x量能
- 15M: 有下探空间
- 1H: 前6小时上涨无力
→ 信号: WEAK_RALLY_SHORT (STRONG, 85分)
→ 预期收益: -3.1%做空
```

---

### 信号2: 底部反转做多 (BOTTOM_REVERSAL_LONG)

**触发条件**:

**5M 级别触发**:
- 最近30分钟内至少出现3个锤头线
  - 锤头线定义:
    - 下影线 > 总长度的60% 或
    - 下影线 > 实体长度的2倍
  - 必须在底部位置 (最低价 ≤ 24小时最低价 * 1.02)
  - 放量 > 2倍平均量

**15M 级别确认**:
- 最近2小时内至少出现2个锤头线

**1H 级别确认**:
- 前6小时横盘筑底
  - 平均K线变化 < 0.3%

**评分系统 (0-100分)**:
- 下影线长度: 0-30分
- 成交量倍数: 0-40分
- 多周期确认: 0-30分

**实际案例**:
```
今晨 04:30 BTC/USDT
- 5M: 525点下影线 + 5.71x量能 (3次锤头线)
- 15M: 2次锤头线
- 1H: 横盘筑底
→ 信号: BOTTOM_REVERSAL_LONG (STRONG, 78分)
→ 实际收益: +1.72%做多
```

---

## 🏗️ 系统架构

```
┌──────────────────────────────────────────────────────────┐
│              超级大脑决策系统 (Enhanced)                   │
│         SmartDecisionBrainEnhanced                        │
└────────────────────────┬─────────────────────────────────┘
                         │
            ┌────────────┴────────────┐
            │                         │
            ▼                         ▼
┌─────────────────────┐     ┌─────────────────────┐
│   主流币检查         │     │   白名单检查         │
│ BTC/ETH/SOL/BNB     │     │   其他币种           │
└──────────┬──────────┘     └──────────┬──────────┘
           │                           │
           ▼                           │
┌─────────────────────┐                │
│  高级信号检测        │                │
│  AdvancedSignalDetector              │
│  (优先级最高)        │                │
└──────────┬──────────┘                │
           │                           │
           │ 无信号                    │
           ▼                           ▼
           └───────────┬───────────────┘
                       │
                       ▼
          ┌────────────────────────┐
          │   多维度分析            │
          │ - 价格位置 (30分)       │
          │ - 趋势强度 (20分)       │
          │ - 支撑阻力 (30分)       │
          └────────────────────────┘
                       │
                       ▼
          ┌────────────────────────┐
          │   分批建仓执行          │
          │ SmartEntryExecutor     │
          │ - 30% / 30% / 40%      │
          │ - 30分钟动态建仓       │
          └────────────────────────┘
```

---

## 🔌 集成方案

### 核心文件

#### 1. 高级信号检测器

**文件**: `app/services/advanced_signal_detector.py`

```python
class AdvancedSignalDetector:
    def __init__(self, db_config: dict)

    def detect_signals(self, symbol: str) -> Optional[SignalResult]:
        """主入口: 检测所有类型的高级信号"""
        # 优先级1: 底部反转做多
        bottom_signal = self.detect_bottom_reversal_long(...)
        if bottom_signal:
            return bottom_signal

        # 优先级2: 上涨无力做空
        short_signal = self.detect_weak_rally_short(...)
        if short_signal:
            return short_signal

        return None

    def detect_weak_rally_short(self, symbol, klines_1h, klines_15m, klines_5m):
        """检测上涨无力+突然下跌做空信号"""
        # 1H: 检查上涨无力
        # 15M: 检查下探空间
        # 5M: 检查触发条件 (条件A或B)
        # 计算评分 (0-105)
        # 返回信号结果

    def detect_bottom_reversal_long(self, symbol, klines_1h, klines_15m, klines_5m):
        """检测底部反转做多信号"""
        # 1H: 检查横盘筑底
        # 15M: 检查锤头线 (至少2个)
        # 5M: 检查锤头线 (至少3个) + 底部位置 + 放量
        # 计算评分 (0-100)
        # 返回信号结果

@dataclass
class SignalResult:
    signal_type: str  # 'WEAK_RALLY_SHORT' 或 'BOTTOM_REVERSAL_LONG'
    direction: str    # 'LONG' 或 'SHORT'
    strength: str     # 'STRONG' (70-105分) 或 'MEDIUM' (50-69分)
    score: int        # 0-105
    entry_price: float
    stop_loss: float
    reason: str
    details: Dict
```

#### 2. 增强版超级大脑

**文件**: `app/services/smart_decision_brain_enhanced.py`

```python
class SmartDecisionBrainEnhanced:
    def __init__(self, db_config: dict):
        # 主流币 (永不被黑名单拦截)
        self.whitelist_main = ['BTC/USDT', 'ETH/USDT', 'SOL/USDT', 'BNB/USDT']

        # 白名单 (只做LONG)
        self.whitelist_long = ['BCH/USDT', 'ENA/USDT', ...]

        # 高级信号检测器
        self.advanced_detector = AdvancedSignalDetector(db_config)
        self.enable_advanced_signals = True

    def should_trade(self, symbol: str) -> Dict:
        """决策是否交易"""
        # 1. 黑名单检查 (主流币例外)
        if symbol in self.blacklist and symbol not in self.whitelist_main:
            return {'decision': False, ...}

        # 2. 主流币优先检测高级信号
        if symbol in self.whitelist_main:
            advanced_signal = self.check_advanced_signals(symbol)
            if advanced_signal:
                # 立即开仓,不再进行多维度分析
                return {
                    'decision': True,
                    'direction': advanced_signal['direction'],
                    'score': 80,  # STRONG信号
                    'signal_source': 'advanced_signal',
                    'trade_params': {
                        'stop_loss': advanced_signal['stop_loss'],
                        'max_hold_minutes': 360  # 6小时
                    }
                }

        # 3. 白名单 + 多维度分析
        # ...原有逻辑
```

**决策优先级**:
1. 黑名单检查 (主流币例外)
2. 主流币 + 高级信号 (最高优先级)
3. 白名单 + 多维度分析

---

## 🔄 超级大脑决策流程详解

### 决策优先级和流程

```
输入: symbol (交易对, 如 BTC/USDT)
    ↓
【第1步】黑名单检查
    if symbol in blacklist AND symbol not in whitelist_main:
        ❌ 拒绝交易
    ↓
【第2步】主流币高级信号检测 (最高优先级)
    if symbol in whitelist_main (BTC/ETH/SOL/BNB):
        检测高级信号:
          ├─> BOTTOM_REVERSAL_LONG (底部反转做多)
          └─> WEAK_RALLY_SHORT (上涨无力做空)

        if 检测到信号:
            ✅ 立即返回开仓决策 (不再进行多维度分析)
            signal_score >= 70: 决策分80, 持仓6小时
            signal_score >= 50: 决策分50, 持仓4小时
    ↓
【第3步】白名单多维度分析
    if symbol not in whitelist_long AND not in whitelist_main:
        ❌ 拒绝交易

    加载K线: 1D (50根) + 1H (100根)

    多维度评分:
    ├─> 价格位置分析 (0-30分)
    │   ├─ 底部区域 (<30%): +20分
    │   ├─ 中部区域 (30-70%): +5分
    │   └─ 顶部区域 (>70%): -20分
    │   └─ 7日涨幅 <10%: +10分
    │
    ├─> 趋势强度分析 (0-20分)
    │   └─ 30D内阳线 >60%: +20分
    │
    └─> 支撑阻力分析 (0-30分)
        └─ 盈亏比 >=2: +30分

    综合评分 = 价格位置分 + 趋势分 + 支撑阻力分

    if 综合评分 >= 30:
        ✅ 返回开仓决策 (LONG方向)
        score >= 45: 持仓6小时
        score >= 30: 持仓4小时
        score < 30:  持仓2小时
    else:
        ❌ 拒绝交易
```

### 决策结果数据结构

```python
{
    'decision': True/False,
    'direction': 'LONG' / 'SHORT' / None,
    'score': 0-100,  # 决策评分
    'signal_source': 'advanced_signal' / 'analysis' / 'blacklist',
    'reasons': [
        '🎯 高级信号: BOTTOM_REVERSAL_LONG',
        '📊 信号评分: 78分 (STRONG)',
        '💡 底部3次锤头线 + 放量4.5x + 1H横盘筑底'
    ],
    'trade_params': {
        'stop_loss': 85500.0,
        'take_profit': None,  # 高级信号暂不设置
        'max_hold_minutes': 360,  # 最大持仓时间
        'entry_score': 80,
        'signal_details': {...}
    }
}
```

---

## 🔍 高级信号检测详细逻辑

### 1. BOTTOM_REVERSAL_LONG (底部反转做多)

**多周期检测流程**:

```
【1H级别】横盘筑底检查
    最近4小时平均K线变化 < 0.3%
    ✅ 通过: +10分

【15M级别】长下影线确认
    最近2小时(8根K线)至少2个锤头线
    锤头线定义: 下影线 > 总长度 * 50%
    ✅ 通过: +10分

【5M级别】核心触发 (最近30分钟)
    至少3个锤头线:
      ├─ 下影线 > 60% 或 下影线 > 实体*2
      ├─ 必须在底部: 最低价 <= 24H最低价 * 1.02
      ├─ 放量: 成交量 >= 平均量 * 2.0
      └─ 收盘在上半部分

    评分计算:
      ├─ 下影线长度 (0-30分)
      │   └─ 最强锤头线 > 70%: +30分
      │   └─ 最强锤头线 > 60%: +20分
      │
      ├─ 量能评分 (0-40分)
      │   └─ 平均量能倍数 > 5x: +40分
      │   └─ 平均量能倍数 > 3x: +30分
      │   └─ 平均量能倍数 > 2x: +20分
      │
      └─ 多周期确认 (0-30分)
          └─ 1H横盘: +10分
          └─ 15M锤头线>=2: +10分
          └─ 5M锤头线>=4: +10分

总分 >= 70分: STRONG信号 (开仓评分80, 6小时)
总分 >= 50分: MEDIUM信号 (开仓评分50, 4小时)
总分 < 50分: 不产生信号
```

### 2. WEAK_RALLY_SHORT (上涨无力做空)

**多周期检测流程**:

```
【1H级别】上涨无力检查
    最近6小时:
      ├─ 阳线 > 3根
      ├─ 平均涨幅 < 0.3%
      └─ 价格振幅 < 2%
    ✅ 通过: +10分

【15M级别】下探空间确认
    最近2小时至少1根K线下探
    最低价 < 开盘价 * 0.99
    ✅ 通过: +10分

【5M级别】触发条件 (二选一)

    条件A: 单根大跌
      ├─ 跌幅 >= 0.4%
      ├─ 放量 >= 2倍
      └─ 实体占比 > 30%

    条件B: 连续下跌 (更可靠!)
      ├─ 连续2根各跌 >= 0.2%
      ├─ 累计跌幅 >= 0.4%
      ├─ 至少1根放量 >= 2倍
      └─ 奖励: +5分

    评分计算:
      ├─ 下跌幅度 (0-30分)
      │   └─ 跌幅 > 0.6%: +30分
      │   └─ 跌幅 > 0.4%: +25分 (连续) / +20分 (单根)
      │
      ├─ 量能评分 (0-40分)
      │   └─ 量能 > 10x: +40分
      │   └─ 量能 > 5x:  +30分
      │   └─ 量能 > 2x:  +20分
      │   └─ 连续下跌且两根都放量: +5分
      │
      └─ 多周期确认 (0-30分)
          └─ 1H上涨无力: +10分
          └─ 15M下探空间: +10分
          └─ 加速下跌: +5分

总分 >= 70分: STRONG信号 (开仓评分80, 6小时)
总分 >= 50分: MEDIUM信号 (开仓评分50, 4小时)
总分 < 50分: 不产生信号
```

---

## 🏗️ 分批建仓详细执行流程

### 完整30分钟建仓时间轴

```
T+0min (信号触发)
    ↓
启动SmartEntryExecutor
    初始化建仓计划:
      ├─ 第1批: 30%, 超时15分钟
      ├─ 第2批: 30%, 超时20分钟
      └─ 第3批: 40%, 超时28分钟
    ↓
启动PriceSampler (滚动5分钟窗口)
    每秒采样1次价格
    窗口大小: 300秒 = 300个样本
    ↓
T+0-5min: 建立初始基线
    采集300个价格样本
    计算: min/max/P10/P25/P50/P75/P90
    计算趋势: direction/strength/change_pct
    ↓
T+5min: 基线建立完成 ✅
    开始动态入场执行
    基线每秒更新 (滚动5分钟窗口)
    ↓
T+5-15min: 第1批建仓窗口 (30%)
    每10秒检查一次入场条件 (6种条件)

    做多条件 (满足任一):
    1. 极优价格: 评分 >= 80分
       └─ 价格在P10以下，底部10%区间

    2. 优秀价格 + 止跌信号
       └─ 评分 >= 60分 + 止跌信号 >= 50分

    3. 突破基线最低价
       └─ 当前价 <= 基线最低价 * 0.999

    4. 强上涨避免错过
       └─ 强上涨趋势 (strength>0.7) + 价格升至P75

    5. 超时兜底 (12分钟)
       └─ 评分 >= 40分

    6. 强制入场 (15分钟)
       └─ 无条件入场

    ✅ 触发建仓:
      ├─ 计算保证金: 总保证金 * 30%
      ├─ 计算数量: (保证金 * 杠杆) / 价格
      ├─ 创建持仓记录 (status='building')
      ├─ 冻结保证金
      └─ 记录入场价格、时间、原因
    ↓
T+5-20min: 第2批建仓窗口 (30%)
    距第1批至少3分钟后开始检查

    做多条件 (满足任一):
    1. 回调加仓
       └─ 当前价 <= 第1批价格 * 0.997 (-0.3%)

    2. 价格仍低
       └─ 当前价 <= 基线P25

    3. 超时兜底 (距第1批10分钟)

    4. 强制建仓 (距信号20分钟)

    ✅ 触发建仓:
      ├─ 累加持仓数量
      ├─ 更新平均价格
      ├─ 重新计算止损止盈 (基于新均价)
      ├─ 冻结新增保证金
      └─ 更新持仓记录 (batch_filled)
    ↓
T+5-28min: 第3批建仓窗口 (40%)
    距第2批至少3分钟后开始检查

    做多条件 (满足任一):
    1. 价格优于平均成本
       └─ 当前价 <= 前两批平均价

    2. 价格仍低于中位数
       └─ 当前价 <= 基线P50

    3. 价格接近平均价
       └─ 当前价 <= 平均价 * 1.003 (+0.3%容忍)

    4. 超时兜底 (距第2批8分钟)

    5. 强制完成 (距信号28分钟)

    ✅ 触发建仓:
      ├─ 累加持仓数量 (最后40%)
      ├─ 更新平均价格
      ├─ 重新计算止损止盈
      ├─ 状态更新: building → open
      ├─ 设置计划平仓时间
      └─ 完成建仓 🎉
    ↓
T+30min: 建仓窗口结束
    停止价格采样器
    如有未完成批次，强制建仓
```

### 价格评分系统 (做多开仓)

```python
def is_good_long_price(current_price: Decimal) -> Dict:
    """
    做多开仓价格评分
    目标: 在低位买入

    评分 = 价格分位数评分(70分) + 止跌信号(30分) + 突破加分(15分)
    """
    baseline = get_current_baseline()

    # 价格分位数评分 (0-70分)
    if price <= baseline['p10']:
        score += 70  # 底部10%，极优买点
    elif price <= baseline['p25']:
        score += 55  # 底部25%，优秀买点
    elif price <= baseline['p50']:
        score += 35  # 中位数以下，良好买点
    elif price <= baseline['p75']:
        score += 20  # 一般买点
    else:
        score += 5   # 顶部区间，较差买点

    # 止跌信号检测 (0-30分)
    # 检查最近6根5M K线的下影线
    stop_signal = detect_bottom_signal()
    if stop_signal >= 70:
        score += 30  # 强止跌信号
    elif stop_signal >= 50:
        score += 20  # 中等止跌信号

    # 突破加分 (0-15分)
    if price < baseline['min_price']:
        score += 15  # 突破基线最低价

    return {
        'score': min(score, 100),
        'reason': '极优买点' if score >= 80 else '优秀买点',
        'details': {...}
    }
```

### 持仓记录数据库操作

**第1批建仓** (创建记录):
```sql
INSERT INTO futures_positions (
    symbol, position_side, quantity, entry_price, avg_entry_price,
    leverage, margin, stop_loss_price, take_profit_price,
    batch_plan, batch_filled, entry_signal_time,
    status, created_at
) VALUES (
    'BTC/USDT', 'LONG', 0.0070, 86000, 86000,
    5, 120, 85500, NULL,
    '{"batches":[{"ratio":0.3,"timeout":15},{"ratio":0.3,"timeout":20},{"ratio":0.4,"timeout":28}]}',
    '{"batches":[{"batch_num":0,"ratio":0.3,"price":86000,"time":"...","quantity":0.0070}]}',
    '2026-01-26 04:30:00',
    'building', NOW()
)
```

**第2/3批建仓** (更新记录):
```sql
UPDATE futures_positions SET
    quantity = 0.0233,  -- 累加
    avg_entry_price = 85836,  -- 重新计算
    margin = 400,  -- 累加
    stop_loss_price = 85500,  -- 基于新均价
    batch_filled = '{"batches":[...]}',  -- 更新JSON
    updated_at = NOW()
WHERE id = 12345
```

**完成建仓** (状态更新):
```sql
UPDATE futures_positions SET
    status = 'open',  -- building → open
    planned_close_time = '2026-01-26 10:30:00',  -- 当前时间 + 持仓时间
    updated_at = NOW()
WHERE id = 12345
```

### 分批建仓配置

**文件**: `app/services/smart_entry_executor.py`

**批次配置**: 30% / 30% / 40%

**建仓窗口**: 30分钟
- 0-5分钟: 建立价格基线 (滚动5分钟窗口采样)
- 5-30分钟: 动态入场执行

**第1批 (30%) - 首次入场**:

做多条件 (满足任一):
1. 极优价格: 评分 ≥80分 (价格P10以下)
2. 优秀价格 + 止跌信号: 评分 ≥60分 + 止跌 ≥50分
3. 突破基线最低价: 当前价 ≤ 基线最低价 * 0.999
4. 强上涨避免错过: 强上涨趋势 + 价格升至P75
5. 超时兜底: 12分钟 + 评分 ≥40分
6. 强制入场: 15分钟超时

**第2批 (30%) - 加仓** (距第1批至少3分钟):

做多条件:
1. 回调加仓: 价格回调至第1批价格 -0.3%
2. 价格仍低: 仍在P25分位数以下
3. 超时兜底: 距第1批10分钟
4. 强制建仓: 距信号20分钟

**第3批 (40%) - 完成建仓** (距第2批至少3分钟):

做多条件:
1. 深度回调: 价格回调至第1批价格 -0.5%
2. 突破新低: 低于所有批次最低价
3. 上涨确认: 价格涨至第2批价格 +0.3% (确认反转)
4. 超时兜底: 距第2批10分钟
5. 强制完成: 距信号25分钟

### 价格基线系统

**滚动5分钟窗口采样**:
- 采样频率: 每秒采样一次价格
- 5分钟 = 300个价格样本

```python
baseline = {
    'min_price': 86000.0,   # 最低价
    'max_price': 86100.0,   # 最高价
    'p10': 86005.0,         # 10%分位数
    'p25': 86015.0,         # 25%分位数
    'p50': 86050.0,         # 50%分位数 (中位数)
    'p75': 86080.0,         # 75%分位数
    'p90': 86095.0,         # 90%分位数
    'trend': {
        'direction': 'up',   # 趋势方向
        'strength': 0.6,     # 趋势强度
        'change_pct': 0.08   # 变化百分比
    }
}
```

### 实际案例对比

**场景: BTC底部反转做多**

| 方式 | 第1批价格 | 第2批价格 | 第3批价格 | 平均成本 | 收益 (涨到$87,000) |
|------|----------|----------|----------|---------|-------------------|
| 直接按信号价格 | $86,021 | $86,021 | $86,021 | $86,021 | +1.14% |
| 分批动态建仓 | $86,000 | $85,750 | $86,000 | $85,836 | +1.36% |
| **优势** | | | | **-$185** | **多赚0.22%** ✅ |

---

## 📊 完整信号流程示例

### 今晨BTC底部反转案例 (2026-01-26 04:30)

```
时间轴:

04:30 - 🎯 高级信号触发
        AdvancedSignalDetector
        检测到: BOTTOM_REVERSAL_LONG
        价格: $86,021.70
        评分: 78分 (STRONG)
        5M: 525点下影线 + 5.71x量能 (3次锤头线)
        15M: 2次锤头线
        1H: 横盘筑底
          ↓
04:30 - 💡 超级大脑决策
        SmartDecisionBrainEnhanced
        主流币: BTC ✅
        高级信号: BOTTOM_REVERSAL_LONG (78分)
        决策: 立即开仓
        方向: LONG
        决策评分: 80分
        止损: $85,500
        持仓时间: 6小时
          ↓
04:30 - 📊 启动分批建仓执行器
        SmartEntryExecutor
        初始化: 30%/30%/40%分批计划
        总保证金: $400
        杠杆: 5x
          ↓
04:35 - 📈 建立价格基线 (5分钟采样)
        基线: $86,000 - $86,100
        P25: $86,015
        趋势: 横盘震荡
          ↓
04:40 - ✅ 第1批建仓 (30%, $120)
        触发: 极优价格 (评分85)
        价格: $86,000
        数量: 0.0070 BTC
        原因: 价格跌至P10以下
          ↓
04:50 - ✅ 第2批建仓 (30%, $120)
        触发: 回调加仓
        价格: $85,750 (-0.29%)
        数量: 0.0070 BTC
        原因: 回调至第1批价格-0.3%
          ↓
04:55 - ✅ 第3批建仓 (40%, $160)
        触发: 上涨确认
        价格: $86,000 (+0.29%)
        数量: 0.0093 BTC
        原因: 价格涨至第2批+0.3%,确认反转
          ↓
04:55 - 🎉 建仓完成
        总数量: 0.0233 BTC
        平均成本: $85,836
        持仓ID: 12345
        止损: $85,500
          ↓
05:00 - 📈 价格上涨至 $87,000
        浮盈: ($87,000 - $85,836) × 0.0233
             = $27.14
        收益率: +1.36%
```

---

## 📈 系统能力对比

### 优化前 vs 优化后

| 能力 | 原系统 | 增强系统 | 改进 |
|------|--------|---------|------|
| **信号捕捉能力** | | | |
| 趋势延续信号 | ✅ EMA金叉/死叉 | ✅ EMA金叉/死叉 | 保持 |
| 反转信号 | ❌ 无法捕捉 | ✅ 底部反转做多 | +100% |
| 突然下跌信号 | ❌ 无法捕捉 | ✅ 上涨无力做空 | +100% |
| 多周期确认 | ⚠️ 单一周期 | ✅ 1H+15M+5M | 质量提升 |
| **风险控制** | | | |
| 主流币保护 | ⚠️ 可能被黑名单拦截 | ✅ 永不被拦截 | 风险降低 |
| 信号评分 | ⚠️ 简单评分 | ✅ 105分系统 | 精准度提升 |
| **开仓执行** | | | |
| 分批建仓 | ✅ 30%/30%/40% | ✅ 30%/30%/40% | 保持 |
| 价格优化 | ✅ 动态价格评估 | ✅ 动态价格评估 | 保持 |
| 响应速度 | 15分钟 (EMA周期) | 5分钟 (高级信号) | 快3倍 |
| **质量控制** | | | |
| 超时管理 | ✅ 动态超时 | ✅ 动态超时 | 保持 |
| 黑名单管理 | ✅ 3级制度 | ✅ 3级制度 | 保持 |
| 对冲成本 | ✅ 已优化 (100U) | ✅ 已优化 (100U) | 保持 |
| 止盈策略 | ✅ 动态止盈 | ✅ 动态止盈 | 保持 |

---

## 📝 部署指南

### 快速部署 (5分钟)

#### 步骤1: 备份原文件

```bash
cd d:\test2\crypto-analyzer

# 备份超级大脑
copy app\services\smart_decision_brain.py app\services\smart_decision_brain_backup.py
```

#### 步骤2: 替换为增强版

```bash
# 替换超级大脑
copy app\services\smart_decision_brain_enhanced.py app\services\smart_decision_brain.py
```

#### 步骤3: 运行测试

```bash
# 测试高级信号检测器
python test_advanced_signal_detector.py

# 测试超级大脑集成
python test_brain_integration.py
```

#### 步骤4: 启动系统

```bash
# 启动交易系统
python main.py
```

### 验证清单

部署前:
- [ ] 已备份 `smart_decision_brain.py`
- [ ] 配置文件正确 (数据库连接、监控币种等)
- [ ] 数据库表 `ema_signals` 存在
- [ ] 数据库表 `kline_data` 有足够的历史数据

部署后:
- [ ] 系统启动无错误
- [ ] 日志中能看到扫描信息
- [ ] 测试脚本运行正常
- [ ] 可以查询到 `signal_source='advanced_signal'` 的记录

### 回滚方案

如果出现问题:

```bash
# 回滚超级大脑
copy app\services\smart_decision_brain_backup.py app\services\smart_decision_brain.py

# 重启系统
python main.py
```

---

## 🎓 建议执行步骤

### 阶段1: 观察模式 (1-2天)

**配置**:
```python
config['trade_mode'] = 'observation'  # 只记录信号,不实际交易
config['enable_advanced_signals'] = True
```

**监控指标**:
- 每天产生多少个高级信号?
- 信号准确率如何?
- 是否有假信号?

### 阶段2: 小仓位测试 (3-5天)

**配置**:
```python
config['trade_mode'] = 'live'
config['position_size_multiplier'] = 0.2  # 标准仓位的20%
```

**监控指标**:
- 高级信号胜率
- 高级信号 vs 多维度分析,哪个更准?
- 平均收益率
- 最大回撤

### 阶段3: 逐步放大 (1-2周)

**配置**:
```python
# 逐步增加仓位
config['position_size_multiplier'] = 0.5  # 50%
# ... 观察几天
config['position_size_multiplier'] = 0.75  # 75%
# ... 观察几天
config['position_size_multiplier'] = 1.0  # 100%
```

---

## 📊 监控指标

### 核心指标

| 指标 | 当前值 | 目标值 | 监控频率 |
|-----|--------|--------|---------|
| **整体胜率** | 56.7% | 65%+ | 每日 |
| **盈亏比** | 1.60:1 | 2.0:1+ | 每日 |
| **日均盈利** | $31.64 | $100+ | 每日 |

### 高级信号指标 (新增)

| 指标 | 目标值 | 监控频率 |
|-----|--------|---------|
| 高级信号数量 | 2-5个/天 | 每日 |
| 高级信号胜率 | 70%+ | 每日 |
| STRONG信号胜率 | 80%+ | 每日 |
| 主流币捕捉率 | 90%+ | 每周 |

### 分项指标

| 指标 | 当前值 | 目标值 | 监控频率 |
|-----|--------|--------|---------|
| TIMEOUT_4H数量 | 47笔/天 | 20-25笔/天 | 每日 |
| TIMEOUT_4H胜率 | 51.1% | 60%+ | 每日 |
| hard_stop_loss数量 | 10笔/天 | 3-5笔/天 | 每日 |
| hard_stop_loss亏损 | -$411/天 | -$100/天 | 每日 |
| hedge对冲数量 | 80笔/周 | 40笔/周 | 每周 |
| hedge平均亏损 | -$15.69 | -$3.92 | 每周 |
| 止盈触发率 | <5% | 30-40% | 每日 |

---

## 📚 相关文档

### 核心文档

- **本文档**: `docs/超级大脑合约交易方案.md` - 完整方案总结
- `FINAL_SUMMARY.md` - 高级信号系统完整总结
- `INTEGRATE_TO_BRAIN.md` - 超级大脑集成指南
- `SIGNAL_TO_BATCH_ENTRY.md` - 信号到分批建仓流程

### 技术规范

- `SIGNAL_TYPES_SPECIFICATION.md` - 信号类型规范 (v1.1)
- `README_ADVANCED_SIGNALS.md` - 高级信号系统使用手册

### 快速指南

- `QUICK_DEPLOY.md` - 5分钟快速部署
- `INTEGRATION_COMPLETE.md` - 集成完成总结

---

## 📝 版本历史

### v2.0 (2026-01-26)

**重大更新**: 集成高级信号检测系统

**新增内容**:
- ✅ 高级信号检测器 (`AdvancedSignalDetector`)
- ✅ 上涨无力+突然下跌做空信号 (`WEAK_RALLY_SHORT`)
- ✅ 底部反转做多信号 (`BOTTOM_REVERSAL_LONG`)
- ✅ 增强版超级大脑 (`SmartDecisionBrainEnhanced`)
- ✅ 主流币优先检测高级信号
- ✅ 信号评分系统 (0-105分)
- ✅ 多周期共振确认 (1H + 15M + 5M)

**系统能力提升**:
- 捕捉反转信号: 从 ❌ 到 ✅
- 捕捉突然下跌: 从 ❌ 到 ✅
- 主流币保护: 永不被黑名单拦截
- 信号响应速度: 从15分钟到5分钟 (快3倍)

### v1.0 (2026-01-23)

**初始版本**: 质量优化方案

**优化内容**:
- ✅ 动态超时时间 + 分阶段超时策略
- ✅ 黑名单3级制度 (支持动态升降级)
- ✅ 降低对冲成本 (87.5%成本降低)
- ✅ 基于15M阳线/阴线的动态止盈

---

---

# 第三部分: 智能分批平仓系统 (2026-01-26)

## 📋 概述

参考智能分批建仓的成功经验，现在平仓也采用同样的策略：**在计划平仓前30分钟，通过滚动5分钟价格基线，分2批寻找最佳平仓价格**。

### 核心思路

| 阶段 | 窗口时间 | 批次 | 目标 | 价格基线 |
|------|---------|------|------|---------|
| **开仓** | 信号触发后30分钟 | 3批 (30%/30%/40%) | 寻找最低买入价 | 滚动5分钟窗口 |
| **平仓** | 计划平仓前30分钟 | 2批 (50%/50%) | 寻找最高卖出价 | 滚动5分钟窗口 |

**为什么平仓只分2批？**
- 平仓时间有限（计划平仓时间固定）
- 需要更快落袋为安
- 2批平衡了价格优化和执行确定性

---

## 🔄 完整平仓流程

```
持仓建立
   ↓
正常监控（止损/止盈保护）
   ↓
距离计划平仓时间还有30分钟
   ↓
🎯 进入智能分批平仓窗口
   ↓
启动价格基线采样器（滚动5分钟）
   ↓
等待5分钟建立基线
   ↓
========== 开始寻找最佳平仓价格 ==========
   ↓
第1批（50%）- 在价格好的时候先锁定利润
   ├─> 条件1: 极佳价格（评分 >= 95分）
   ├─> 条件2: 优秀价格 + 有盈利（评分 >= 85分）
   ├─> 条件3: 突破基线最高价/最低价
   ├─> 条件4: 高盈利 >= 2% + 价格在中位数
   ├─> 条件5: 趋势转向预警
   └─> 条件6: 时间兜底（20分钟）
   ↓
✅ 第1批平仓完成
   ↓
第2批（剩余50%）- 等待更优价格或超时
   ├─> 条件1: 价格比第1批更优（±0.2%）
   ├─> 条件2: 极佳价格（评分 >= 95分）
   ├─> 条件3: 突破新高/新低
   ├─> 条件4: 价格接近第1批 + 评分良好
   ├─> 条件5: 时间兜底（25分钟）
   └─> 条件6: 强制平仓（30分钟）
   ↓
✅ 第2批平仓完成
   ↓
🎉 智能分批平仓完成
```

---

## 📊 价格评分系统

### 做多平仓评分

**目标：在高位卖出**

```
评分 = 价格分位数评分(70分) + 盈利加分(30分) + 突破加分(15分)

价格分位数评分:
- 价格 >= P90: 70分 (顶部10%，极佳卖点)
- 价格 >= P75: 55分 (顶部25%，优秀卖点)
- 价格 >= P50: 35分 (中位数以上，良好卖点)
- 价格 >= P25: 20分 (一般卖点)
- 价格 <  P25: 5分  (底部区间，较差卖点)

盈利加分:
- 盈利 >= 2%: +30分
- 盈利 >= 1%: +20分
- 盈利 > 0:   +10分
- 亏损 >= 1%: -10分

突破加分:
- 突破基线最高价: +15分
```

**评分示例**：

| 场景 | 当前价 | 基线P90 | 盈利 | 评分 | 说明 |
|------|--------|---------|------|------|------|
| 场景1 | $87,500 | $87,450 | +1.7% | 70+20+15=105 | 极佳卖点！ |
| 场景2 | $87,300 | $87,450 | +1.5% | 55+20=75 | 优秀卖点 |
| 场景3 | $87,100 | $87,450 | +1.3% | 35+20=55 | 良好卖点 |
| 场景4 | $86,800 | $87,450 | +0.9% | 20+10=30 | 一般卖点 |

### 做空平仓评分

**目标：在低位买入**

镜像逻辑（在P10/P25/P50评分，跌破最低价加分）

---

## 🎬 实际案例演示

### 场景：BTC 做多持仓智能平仓

```
持仓信息:
- 方向: LONG
- 开仓价: $86,000
- 数量: 0.02 BTC
- 计划平仓时间: 10:00

==================== 时间轴 ====================

09:30 - 🎯 进入智能分批平仓窗口（距离计划平仓30分钟）
        启动价格基线采样器
        当前价: $87,200 (盈利 +1.40%)
          ↓
09:35 - 📊 价格基线建立完成
        5分钟采样范围: $86,800 - $87,500
        P10: $86,850
        P25: $87,000
        P50: $87,100
        P75: $87,300
        P90: $87,450
        趋势: 横盘震荡
          ↓
09:40 - 🔍 第1批平仓检查
        当前价: $87,420
        评分: 98分
          ├─ 价格分位数: 70分 (P90以上)
          ├─ 盈利加分: 20分 (+1.65%)
          └─ 突破加分: 无
        ✅ 触发: "极佳卖点(评分98): 顶部10%极佳卖点"

        ▶ 平仓50% (0.01 BTC @ $87,420)
          实现盈利: ($87,420 - $86,000) × 0.01 = $14.20
          ↓
09:45 - 🔍 第2批平仓检查
        当前价: $87,300
        评分: 88分
        判断: 价格比第1批低 (-0.14%)，继续等待
          ↓
09:50 - 🔍 第2批平仓检查
        当前价: $87,280
        评分: 85分
        判断: 价格比第1批低 (-0.16%)，继续等待
          ↓
09:55 - 🔍 第2批平仓检查
        当前价: $87,550
        评分: 100分
        判断: 价格比第1批高 (+0.15%)
        ✅ 触发: "更优卖点(比第1批高0.15%)"

        ▶ 平仓剩余50% (0.01 BTC @ $87,550)
          实现盈利: ($87,550 - $86,000) × 0.01 = $15.50
          ↓
10:00 - 🎉 智能分批平仓完成！

        总盈利: $14.20 + $15.50 = $29.70
        平均平仓价: ($87,420 + $87,550) / 2 = $87,485

==================== 对比分析 ====================

如果一次性平仓 @ $87,300:
  盈利: ($87,300 - $86,000) × 0.02 = $26.00

智能分批平仓:
  盈利: $29.70

优化收益: $29.70 - $26.00 = +$3.70 (+14.2%)
```

---

## 💡 关键优势

### 1. 参考成功经验

开仓分批策略已经验证有效，平仓采用同样思路：
- ✅ 滚动价格基线（实时更新）
- ✅ 分位数评分系统（P10/P25/P50/P75/P90）
- ✅ 多条件触发机制
- ✅ 超时保护机制

### 2. 优化平均平仓价

```
场景A: 单次平仓
  └─> 可能在价格中等时平仓

场景B: 分批平仓
  ├─> 第1批: 在价格高位平仓（锁定利润）
  └─> 第2批: 等待冲高或超时平仓
  └─> 平均平仓价更优！
```

### 3. 风险控制

- **第1批（50%）先锁定利润** → 避免全部错过最佳价格
- **第2批（50%）等待更优价格** → 优化收益
- **超时保护** → 确保在计划时间前完成

### 4. 趋势预警

```python
# 做多持仓检测到强下跌趋势
if baseline['trend']['direction'] == 'down' and baseline['trend']['strength'] > 0.6:
    if profit_pct >= 0.5:  # 有盈利就赶紧跑
        ✅ 触发快速止盈
```

---

## 🚨 兜底保护

即使在智能分批平仓窗口，仍然保留兜底保护：

```python
# 优先级最高：止损/止盈（任何时候都检查）
if 触发止损 or 触发止盈:
    ✅ 立即全部平仓

# 优先级2: 超高盈利
if profit_pct >= 5.0:
    ✅ 立即全部平仓

# 优先级3: 巨额亏损
if profit_pct <= -3.0:
    ✅ 立即全部平仓

# 优先级4: 智能分批平仓（正常流程）
if 进入30分钟平仓窗口:
    ✅ 分2批寻找最佳价格
```

---

## 📈 预期效果

### 收益优化

假设100笔交易：
- 单次平仓平均优化：0.1% - 0.3%
- 累积优化：**10% - 30% 额外收益**

### 胜率提升

- 第1批先锁定利润 → 避免价格回落全部错过
- 第2批等待更优价格 → 抓住冲高/回调机会
- 超时保护 → 确保不会无限等待

---

## ⚙️ 核心代码实现详解

### PriceSampler 平仓价格评分

**文件**: `app/services/price_sampler.py` (lines 400-536)

新增平仓价格评分方法：

```python
def is_good_long_exit_price(self, current_price: Decimal, entry_price: float) -> Dict:
    """
    做多平仓价格评分
    目标: 在高位卖出

    Returns:
        {
            'score': 0-115,  # 价格(70) + 盈利(30) + 突破(15)
            'reason': str,
            'profit_pct': float,
            'details': {...}
        }
    """
    baseline = self.get_current_baseline()
    price_float = float(current_price)
    profit_pct = (price_float - entry_price) / entry_price * 100

    score = 0
    reason_parts = []

    # 1. 价格分位数评分（0-70分）
    if price_float >= baseline['p90']:
        score += 70
        reason_parts.append('顶部10%极佳卖点')
    elif price_float >= baseline['p75']:
        score += 55
        reason_parts.append('顶部25%优秀卖点')
    elif price_float >= baseline['p50']:
        score += 35
        reason_parts.append('中位数以上良好卖点')
    elif price_float >= baseline['p25']:
        score += 20
        reason_parts.append('一般卖点')
    else:
        score += 5
        reason_parts.append('底部区间较差卖点')

    # 2. 盈利加分（0-30分）
    if profit_pct >= 2.0:
        score += 30
        reason_parts.append(f'盈利{profit_pct:.2f}%')
    elif profit_pct >= 1.0:
        score += 20
        reason_parts.append(f'盈利{profit_pct:.2f}%')
    elif profit_pct > 0:
        score += 10
        reason_parts.append(f'微利{profit_pct:.2f}%')
    elif profit_pct <= -1.0:
        score -= 10
        reason_parts.append(f'亏损{profit_pct:.2f}%')

    # 3. 突破加分（0-15分）
    if price_float >= baseline['max_price']:
        score += 15
        reason_parts.append('突破基线最高价')

    total_score = min(score, 115)
    reason = ' + '.join(reason_parts)

    return {
        'score': total_score,
        'reason': reason,
        'profit_pct': profit_pct,
        'details': {
            'price_score': score - (30 if profit_pct >= 2 else 20 if profit_pct >= 1 else 10 if profit_pct > 0 else 0),
            'profit_bonus': 30 if profit_pct >= 2 else 20 if profit_pct >= 1 else 10 if profit_pct > 0 else 0,
            'breakout_bonus': 15 if price_float >= baseline['max_price'] else 0
        }
    }

def is_good_short_exit_price(self, current_price: Decimal, entry_price: float) -> Dict:
    """
    做空平仓价格评分
    目标: 在低位买入

    镜像逻辑:
    - 价格在P10以下: +70分
    - 跌破基线最低价: +15分
    - 盈利 >= 2%: +30分
    """
    # 镜像实现...
```

---

### SmartExitOptimizer 智能分批平仓详解

**文件**: `app/services/smart_exit_optimizer.py` (lines 42-801)

#### 核心数据结构

```python
class SmartExitOptimizer:
    def __init__(self):
        # 监控中的持仓 (position_id -> asyncio.Task)
        self.monitoring_tasks: Dict[int, asyncio.Task] = {}

        # 平仓计划 (position_id -> exit_plan)
        self.exit_plans: Dict[int, Dict] = {}

        # 数据库连接池 (20个连接用于并发监控)
        self.db_pool = await aiomysql.create_pool(
            minsize=10, maxsize=20, ...
        )

# 平仓计划数据结构
exit_plan = {
    'batches': [
        {
            'ratio': 0.5,  # 第1批50%
            'filled': False,
            'price': None,
            'time': None,
            'reason': None
        },
        {
            'ratio': 0.5,  # 第2批50%
            'filled': False,
            'price': None,
            'time': None,
            'reason': None
        }
    ],
    'sampler': PriceSampler(...),  # 价格采样器
    'start_time': datetime.now(),
    'total_quantity': 0.02,  # 原始总数量
    'entry_time': datetime(...),
    'planned_close_time': datetime(...)
}
```

#### 主监控循环

```python
async def _monitor_position(self, position_id: int, position: Dict):
    """
    监控单个持仓 (独立协程)
    每秒检查一次，持续到平仓

    优先级:
    1. 止损/止盈保护 (任何时候)
    2. 极端情况处理 (超高盈利/巨额亏损)
    3. 智能分批平仓 (计划平仓前30分钟)
    """
    try:
        while True:
            # 获取当前价格
            current_price = await self._get_current_price(symbol)

            # 计算盈亏
            profit_info = self._calculate_profit(position, current_price)

            # 【优先级1】检查极端情况 (任何时候都检查)
            extreme_result = await self._check_extreme_conditions(
                position_id, position, current_price, profit_info
            )
            if extreme_result:
                logger.info(f"触发极端条件平仓: {extreme_result['reason']}")
                break

            # 【优先级2】计算距离计划平仓时间
            time_until_close = (
                position['planned_close_time'] - datetime.now()
            ).total_seconds() / 60  # 转为分钟

            # 【优先级3】进入智能分批平仓窗口 (前30分钟)
            if time_until_close <= 30:
                batch_exit_done = await self._smart_batch_exit(
                    position_id, position, current_price, profit_info
                )
                if batch_exit_done:
                    logger.info(f"✅ 智能分批平仓完成")
                    break

            # 每秒检查一次
            await asyncio.sleep(1)

    except Exception as e:
        logger.error(f"持仓监控异常: {e}")
    finally:
        # 清理资源
        if position_id in self.exit_plans:
            sampler = self.exit_plans[position_id]['sampler']
            sampler.stop_sampling()
            del self.exit_plans[position_id]
```

#### 智能分批平仓主控制

```python
async def _smart_batch_exit(
    self,
    position_id: int,
    position: Dict,
    current_price: Decimal,
    profit_info: Dict
) -> bool:
    """
    智能分批平仓逻辑 (计划平仓前30分钟)

    Returns:
        True: 全部平仓完成
        False: 仍在进行中
    """
    symbol = position['symbol']
    direction = position['position_side']

    # 初始化平仓计划（第一次进入监控窗口）
    if position_id not in self.exit_plans:
        logger.info(f"🎯 {symbol} 进入智能分批平仓窗口")

        # 启动价格基线采样器 (滚动5分钟)
        sampler = PriceSampler(
            symbol,
            self.price_service,
            window_seconds=300  # 5分钟
        )
        sampling_task = asyncio.create_task(
            sampler.start_background_sampling()
        )

        # 创建平仓计划
        exit_plan = {
            'batches': [
                {'ratio': 0.5, 'filled': False, 'price': None, 'time': None, 'reason': None},
                {'ratio': 0.5, 'filled': False, 'price': None, 'time': None, 'reason': None}
            ],
            'sampler': sampler,
            'sampling_task': sampling_task,
            'start_time': datetime.now(),
            'total_quantity': float(position['quantity']),
            'entry_time': position['entry_signal_time'],
            'planned_close_time': position['planned_close_time']
        }
        self.exit_plans[position_id] = exit_plan

        # 等待基线建立 (最多5分钟)
        logger.info(f"📊 等待5分钟建立价格基线...")
        await self._wait_for_baseline(sampler, timeout=300)

    exit_plan = self.exit_plans[position_id]
    sampler = exit_plan['sampler']
    baseline = sampler.get_current_baseline()

    # 第1批平仓判断 (50%)
    if not exit_plan['batches'][0]['filled']:
        should_exit, reason = await self._should_exit_batch1(
            position, current_price, baseline, profit_info, exit_plan
        )

        if should_exit:
            await self._execute_partial_close(
                position_id, position, current_price, 0.5, reason
            )
            exit_plan['batches'][0]['filled'] = True
            exit_plan['batches'][0]['price'] = float(current_price)
            exit_plan['batches'][0]['time'] = datetime.now()
            exit_plan['batches'][0]['reason'] = reason

            logger.info(f"✅ 第1批平仓完成 (50% @ ${current_price:.2f})")
            return False

    # 第2批平仓判断 (剩余50%)
    elif not exit_plan['batches'][1]['filled']:
        should_exit, reason = await self._should_exit_batch2(
            position, current_price, baseline, profit_info, exit_plan
        )

        if should_exit:
            await self._execute_partial_close(
                position_id, position, current_price, 1.0, reason
            )
            exit_plan['batches'][1]['filled'] = True
            exit_plan['batches'][1]['price'] = float(current_price)
            exit_plan['batches'][1]['time'] = datetime.now()
            exit_plan['batches'][1]['reason'] = reason

            logger.info(f"✅ 第2批平仓完成 (50% @ ${current_price:.2f})")

            # 计算平均平仓价
            avg_exit_price = (
                exit_plan['batches'][0]['price'] + exit_plan['batches'][1]['price']
            ) / 2
            logger.info(f"🎉 智能分批平仓完成! 平均平仓价: ${avg_exit_price:.2f}")

            return True  # 全部完成

    return False
```

#### 第1批平仓条件判断

```python
async def _should_exit_batch1(
    self,
    position: Dict,
    current_price: Decimal,
    baseline: Optional[Dict],
    profit_info: Dict,
    exit_plan: Dict
) -> Tuple[bool, str]:
    """
    判断是否应该平仓第1批 (50%)

    目标: 在价格好的时候先锁定利润

    Returns:
        (是否平仓, 原因)
    """
    if not baseline:
        return False, ""

    direction = position['position_side']
    entry_price = float(position['avg_entry_price'])
    profit_pct = profit_info['pnl_pct']

    elapsed_minutes = (
        datetime.now() - exit_plan['start_time']
    ).total_seconds() / 60

    if direction == 'LONG':
        # 做多平仓: 评估当前价格 (目标高位卖出)
        evaluation = exit_plan['sampler'].is_good_long_exit_price(
            current_price, entry_price
        )

        # 条件1: 极佳价格 (评分 >= 95分)
        if evaluation['score'] >= 95:
            return True, f"极佳卖点(评分{evaluation['score']}): {evaluation['reason']}"

        # 条件2: 优秀价格 + 有盈利 (评分 >= 85分 + 盈利 > 0)
        if evaluation['score'] >= 85 and profit_pct > 0:
            return True, f"优秀卖点(评分{evaluation['score']}) + 盈利{profit_pct:.2f}%"

        # 条件3: 突破基线最高价
        if float(current_price) >= baseline['max_price']:
            return True, f"突破基线最高价({baseline['max_price']:.6f})"

        # 条件4: 高盈利 >= 2% + 价格在中位数以上
        if profit_pct >= 2.0 and float(current_price) >= baseline['p50']:
            return True, f"高盈利{profit_pct:.2f}% + 价格在中位数以上"

        # 条件5: 强下跌趋势预警 (有盈利就赶紧跑)
        if baseline['trend']['direction'] == 'down' and baseline['trend']['strength'] > 0.6:
            if profit_pct >= 0.5:
                return True, f"强下跌趋势预警({baseline['trend']['change_pct']:.2f}%) + 盈利{profit_pct:.2f}%"

        # 条件6: 时间兜底 (20分钟 + 评分合理)
        if elapsed_minutes >= 20 and evaluation['score'] >= 60:
            return True, f"时间兜底(已{elapsed_minutes:.1f}分钟) + 评分{evaluation['score']}"

    else:  # SHORT
        # 做空平仓: 镜像逻辑 (目标低位买入)
        evaluation = exit_plan['sampler'].is_good_short_exit_price(
            current_price, entry_price
        )

        # 条件1-6: 镜像逻辑
        # ...

    return False, ""
```

#### 第2批平仓条件判断

```python
async def _should_exit_batch2(
    self,
    position: Dict,
    current_price: Decimal,
    baseline: Optional[Dict],
    profit_info: Dict,
    exit_plan: Dict
) -> Tuple[bool, str]:
    """
    判断是否应该平仓第2批 (剩余50%)

    目标: 等待更优价格或超时平仓

    Returns:
        (是否平仓, 原因)
    """
    direction = position['position_side']
    entry_price = float(position['avg_entry_price'])
    profit_pct = profit_info['pnl_pct']

    batch1_price = exit_plan['batches'][0]['price']
    batch1_time = exit_plan['batches'][0]['time']

    elapsed_minutes = (
        datetime.now() - exit_plan['start_time']
    ).total_seconds() / 60

    time_since_batch1 = (
        datetime.now() - batch1_time
    ).total_seconds() / 60

    current_price_float = float(current_price)

    if direction == 'LONG':
        # 做多平仓

        # 条件1: 价格比第1批更优 (+0.2%)
        if current_price_float >= batch1_price * 1.002:
            improvement_pct = (current_price_float / batch1_price - 1) * 100
            return True, f"更优卖点(比第1批高{improvement_pct:.2f}%)"

        # 条件2: 极佳价格 (评分 >= 95分)
        evaluation = exit_plan['sampler'].is_good_long_exit_price(
            current_price, entry_price
        )
        if evaluation['score'] >= 95:
            return True, f"极佳卖点(评分{evaluation['score']})"

        # 条件3: 突破新高
        if baseline and current_price_float >= baseline['max_price']:
            return True, f"突破新高({baseline['max_price']:.6f})"

        # 条件4: 价格接近第1批 + 评分良好
        if abs(current_price_float - batch1_price) / batch1_price <= 0.002:  # ±0.2%
            if evaluation['score'] >= 70:
                return True, f"价格接近第1批 + 良好评分({evaluation['score']})"

        # 条件5: 时间兜底 (25分钟)
        if elapsed_minutes >= 25:
            return True, f"时间兜底(已{elapsed_minutes:.1f}分钟)"

        # 条件6: 强制平仓 (30分钟到期)
        if elapsed_minutes >= 30:
            return True, f"强制平仓(已{elapsed_minutes:.1f}分钟)"

    else:  # SHORT
        # 做空平仓: 镜像逻辑
        # ...

    return False, ""
```

#### 部分平仓执行

```python
async def _execute_partial_close(
    self,
    position_id: int,
    position: Dict,
    current_price: Decimal,
    close_ratio: float,
    reason: str
):
    """
    执行部分平仓

    Args:
        close_ratio: 0.5 = 平仓50%, 1.0 = 平仓剩余100%
    """
    symbol = position['symbol']
    direction = position['position_side']

    # 计算平仓数量
    remaining_quantity = float(position['quantity'])

    # 如果是第2批，需要考虑第1批已平仓的数量
    if position_id in self.exit_plans:
        exit_plan = self.exit_plans[position_id]
        if exit_plan['batches'][0]['filled']:
            # 第1批已平仓50%，剩余50%
            remaining_quantity = exit_plan['total_quantity'] * 0.5

    close_quantity = remaining_quantity * close_ratio

    logger.info(
        f"▶ 执行部分平仓: {symbol} {direction} | "
        f"数量: {close_quantity:.4f} ({close_ratio*100:.0f}%) | "
        f"价格: ${current_price:.2f} | "
        f"原因: {reason}"
    )

    # 调用实盘引擎平仓 (模拟盘不调用交易所API)
    close_result = await self.live_engine.close_position(
        symbol=symbol,
        side='SELL' if direction == 'LONG' else 'BUY',
        quantity=close_quantity,
        price=float(current_price)
    )

    # 更新数据库持仓记录
    await self._update_position_partial_close(
        position_id, close_quantity, current_price, reason, close_ratio
    )

    logger.info(f"✅ 部分平仓完成: {close_quantity:.4f} @ ${current_price:.2f}")
```

#### 数据库更新 (部分平仓)

```python
async def _update_position_partial_close(
    self,
    position_id: int,
    close_quantity: float,
    close_price: Decimal,
    reason: str,
    close_ratio: float
):
    """
    更新持仓记录 (部分平仓)

    第1批平仓: quantity保持不变，添加 partial_close_info
    第2批平仓: quantity=0, status='closed', 更新realized_pnl
    """
    async with self.db_pool.acquire() as conn:
        async with conn.cursor() as cursor:
            if close_ratio < 1.0:
                # 第1批平仓 (50%)
                await cursor.execute("""
                    UPDATE futures_positions
                    SET partial_close_info = JSON_SET(
                        COALESCE(partial_close_info, '{}'),
                        '$.batch1_quantity', %s,
                        '$.batch1_price', %s,
                        '$.batch1_time', %s,
                        '$.batch1_reason', %s
                    ),
                    updated_at = NOW()
                    WHERE id = %s
                """, (close_quantity, float(close_price), datetime.now(), reason, position_id))

            else:
                # 第2批平仓 (剩余50%)
                # 计算总盈亏
                position = await self._get_position(position_id)
                entry_price = position['avg_entry_price']
                direction = position['position_side']

                # 获取第1批平仓信息
                partial_info = json.loads(position.get('partial_close_info', '{}'))
                batch1_quantity = partial_info.get('batch1_quantity', 0)
                batch1_price = partial_info.get('batch1_price', 0)

                # 计算总盈亏
                if direction == 'LONG':
                    pnl1 = (batch1_price - entry_price) * batch1_quantity
                    pnl2 = (float(close_price) - entry_price) * close_quantity
                else:
                    pnl1 = (entry_price - batch1_price) * batch1_quantity
                    pnl2 = (entry_price - float(close_price)) * close_quantity

                total_pnl = pnl1 + pnl2
                total_pnl_pct = (total_pnl / (entry_price * (batch1_quantity + close_quantity))) * 100

                # 更新持仓状态为已平仓
                await cursor.execute("""
                    UPDATE futures_positions
                    SET quantity = 0,
                        exit_price = %s,
                        close_time = NOW(),
                        realized_pnl = %s,
                        realized_pnl_pct = %s,
                        exit_reason = %s,
                        status = 'closed',
                        partial_close_info = JSON_SET(
                            partial_close_info,
                            '$.batch2_quantity', %s,
                            '$.batch2_price', %s,
                            '$.batch2_time', %s,
                            '$.batch2_reason', %s,
                            '$.avg_exit_price', %s
                        ),
                        updated_at = NOW()
                    WHERE id = %s
                """, (
                    float(close_price), total_pnl, total_pnl_pct, reason,
                    close_quantity, float(close_price), datetime.now(), reason,
                    (batch1_price + float(close_price)) / 2,
                    position_id
                ))

            await conn.commit()
```

---

# 附录: 完整文档索引

## 核心组件

### 信号检测
- `app/services/advanced_signal_detector.py` - 高级信号检测器
- `app/services/smart_decision_brain_enhanced.py` - 增强版超级大脑

### 分批执行
- `app/services/smart_entry_executor.py` - 智能分批建仓执行器
- `app/services/smart_exit_optimizer.py` - 智能分批平仓优化器
- `app/services/price_sampler.py` - 价格采样器（滚动5分钟窗口）

### 监控增强
- `app/trading/ema_signal_monitor_enhanced.py` - EMA信号监控增强版

---

## 系统完整流程

```
高级信号检测
    ↓
超级大脑决策
    ↓
分批建仓执行 (30分钟窗口，3批: 30%/30%/40%)
    ├─> 第1批: 极优价格入场
    ├─> 第2批: 回调/反弹加仓
    └─> 第3批: 趋势确认或超时完成
    ↓
持仓监控 (止损/止盈保护)
    ↓
分批平仓执行 (计划平仓前30分钟，2批: 50%/50%)
    ├─> 第1批: 价格好时先锁定利润
    └─> 第2批: 等待更优价格或超时平仓
```

---

## 📝 版本历史

### v2.1 (2026-01-26)

**新增功能**: 智能分批平仓系统

**优化内容**:
- ✅ 智能分批平仓（2批: 50%/50%）
- ✅ 平仓价格评分系统（0-100分）
- ✅ 滚动5分钟价格基线
- ✅ 趋势转向预警
- ✅ 超时保护机制

**预期效果**:
- 平均平仓价优化: 0.1% - 0.3%
- 累积收益提升: 10% - 30%

### v2.0 (2026-01-26)

**重大更新**: 集成高级信号检测系统

**新增内容**:
- ✅ 高级信号检测器 (`AdvancedSignalDetector`)
- ✅ 上涨无力+突然下跌做空信号 (`WEAK_RALLY_SHORT`)
- ✅ 底部反转做多信号 (`BOTTOM_REVERSAL_LONG`)
- ✅ 增强版超级大脑 (`SmartDecisionBrainEnhanced`)
- ✅ 主流币优先检测高级信号
- ✅ 信号评分系统 (0-105分)
- ✅ 多周期共振确认 (1H + 15M + 5M)
- ✅ 智能分批建仓 (30分钟窗口，3批)

**系统能力提升**:
- 捕捉反转信号: 从 ❌ 到 ✅
- 捕捉突然下跌: 从 ❌ 到 ✅
- 主流币保护: 永不被黑名单拦截
- 信号响应速度: 从15分钟到5分钟 (快3倍)
- 开仓价格优化: 通过分批建仓降低0.2%-0.5%成本

### v1.0 (2026-01-23)

**初始版本**: 质量优化方案

**优化内容**:
- ✅ 动态超时时间 + 分阶段超时策略
- ✅ 黑名单3级制度 (支持动态升降级)
- ✅ 降低对冲成本 (87.5%成本降低)
- ✅ 基于15M阳线/阴线的动态止盈

---

# 附录A: 系统性能监控

## 📊 核心监控指标

### 1. 信号质量指标

| 指标名称 | 计算方式 | 目标值 | 监控频率 |
|---------|---------|--------|---------|
| 高级信号数量 | COUNT(signal_source='advanced_signal') | 2-5个/天 | 每日 |
| 高级信号胜率 | 盈利信号数 / 总信号数 | 70%+ | 每日 |
| STRONG信号胜率 | STRONG信号盈利数 / STRONG信号总数 | 80%+ | 每日 |
| 多维度分析胜率 | 盈利数 / 总数 (signal_source='analysis') | 60%+ | 每日 |
| 信号响应时间 | 信号触发到建仓完成的时间 | <15分钟 | 每笔 |

### 2. 建仓执行指标

| 指标名称 | 计算方式 | 目标值 | 监控频率 |
|---------|---------|--------|---------|
| 平均建仓时长 | AVG(建仓完成时间 - 信号时间) | 10-20分钟 | 每日 |
| 第1批建仓速度 | 第1批建仓时间 - 信号时间 | 5-10分钟 | 每笔 |
| 建仓价格优化 | (信号价 - 平均建仓价) / 信号价 | 0.2-0.5% | 每笔 |
| 建仓完成率 | 3批全部完成数 / 总信号数 | 95%+ | 每日 |
| 超时建仓率 | 强制建仓数 / 总建仓数 | <10% | 每日 |

### 3. 平仓执行指标

| 指标名称 | 计算方式 | 目标值 | 监控频率 |
|---------|---------|--------|---------|
| 智能平仓使用率 | 分批平仓数 / 总平仓数 | 80%+ | 每日 |
| 平仓价格优化 | (平均平仓价 - 直接平仓价) / 直接平仓价 | 0.1-0.3% | 每笔 |
| 第1批平仓时机 | 第1批平仓时间 - 窗口开始时间 | 5-15分钟 | 每笔 |
| 第2批等待时间 | 第2批时间 - 第1批时间 | 5-10分钟 | 每笔 |
| 平仓超时率 | 强制平仓数 / 总平仓数 | <5% | 每日 |

### 4. 整体收益指标

| 指标名称 | 计算方式 | 目标值 | 监控频率 |
|---------|---------|--------|---------|
| 整体胜率 | 盈利单数 / 总单数 | 65%+ | 每日 |
| 盈亏比 | AVG(盈利单盈利) / AVG(亏损单亏损) | 2.0+ | 每日 |
| 日均盈利 | SUM(realized_pnl) / 天数 | $100+ | 每日 |
| 最大回撤 | MAX(累积盈亏峰值 - 当前盈亏) | <20% | 每周 |
| 夏普比率 | (平均收益率 - 无风险利率) / 收益率标准差 | >1.5 | 每月 |

---

## 🔍 SQL监控查询

### 查询1: 高级信号表现统计

```sql
-- 高级信号胜率和平均收益
SELECT
    signal_type,
    COUNT(*) as total_trades,
    SUM(CASE WHEN realized_pnl > 0 THEN 1 ELSE 0 END) as winning_trades,
    ROUND(SUM(CASE WHEN realized_pnl > 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as win_rate,
    ROUND(AVG(realized_pnl), 2) as avg_pnl,
    ROUND(AVG(realized_pnl_pct), 2) as avg_pnl_pct,
    ROUND(SUM(realized_pnl), 2) as total_pnl
FROM futures_positions
WHERE entry_signal_type IN ('BOTTOM_REVERSAL_LONG', 'WEAK_RALLY_SHORT')
AND status = 'closed'
AND DATE(close_time) >= DATE_SUB(CURDATE(), INTERVAL 7 DAY)
GROUP BY signal_type
ORDER BY total_trades DESC;
```

### 查询2: 分批建仓效果分析

```sql
-- 建仓价格优化效果
SELECT
    symbol,
    entry_signal_time,
    JSON_EXTRACT(batch_filled, '$.batches[0].price') as batch1_price,
    JSON_EXTRACT(batch_filled, '$.batches[1].price') as batch2_price,
    JSON_EXTRACT(batch_filled, '$.batches[2].price') as batch3_price,
    avg_entry_price,
    -- 如果直接按第1批价格开仓，成本差异
    ROUND(
        (JSON_EXTRACT(batch_filled, '$.batches[0].price') - avg_entry_price) * 100.0
        / JSON_EXTRACT(batch_filled, '$.batches[0].price'), 4
    ) as cost_improvement_pct,
    realized_pnl,
    realized_pnl_pct
FROM futures_positions
WHERE status = 'closed'
AND batch_filled IS NOT NULL
AND DATE(close_time) >= DATE_SUB(CURDATE(), INTERVAL 7 DAY)
ORDER BY entry_signal_time DESC
LIMIT 20;
```

### 查询3: 分批平仓效果分析

```sql
-- 平仓价格优化效果
SELECT
    symbol,
    position_side,
    avg_entry_price,
    JSON_EXTRACT(partial_close_info, '$.batch1_price') as batch1_exit_price,
    JSON_EXTRACT(partial_close_info, '$.batch2_price') as batch2_exit_price,
    JSON_EXTRACT(partial_close_info, '$.avg_exit_price') as avg_exit_price,
    exit_price as final_exit_price,
    -- 计算如果直接平仓vs分批平仓的差异
    ROUND(
        (JSON_EXTRACT(partial_close_info, '$.avg_exit_price') - batch1_exit_price) * 100.0
        / batch1_exit_price, 4
    ) as exit_improvement_pct,
    realized_pnl,
    realized_pnl_pct,
    exit_reason
FROM futures_positions
WHERE status = 'closed'
AND partial_close_info IS NOT NULL
AND DATE(close_time) >= DATE_SUB(CURDATE(), INTERVAL 7 DAY)
ORDER BY close_time DESC
LIMIT 20;
```

### 查询4: 主流币vs白名单表现对比

```sql
-- 主流币vs白名单表现
SELECT
    CASE
        WHEN symbol IN ('BTC/USDT', 'ETH/USDT', 'SOL/USDT', 'BNB/USDT') THEN '主流币'
        ELSE '白名单'
    END as coin_type,
    COUNT(*) as total_trades,
    SUM(CASE WHEN realized_pnl > 0 THEN 1 ELSE 0 END) as winning_trades,
    ROUND(SUM(CASE WHEN realized_pnl > 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as win_rate,
    ROUND(AVG(realized_pnl), 2) as avg_pnl,
    ROUND(SUM(realized_pnl), 2) as total_pnl,
    COUNT(DISTINCT symbol) as unique_symbols
FROM futures_positions
WHERE status = 'closed'
AND DATE(close_time) >= DATE_SUB(CURDATE(), INTERVAL 7 DAY)
GROUP BY coin_type
ORDER BY total_pnl DESC;
```

### 查询5: 每日性能总结

```sql
-- 每日交易统计
SELECT
    DATE(close_time) as trade_date,
    COUNT(*) as total_trades,
    SUM(CASE WHEN realized_pnl > 0 THEN 1 ELSE 0 END) as winning_trades,
    ROUND(SUM(CASE WHEN realized_pnl > 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as win_rate,
    ROUND(SUM(realized_pnl), 2) as daily_pnl,
    ROUND(AVG(CASE WHEN realized_pnl > 0 THEN realized_pnl END), 2) as avg_win,
    ROUND(AVG(CASE WHEN realized_pnl < 0 THEN realized_pnl END), 2) as avg_loss,
    ROUND(
        AVG(CASE WHEN realized_pnl > 0 THEN realized_pnl END) /
        ABS(AVG(CASE WHEN realized_pnl < 0 THEN realized_pnl END)), 2
    ) as profit_loss_ratio,
    -- 高级信号统计
    SUM(CASE WHEN entry_signal_type IN ('BOTTOM_REVERSAL_LONG', 'WEAK_RALLY_SHORT') THEN 1 ELSE 0 END) as advanced_signals,
    -- 分批建仓统计
    SUM(CASE WHEN batch_filled IS NOT NULL THEN 1 ELSE 0 END) as batch_entry_trades,
    -- 分批平仓统计
    SUM(CASE WHEN partial_close_info IS NOT NULL THEN 1 ELSE 0 END) as batch_exit_trades
FROM futures_positions
WHERE status = 'closed'
AND DATE(close_time) >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
GROUP BY DATE(close_time)
ORDER BY trade_date DESC;
```

---

## 🚨 异常监控告警

### 告警规则配置

```python
# 告警规则
ALERT_RULES = {
    # 胜率告警
    'win_rate_low': {
        'metric': '整体胜率',
        'threshold': 50,  # 低于50%
        'window': '24h',
        'action': 'EMAIL + SMS'
    },

    # 连续亏损告警
    'consecutive_losses': {
        'metric': '连续亏损单数',
        'threshold': 5,  # 连续5单
        'window': 'realtime',
        'action': 'EMAIL + SMS + 暂停交易'
    },

    # 日亏损告警
    'daily_loss_limit': {
        'metric': '日亏损',
        'threshold': -200,  # 亏损超过$200
        'window': '24h',
        'action': 'EMAIL + SMS + 暂停交易'
    },

    # 高级信号失效告警
    'advanced_signal_fail': {
        'metric': '高级信号胜率',
        'threshold': 50,  # 低于50%
        'window': '7d',
        'action': 'EMAIL + 禁用高级信号'
    },

    # 系统异常告警
    'system_error': {
        'metric': '系统错误率',
        'threshold': 5,  # 每小时>5次错误
        'window': '1h',
        'action': 'EMAIL + SMS'
    }
}
```

### 实时监控脚本

```python
# monitor_system.py
import asyncio
from datetime import datetime, timedelta
from loguru import logger

class SystemMonitor:
    """系统实时监控"""

    async def check_win_rate(self):
        """检查胜率"""
        query = """
            SELECT
                COUNT(*) as total,
                SUM(CASE WHEN realized_pnl > 0 THEN 1 ELSE 0 END) as wins
            FROM futures_positions
            WHERE status = 'closed'
            AND close_time >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
        """
        result = await self.db.fetch_one(query)

        if result['total'] > 10:  # 至少10单
            win_rate = result['wins'] * 100.0 / result['total']
            if win_rate < 50:
                await self.alert('胜率过低', f'24h胜率: {win_rate:.2f}%', level='HIGH')

    async def check_consecutive_losses(self):
        """检查连续亏损"""
        query = """
            SELECT realized_pnl
            FROM futures_positions
            WHERE status = 'closed'
            ORDER BY close_time DESC
            LIMIT 10
        """
        results = await self.db.fetch_all(query)

        consecutive = 0
        for r in results:
            if r['realized_pnl'] < 0:
                consecutive += 1
            else:
                break

        if consecutive >= 5:
            await self.alert('连续亏损', f'连续{consecutive}单亏损', level='CRITICAL')
            await self.pause_trading()

    async def monitor_loop(self):
        """主监控循环"""
        while True:
            try:
                await self.check_win_rate()
                await self.check_consecutive_losses()
                await self.check_daily_loss()
                await self.check_advanced_signals()
                await self.check_system_health()

                await asyncio.sleep(60)  # 每分钟检查一次

            except Exception as e:
                logger.error(f"监控异常: {e}")
                await asyncio.sleep(10)
```

---

# 附录B: 常见问题排查

## Q1: 高级信号检测不到交易机会

**可能原因**:
1. 数据库K线数据不足
2. 主流币都在黑名单中
3. 信号评分阈值过高

**排查步骤**:
```sql
-- 检查K线数据完整性
SELECT
    symbol,
    timeframe,
    COUNT(*) as kline_count,
    MAX(timestamp) as latest_time
FROM kline_data
WHERE symbol IN ('BTC/USDT', 'ETH/USDT', 'SOL/USDT', 'BNB/USDT')
AND exchange = 'binance_futures'
GROUP BY symbol, timeframe;

-- 检查黑名单配置
SELECT * FROM trading_blacklist WHERE symbol IN ('BTC/USDT', 'ETH/USDT', 'SOL/USDT', 'BNB/USDT');
```

**解决方案**:
- 确保最近30天K线数据完整
- 主流币不应在黑名单中
- 检查`enable_advanced_signals`配置为True

---

## Q2: 分批建仓频繁超时

**可能原因**:
1. 价格采样器启动失败
2. WebSocket连接断开
3. 入场条件过于严格

**排查步骤**:
```python
# 查看日志
tail -f logs/smart_trader.log | grep "超时强制建仓"

# 检查价格采样器状态
# 日志中应该有: "✅ 初始基线: 范围 ... 趋势 ..."
```

**解决方案**:
- 检查WebSocket连接状态
- 降低第1批入场评分要求 (80→70)
- 缩短超时时间 (15→12分钟)

---

## Q3: 分批平仓总是强制平仓

**可能原因**:
1. 平仓评分阈值过高
2. 价格波动太小
3. 监控窗口时间不够

**排查步骤**:
```sql
-- 查看最近平仓记录
SELECT
    symbol,
    JSON_EXTRACT(partial_close_info, '$.batch1_reason') as batch1_reason,
    JSON_EXTRACT(partial_close_info, '$.batch2_reason') as batch2_reason,
    close_time
FROM futures_positions
WHERE status = 'closed'
AND partial_close_info IS NOT NULL
ORDER BY close_time DESC
LIMIT 10;
```

**解决方案**:
- 降低第1批平仓评分 (95→85)
- 增加趋势转向预警灵敏度
- 提前触发平仓窗口 (30→35分钟)

---

**文档版本**: v2.1
**最后更新**: 2026-01-26
**下次审查**: 实施完成后7天

---

**核心理念**: 开仓寻找最低价，平仓寻找最高价，都用滚动价格基线 + 分批策略优化执行价格！
