# è¶…çº§å¤§è„‘å¿ƒç†å­¦ä¼˜åŒ–æ–¹æ¡ˆ

> **åŸºäº**: å¿ƒç†å­¦è¯„ä¼°æŠ¥å‘Šçš„æ·±åº¦åˆ†æ
> **ç›®æ ‡**: æä¾›å¯ç«‹å³å®æ–½çš„å…·ä½“æ”¹è¿›æ–¹æ¡ˆ
> **æ—¥æœŸ**: 2026-02-09

---

## ğŸ¯ æ ¸å¿ƒé—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

åŸºäºå¿ƒç†å­¦è¯„ä¼°ï¼Œæˆ‘è¯†åˆ«å‡º**5ä¸ªå…³é”®é—®é¢˜**å’Œå¯¹åº”çš„**å¯æ‰§è¡Œè§£å†³æ–¹æ¡ˆ**ã€‚

---

## é—®é¢˜1ï¼šç™½åå•åˆ¶åº¦çš„ç¡®è®¤åè¯¯é£é™© â­â­â­â­â­

### ç°çŠ¶åˆ†æ

```python
# å½“å‰ä»£ç  (smart_decision_brain.py)
self.whitelist_long = [
    'BCH/USDT', 'ENA/USDT', 'WIF/USDT', 'TAO/USDT',
    'DASH/USDT', 'ETC/USDT', 'NEAR/USDT', 'AAVE/USDT',
    'SUI/USDT', 'UNI/USDT', 'SOL/USDT'
]

# åªåšå¤šï¼Œæ°¸ä¸åšç©º
if symbol in self.whitelist_long:
    return self.should_trade(symbol)  # åªè¯„ä¼°LONG
```

**å¿ƒç†å­¦é£é™©**ï¼š
1. **ç¡®è®¤åè¯¯å›ºåŒ–**ï¼šç™½åå•å¯èƒ½åŸºäºè¿‡å»çš„æˆåŠŸæ¡ˆä¾‹ï¼ˆ"æˆ‘æ›¾ç»åšå¤šWIFèµšäº†é’±"ï¼‰ï¼Œè€Œå¿½ç•¥å¤±è´¥æ¡ˆä¾‹
2. **é”šå®šæ•ˆåº”**ï¼šè¿™äº›å¸ç§ä¸€æ—¦è¿›å…¥ç™½åå•ï¼Œå¾ˆéš¾è¢«ç§»é™¤ï¼ˆ"éƒ½ç”¨äº†è¿™ä¹ˆä¹…äº†"ï¼‰
3. **é€‰æ‹©æ€§è®°å¿†**ï¼šåªè®°å¾—ç™½åå•å¸ç§åšå¤šèµšé’±çš„æ—¶å€™ï¼Œå¿˜è®°åšå¤šäºæŸçš„æ—¶å€™

**å®é™…é—®é¢˜**ï¼š
- å¦‚æœæŸä¸ªå¸ç§è¶‹åŠ¿å½»åº•è½¬ç†Šï¼Œç™½åå•ä¼šæŒç»­äºæŸ
- å¸‚åœºç¯å¢ƒå˜åŒ–æ—¶ï¼ˆå¦‚å…¨é¢ç†Šå¸‚ï¼‰ï¼Œåªåšå¤šç­–ç•¥å®Œå…¨å¤±æ•ˆ
- æ²¡æœ‰å®¢è§‚çš„"è¿›å…¥"å’Œ"é€€å‡º"ç™½åå•çš„æ ‡å‡†

### ğŸ’¡ è§£å†³æ–¹æ¡ˆ1ï¼šåŠ¨æ€ç™½åå•ç³»ç»Ÿ

#### 1.1 å»ºç«‹ç™½åå•è¯„åˆ†æœºåˆ¶

```python
# æ–°å¢ï¼šç™½åå•è¯„åˆ†ç³»ç»Ÿ
class WhitelistScorer:
    """åŠ¨æ€è¯„ä¼°ç™½åå•å¸ç§çš„è¡¨ç°"""

    def __init__(self, db_config: dict):
        self.db_config = db_config
        self.evaluation_window = 30  # 30å¤©è¯„ä¼°å‘¨æœŸ

    def evaluate_symbol_performance(self, symbol: str) -> dict:
        """è¯„ä¼°å¸ç§åœ¨ç™½åå•ä¸­çš„è¡¨ç°"""

        # 1. è®¡ç®—æœ€è¿‘30å¤©çš„è¡¨ç°
        recent_trades = self.get_recent_trades(symbol, days=30)

        # 2. å…³é”®æŒ‡æ ‡
        metrics = {
            'win_rate': self.calculate_win_rate(recent_trades),      # èƒœç‡
            'avg_profit': self.calculate_avg_profit(recent_trades),  # å¹³å‡ç›ˆåˆ©
            'max_drawdown': self.calculate_max_drawdown(symbol),     # æœ€å¤§å›æ’¤
            'sharpe_ratio': self.calculate_sharpe_ratio(recent_trades),  # å¤æ™®æ¯”ç‡
            'long_vs_short': self.compare_long_short_performance(symbol)  # åšå¤švsåšç©ºæ¯”è¾ƒ
        }

        # 3. ç»¼åˆè¯„åˆ† (0-100)
        score = self.calculate_composite_score(metrics)

        # 4. ç­–ç•¥å»ºè®®
        recommendation = self.generate_recommendation(metrics)

        return {
            'symbol': symbol,
            'score': score,
            'metrics': metrics,
            'recommendation': recommendation,  # 'KEEP_LONG_ONLY', 'ALLOW_BOTH', 'REMOVE', 'SWITCH_TO_SHORT_ONLY'
            'reason': self.explain_recommendation(metrics)
        }

    def calculate_composite_score(self, metrics: dict) -> float:
        """ç»¼åˆè¯„åˆ†"""
        score = 0

        # èƒœç‡æƒé‡ 30%
        score += metrics['win_rate'] * 30

        # å¹³å‡ç›ˆåˆ©æƒé‡ 25%
        if metrics['avg_profit'] > 0:
            score += min(metrics['avg_profit'] * 10, 25)  # æœ€é«˜25åˆ†

        # æœ€å¤§å›æ’¤æƒé‡ 25% (å›æ’¤è¶Šå°è¶Šå¥½)
        if metrics['max_drawdown'] < 0.05:  # å°äº5%
            score += 25
        elif metrics['max_drawdown'] < 0.10:  # 5-10%
            score += 15
        elif metrics['max_drawdown'] < 0.15:  # 10-15%
            score += 5

        # å¤æ™®æ¯”ç‡æƒé‡ 20%
        if metrics['sharpe_ratio'] > 2:
            score += 20
        elif metrics['sharpe_ratio'] > 1:
            score += 10
        elif metrics['sharpe_ratio'] > 0:
            score += 5

        return score

    def generate_recommendation(self, metrics: dict) -> str:
        """ç”Ÿæˆç­–ç•¥å»ºè®®"""

        # å¦‚æœåšç©ºè¡¨ç°è¿œå¥½äºåšå¤š
        if metrics['long_vs_short']['short_better_by'] > 0.5:
            return 'SWITCH_TO_SHORT_ONLY'

        # å¦‚æœåšå¤šå’Œåšç©ºè¡¨ç°ç›¸è¿‘
        if abs(metrics['long_vs_short']['long_profit'] - metrics['long_vs_short']['short_profit']) < 0.1:
            return 'ALLOW_BOTH'

        # å¦‚æœç»¼åˆè¡¨ç°å¤ªå·®
        composite_score = self.calculate_composite_score(metrics)
        if composite_score < 40:
            return 'REMOVE'

        # å¦‚æœåšå¤šè¡¨ç°ä»ç„¶å¾ˆå¥½
        if metrics['win_rate'] > 0.6 and metrics['avg_profit'] > 0.02:
            return 'KEEP_LONG_ONLY'

        # é»˜è®¤ï¼šä¿å®ˆï¼Œå…è®¸åŒå‘
        return 'ALLOW_BOTH'

    def compare_long_short_performance(self, symbol: str) -> dict:
        """æ¯”è¾ƒåšå¤šå’Œåšç©ºçš„å†å²è¡¨ç°"""

        long_trades = self.get_trades_by_side(symbol, 'LONG', days=90)
        short_trades = self.get_trades_by_side(symbol, 'SHORT', days=90)

        long_profit = self.calculate_total_profit(long_trades)
        short_profit = self.calculate_total_profit(short_trades)

        return {
            'long_profit': long_profit,
            'short_profit': short_profit,
            'long_win_rate': self.calculate_win_rate(long_trades),
            'short_win_rate': self.calculate_win_rate(short_trades),
            'short_better_by': (short_profit - long_profit) if short_profit > long_profit else 0,
            'long_better_by': (long_profit - short_profit) if long_profit > short_profit else 0
        }
```

#### 1.2 é›†æˆåˆ°SmartDecisionBrain

```python
# ä¿®æ”¹ smart_decision_brain.py
class SmartDecisionBrain:

    def __init__(self, db_config: dict, exchange=None):
        # ... åŸæœ‰ä»£ç  ...

        # æ–°å¢ï¼šç™½åå•è¯„åˆ†å™¨
        self.whitelist_scorer = WhitelistScorer(db_config)

        # æ–°å¢ï¼šç™½åå•é…ç½®ï¼ˆåŠ¨æ€ï¼‰
        self.whitelist_config = {
            'BCH/USDT': {'strategy': 'LONG_ONLY', 'score': 0, 'last_updated': None},
            'ENA/USDT': {'strategy': 'LONG_ONLY', 'score': 0, 'last_updated': None},
            'WIF/USDT': {'strategy': 'LONG_ONLY', 'score': 0, 'last_updated': None},
            # ... å…¶ä»–å¸ç§ ...
        }

        # å¯åŠ¨æ—¶ç«‹å³è¯„ä¼°
        self.update_whitelist_scores()

    def update_whitelist_scores(self):
        """æ›´æ–°ç™½åå•è¯„åˆ†ï¼ˆæ¯å¤©æ‰§è¡Œä¸€æ¬¡ï¼‰"""

        logger.info("ğŸ”„ å¼€å§‹æ›´æ–°ç™½åå•è¯„åˆ†...")

        for symbol in self.whitelist_config.keys():
            try:
                evaluation = self.whitelist_scorer.evaluate_symbol_performance(symbol)

                # æ›´æ–°é…ç½®
                self.whitelist_config[symbol]['strategy'] = evaluation['recommendation']
                self.whitelist_config[symbol]['score'] = evaluation['score']
                self.whitelist_config[symbol]['last_updated'] = datetime.now()

                # è®°å½•å˜åŒ–
                if evaluation['recommendation'] != 'KEEP_LONG_ONLY':
                    logger.warning(
                        f"âš ï¸ {symbol} ç™½åå•ç­–ç•¥å˜æ›´: LONG_ONLY â†’ {evaluation['recommendation']}\n"
                        f"   åŸå› : {evaluation['reason']}\n"
                        f"   è¯„åˆ†: {evaluation['score']:.1f}/100"
                    )

            except Exception as e:
                logger.error(f"âŒ {symbol} è¯„åˆ†å¤±è´¥: {e}")

        # ä¿å­˜åˆ°æ•°æ®åº“
        self.save_whitelist_config()

    def should_trade(self, symbol: str) -> dict:
        """æ™ºèƒ½äº¤æ˜“å†³ç­–ï¼ˆæ”¯æŒåŠ¨æ€ç­–ç•¥ï¼‰"""

        # è·å–å½“å‰ç­–ç•¥
        strategy = self.whitelist_config.get(symbol, {}).get('strategy', 'ALLOW_BOTH')

        # 1. å¦‚æœå·²è¢«ç§»é™¤ç™½åå•
        if strategy == 'REMOVE':
            return {
                'decision': False,
                'reason': f'{symbol}å·²ä»ç™½åå•ç§»é™¤ï¼Œè¡¨ç°ä¸ä½³',
                'score': 0
            }

        # 2. è¯„ä¼°LONGä¿¡å·
        long_result = self._evaluate_long(symbol)

        # 3. è¯„ä¼°SHORTä¿¡å·ï¼ˆæ–°å¢ï¼‰
        short_result = self._evaluate_short(symbol)

        # 4. æ ¹æ®ç­–ç•¥è¿‡æ»¤
        if strategy == 'LONG_ONLY':
            # åªè¿”å›LONGä¿¡å·
            if long_result['score'] >= self.threshold:
                return long_result

        elif strategy == 'SHORT_ONLY':
            # åªè¿”å›SHORTä¿¡å·
            if short_result['score'] >= self.threshold:
                return short_result

        elif strategy == 'ALLOW_BOTH':
            # è¿”å›å¾—åˆ†æ›´é«˜çš„æ–¹å‘
            if long_result['score'] >= self.threshold or short_result['score'] >= self.threshold:
                return long_result if long_result['score'] > short_result['score'] else short_result

        return {'decision': False, 'score': 0}

    def _evaluate_short(self, symbol: str) -> dict:
        """è¯„ä¼°åšç©ºä¿¡å·ï¼ˆæ–°å¢æ–¹æ³•ï¼‰"""

        # ä½ç½®è¯„åˆ†ï¼ˆåå‘ï¼‰ï¼šä»·æ ¼è¶Šé«˜ï¼Œåšç©ºè¶Šå¥½
        pos_score = self.analyze_position_for_short(symbol)

        # è¶‹åŠ¿è¯„åˆ†ï¼ˆåå‘ï¼‰ï¼šè¶‹åŠ¿å‘ä¸‹ï¼Œåšç©ºè¶Šå¥½
        trend_score = self.analyze_trend_for_short(symbol)

        # ç›ˆäºæ¯”è¯„åˆ†ï¼ˆåå‘ï¼‰ï¼šé˜»åŠ›ä½è¿‘ï¼Œæ”¯æ’‘ä½è¿œ
        sr_score = self.analyze_support_resistance_for_short(symbol)

        base_score = pos_score + trend_score + sr_score

        # ç ´ä½åŠ æƒ
        breakout_boost = 0
        if self.breakout_system:
            score_result = self.breakout_system.calculate_signal_score(
                symbol=symbol,
                base_score=base_score,
                signal_direction='SHORT',  # åšç©ºæ–¹å‘
                current_price=self.get_current_price(symbol)
            )
            breakout_boost = score_result.get('boost_score', 0)

        total_score = base_score + breakout_boost

        return {
            'decision': total_score >= self.threshold,
            'side': 'SHORT',
            'score': total_score,
            'base_score': base_score,
            'breakout_boost': breakout_boost,
            'reasons': {
                'position': pos_score,
                'trend': trend_score,
                'support_resistance': sr_score
            }
        }
```

#### 1.3 å®šæ—¶ä»»åŠ¡ï¼šæ¯æ—¥è‡ªåŠ¨è¯„ä¼°

```python
# æ–°å¢ï¼šå®šæ—¶è¯„ä¼°è„šæœ¬ (scripts/update_whitelist.py)

import schedule
import time
from app.services.smart_decision_brain import SmartDecisionBrain

def update_whitelist_job():
    """æ¯æ—¥æ›´æ–°ç™½åå•è¯„åˆ†"""
    try:
        logger.info("â° å®šæ—¶ä»»åŠ¡ï¼šå¼€å§‹æ›´æ–°ç™½åå•è¯„åˆ†")

        brain = SmartDecisionBrain(db_config, exchange)
        brain.update_whitelist_scores()

        logger.info("âœ… ç™½åå•è¯„åˆ†æ›´æ–°å®Œæˆ")

    except Exception as e:
        logger.error(f"âŒ ç™½åå•è¯„åˆ†æ›´æ–°å¤±è´¥: {e}")

# æ¯å¤©å‡Œæ™¨2ç‚¹æ‰§è¡Œ
schedule.every().day.at("02:00").do(update_whitelist_job)

# ä¹Ÿå¯ä»¥æ‰‹åŠ¨è§¦å‘
if __name__ == '__main__':
    # ç«‹å³æ‰§è¡Œä¸€æ¬¡
    update_whitelist_job()

    # ç„¶åè¿›å…¥å®šæ—¶å¾ªç¯
    while True:
        schedule.run_pending()
        time.sleep(60)
```

#### 1.4 å¯è§†åŒ–ï¼šç™½åå•ä»ªè¡¨ç›˜

```python
# æ–°å¢ï¼šç™½åå•ç›‘æ§é¢æ¿ (scripts/whitelist_dashboard.py)

def generate_whitelist_report(brain: SmartDecisionBrain) -> str:
    """ç”Ÿæˆç™½åå•æŠ¥å‘Š"""

    report = "=" * 80 + "\n"
    report += "ğŸ“Š ç™½åå•å¸ç§è¯„ä¼°æŠ¥å‘Š\n"
    report += "=" * 80 + "\n\n"

    for symbol, config in sorted(brain.whitelist_config.items(), key=lambda x: x[1]['score'], reverse=True):
        evaluation = brain.whitelist_scorer.evaluate_symbol_performance(symbol)

        report += f"ã€{symbol}ã€‘\n"
        report += f"  ç­–ç•¥: {config['strategy']}\n"
        report += f"  è¯„åˆ†: {config['score']:.1f}/100\n"
        report += f"  èƒœç‡: {evaluation['metrics']['win_rate']*100:.1f}%\n"
        report += f"  å¹³å‡ç›ˆåˆ©: {evaluation['metrics']['avg_profit']*100:.2f}%\n"
        report += f"  æœ€å¤§å›æ’¤: {evaluation['metrics']['max_drawdown']*100:.1f}%\n"
        report += f"  å¤æ™®æ¯”ç‡: {evaluation['metrics']['sharpe_ratio']:.2f}\n"

        if evaluation['recommendation'] != 'KEEP_LONG_ONLY':
            report += f"  âš ï¸ å»ºè®®: {evaluation['recommendation']}\n"
            report += f"  åŸå› : {evaluation['reason']}\n"

        report += "\n"

    report += "=" * 80 + "\n"

    return report

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == '__main__':
    brain = SmartDecisionBrain(db_config, exchange)
    report = generate_whitelist_report(brain)
    print(report)

    # ä¿å­˜åˆ°æ–‡ä»¶
    with open('logs/whitelist_report.txt', 'w', encoding='utf-8') as f:
        f.write(report)
```

### ğŸ¯ é¢„æœŸæ•ˆæœ

1. **å¯¹æŠ—ç¡®è®¤åè¯¯**ï¼š
   - âœ… æ¯å¤©è‡ªåŠ¨è¯„ä¼°ï¼Œç”¨æ•°æ®è€Œéè®°å¿†å†³ç­–
   - âœ… å®¢è§‚æ ‡å‡†å†³å®šå¸ç§ç­–ç•¥ï¼ˆè€Œé"æˆ‘è§‰å¾—"ï¼‰

2. **å¯¹æŠ—é”šå®šæ•ˆåº”**ï¼š
   - âœ… å®šæœŸè¯„ä¼°ï¼Œä¸å›ºå®ˆåˆå§‹ç™½åå•
   - âœ… è¡¨ç°ä¸ä½³çš„å¸ç§ä¼šè¢«è‡ªåŠ¨ç§»é™¤

3. **ç­–ç•¥çµæ´»æ€§**ï¼š
   - âœ… ä»"åªåšå¤š"æ‰©å±•åˆ°"åŒå‘"æˆ–"åªåšç©º"
   - âœ… é€‚åº”å¸‚åœºç¯å¢ƒå˜åŒ–ï¼ˆç‰›å¸‚/ç†Šå¸‚ï¼‰

4. **å¯è¿½æº¯æ€§**ï¼š
   - âœ… æ¯æ¬¡å˜æ›´éƒ½æœ‰æ˜ç¡®ç†ç”±å’Œæ•°æ®æ”¯æŒ
   - âœ… å¯ä»¥å®¡æŸ¥å†å²å†³ç­–æ˜¯å¦æ­£ç¡®

---

## é—®é¢˜2ï¼šå†³ç­–é»‘ç®±å¯¼è‡´ç”¨æˆ·æ— æ³•å­¦ä¹  â­â­â­â­â­

### ç°çŠ¶åˆ†æ

```python
# å½“å‰ä»£ç åªè¿”å›æ€»åˆ†
result = brain.should_trade('WIF/USDT')
# è¾“å‡ºï¼š{'decision': True, 'score': 65}

# ç”¨æˆ·ä¸çŸ¥é“ï¼š
# - ä¸ºä»€ä¹ˆæ˜¯65åˆ†ï¼Ÿ
# - å“ªäº›å› ç´ è´¡çŒ®äº†å¤šå°‘åˆ†ï¼Ÿ
# - ç ´ä½åŠ æƒæ˜¯å¤šå°‘ï¼Ÿ
# - å†å²ä¸Š65åˆ†çš„ä¿¡å·èƒœç‡å¦‚ä½•ï¼Ÿ
```

**å¿ƒç†å­¦é£é™©**ï¼š
1. **æƒå¨æœä»**ï¼šç”¨æˆ·ç›²ç›®ä¿¡ä»»"65åˆ†"ï¼Œä¸åŠ æ‰¹åˆ¤
2. **ä¹ å¾—æ€§æ— åŠ©**ï¼šé•¿æœŸä¾èµ–é»‘ç®±ï¼Œä¸§å¤±ç‹¬ç«‹åˆ¤æ–­èƒ½åŠ›
3. **æ— æ³•æˆé•¿**ï¼šä¸ç†è§£é€»è¾‘ï¼Œæ— æ³•ä»äº¤æ˜“ä¸­å­¦ä¹ 

### ğŸ’¡ è§£å†³æ–¹æ¡ˆ2ï¼šé€æ˜åŒ–å†³ç­–ç³»ç»Ÿ

#### 2.1 è¯¦ç»†è¯„åˆ†è§£é‡Š

```python
# ä¿®æ”¹ should_trade è¿”å›å€¼
def should_trade(self, symbol: str) -> dict:
    """æ™ºèƒ½äº¤æ˜“å†³ç­–ï¼ˆé€æ˜åŒ–ç‰ˆæœ¬ï¼‰"""

    # 1. ä½ç½®è¯„åˆ†
    pos_analysis = self.analyze_position_detailed(symbol)

    # 2. è¶‹åŠ¿è¯„åˆ†
    trend_analysis = self.analyze_trend_detailed(symbol)

    # 3. ç›ˆäºæ¯”è¯„åˆ†
    sr_analysis = self.analyze_support_resistance_detailed(symbol)

    # 4. ç ´ä½åŠ æƒ
    breakout_analysis = self.analyze_breakout_detailed(symbol, base_score)

    # 5. å†å²ç»Ÿè®¡
    historical_stats = self.get_historical_stats(symbol, total_score)

    return {
        'decision': total_score >= self.threshold,
        'side': 'LONG',
        'score': total_score,

        # ğŸ†• è¯¦ç»†è¯„åˆ†æ˜ç»†
        'breakdown': {
            'position': {
                'score': pos_analysis['score'],
                'max_score': 30,
                'percentage': f"{pos_analysis['score']/30*100:.0f}%",
                'reason': pos_analysis['reason'],
                'data': pos_analysis['data']
            },
            'trend': {
                'score': trend_analysis['score'],
                'max_score': 20,
                'percentage': f"{trend_analysis['score']/20*100:.0f}%",
                'reason': trend_analysis['reason'],
                'data': trend_analysis['data']
            },
            'support_resistance': {
                'score': sr_analysis['score'],
                'max_score': 30,
                'percentage': f"{sr_analysis['score']/30*100:.0f}%",
                'reason': sr_analysis['reason'],
                'data': sr_analysis['data']
            },
            'breakout_boost': {
                'score': breakout_analysis['boost'],
                'range': 'Â±20~Â±50',
                'reason': breakout_analysis['reason'],
                'market': breakout_analysis['market_info']
            }
        },

        # ğŸ†• å†å²è¡¨ç°ç»Ÿè®¡
        'historical_performance': {
            'similar_signals': historical_stats['count'],
            'win_rate': f"{historical_stats['win_rate']*100:.1f}%",
            'avg_profit': f"{historical_stats['avg_profit']*100:.2f}%",
            'avg_loss': f"{historical_stats['avg_loss']*100:.2f}%",
            'expectancy': f"{historical_stats['expectancy']*100:.2f}%",
            'max_consecutive_losses': historical_stats['max_consecutive_losses']
        },

        # ğŸ†• å¯è§†åŒ–å»ºè®®
        'visualization': {
            'chart_url': f"/charts/{symbol}/analysis",
            'key_levels': {
                'current_price': current_price,
                'support': sr_analysis['support'],
                'resistance': sr_analysis['resistance'],
                'stop_loss': sr_analysis['suggested_stop_loss'],
                'take_profit': sr_analysis['suggested_take_profit']
            }
        },

        # ğŸ†• é£é™©æç¤º
        'risk_warning': self.generate_risk_warning(symbol, total_score, historical_stats)
    }

def analyze_position_detailed(self, symbol: str) -> dict:
    """è¯¦ç»†çš„ä½ç½®åˆ†æ"""

    klines = self.get_klines(symbol, '5m', 288)
    current_price = klines[-1][4]

    high_24h = max([k[2] for k in klines])
    low_24h = min([k[3] for k in klines])
    range_24h = high_24h - low_24h

    position_pct = (current_price - low_24h) / range_24h if range_24h > 0 else 0.5

    # è¯„åˆ†é€»è¾‘
    if position_pct < 0.3:
        score = 30
        reason = f"ä»·æ ¼ä½äº24Hä½ä½åŒºé—´({position_pct*100:.1f}%)ï¼Œåšå¤šä½ç½®æä½³"
    elif position_pct < 0.5:
        score = 20
        reason = f"ä»·æ ¼ä½äº24Hä¸­ä½ä½({position_pct*100:.1f}%)ï¼Œåšå¤šä½ç½®è¾ƒå¥½"
    elif position_pct < 0.7:
        score = 10
        reason = f"ä»·æ ¼ä½äº24Hä¸­é«˜ä½({position_pct*100:.1f}%)ï¼Œåšå¤šä½ç½®ä¸€èˆ¬"
    else:
        score = 0
        reason = f"ä»·æ ¼ä½äº24Hé«˜ä½åŒºé—´({position_pct*100:.1f}%)ï¼Œåšå¤šä½ç½®è¾ƒå·®"

    return {
        'score': score,
        'reason': reason,
        'data': {
            'current_price': current_price,
            'high_24h': high_24h,
            'low_24h': low_24h,
            'position_percentage': f"{position_pct*100:.1f}%",
            'distance_to_low': f"{((current_price - low_24h) / low_24h * 100):.2f}%",
            'distance_to_high': f"{((high_24h - current_price) / current_price * 100):.2f}%"
        }
    }

def get_historical_stats(self, symbol: str, current_score: float) -> dict:
    """è·å–ç±»ä¼¼è¯„åˆ†çš„å†å²è¡¨ç°"""

    # æŸ¥è¯¢è¯„åˆ†åœ¨ current_score Â± 5 èŒƒå›´å†…çš„å†å²ä¿¡å·
    score_min = current_score - 5
    score_max = current_score + 5

    query = """
        SELECT
            COUNT(*) as total,
            SUM(CASE WHEN profit > 0 THEN 1 ELSE 0 END) as wins,
            AVG(CASE WHEN profit > 0 THEN profit ELSE 0 END) as avg_win,
            AVG(CASE WHEN profit < 0 THEN profit ELSE 0 END) as avg_loss,
            AVG(profit) as avg_profit
        FROM trading_signals
        WHERE symbol = %s
          AND score BETWEEN %s AND %s
          AND created_at > NOW() - INTERVAL 90 DAY
    """

    result = self.db.execute(query, (symbol, score_min, score_max))

    if result['total'] > 0:
        win_rate = result['wins'] / result['total']
        expectancy = win_rate * result['avg_win'] + (1 - win_rate) * result['avg_loss']

        return {
            'count': result['total'],
            'win_rate': win_rate,
            'avg_profit': result['avg_profit'],
            'avg_win': result['avg_win'],
            'avg_loss': result['avg_loss'],
            'expectancy': expectancy,
            'max_consecutive_losses': self.get_max_consecutive_losses(symbol, score_min, score_max)
        }
    else:
        return {
            'count': 0,
            'win_rate': 0,
            'avg_profit': 0,
            'expectancy': 0,
            'max_consecutive_losses': 0,
            'warning': 'å†å²æ•°æ®ä¸è¶³ï¼Œè¯·è°¨æ…'
        }

def generate_risk_warning(self, symbol: str, score: float, historical_stats: dict) -> str:
    """ç”Ÿæˆé£é™©æç¤º"""

    warnings = []

    # 1. å†å²èƒœç‡ä½
    if historical_stats['win_rate'] < 0.5:
        warnings.append(f"âš ï¸ ç±»ä¼¼ä¿¡å·å†å²èƒœç‡ä»…{historical_stats['win_rate']*100:.1f}%ï¼Œä½äº50%")

    # 2. å†å²æ•°æ®ä¸è¶³
    if historical_stats['count'] < 10:
        warnings.append(f"âš ï¸ ç±»ä¼¼ä¿¡å·å†å²æ ·æœ¬ä»…{historical_stats['count']}ä¸ªï¼Œç»Ÿè®¡ä¸å¯é ")

    # 3. æœŸæœ›å€¼ä¸ºè´Ÿ
    if historical_stats['expectancy'] < 0:
        warnings.append(f"âš ï¸ ç±»ä¼¼ä¿¡å·æœŸæœ›å€¼ä¸ºè´Ÿ({historical_stats['expectancy']*100:.2f}%)ï¼Œä¸å»ºè®®äº¤æ˜“")

    # 4. è¿ç»­äºæŸé£é™©
    if historical_stats['max_consecutive_losses'] >= 5:
        warnings.append(f"âš ï¸ å†å²æœ€å¤§è¿ç»­äºæŸ{historical_stats['max_consecutive_losses']}æ¬¡ï¼Œè¯·åšå¥½å¿ƒç†å‡†å¤‡")

    # 5. è¯„åˆ†æ¥è¿‘é˜ˆå€¼
    if abs(score - self.threshold) < 5:
        warnings.append(f"âš ï¸ è¯„åˆ†({score:.1f})æ¥è¿‘é˜ˆå€¼({self.threshold})ï¼Œä¿¡å·å¯é æ€§ä¸€èˆ¬")

    if warnings:
        return "\n".join(warnings)
    else:
        return "âœ… ä¿¡å·è´¨é‡è‰¯å¥½ï¼Œä½†ä»éœ€è°¨æ…"
```

#### 2.2 äº¤äº’å¼å­¦ä¹ æ¨¡å¼

```python
# æ–°å¢ï¼šå­¦ä¹ æ¨¡å¼ (app/services/learning_mode.py)

class LearningMode:
    """äº¤äº’å¼å­¦ä¹ æ¨¡å¼ - å¸®åŠ©ç”¨æˆ·ç†è§£å†³ç­–é€»è¾‘"""

    def __init__(self, brain: SmartDecisionBrain):
        self.brain = brain

    def explain_signal(self, symbol: str, verbose: bool = True):
        """è¯¦ç»†è§£é‡Šä¿¡å·"""

        result = self.brain.should_trade(symbol)

        if verbose:
            self._print_detailed_explanation(result)

        return result

    def _print_detailed_explanation(self, result: dict):
        """æ‰“å°è¯¦ç»†è§£é‡Š"""

        print("\n" + "=" * 80)
        print(f"ğŸ“Š ã€{result.get('symbol', 'N/A')}ã€‘äº¤æ˜“ä¿¡å·è¯¦è§£")
        print("=" * 80 + "\n")

        # 1. æ€»ä½“å†³ç­–
        decision = "âœ… å»ºè®®å¼€ä»“" if result['decision'] else "âŒ ä¸å»ºè®®å¼€ä»“"
        print(f"å†³ç­–: {decision}")
        print(f"æ–¹å‘: {result['side']}")
        print(f"æ€»åˆ†: {result['score']:.1f} (é˜ˆå€¼: {self.brain.threshold})\n")

        # 2. è¯„åˆ†æ˜ç»†
        print("ğŸ“ˆ è¯„åˆ†æ˜ç»†:")
        print("-" * 80)

        breakdown = result['breakdown']

        for dimension, details in breakdown.items():
            if dimension == 'breakout_boost':
                print(f"\nğŸ”¥ ç ´ä½åŠ æƒ: {details['score']:+.0f} åˆ† ({details['range']})")
                print(f"   {details['reason']}")
                if details.get('market'):
                    market = details['market']
                    print(f"   å¸‚åœº: {market['direction']} æ–¹å‘, å¼ºåº¦ {market['strength']:.0f}")
            else:
                dimension_name = {
                    'position': 'ä½ç½®è¯„åˆ†',
                    'trend': 'è¶‹åŠ¿è¯„åˆ†',
                    'support_resistance': 'ç›ˆäºæ¯”è¯„åˆ†'
                }.get(dimension, dimension)

                print(f"\n{dimension_name}: {details['score']:.0f}/{details['max_score']} åˆ† ({details['percentage']})")
                print(f"   {details['reason']}")

                # æ˜¾ç¤ºå…³é”®æ•°æ®
                if details.get('data'):
                    for key, value in details['data'].items():
                        print(f"   - {key}: {value}")

        # 3. å†å²è¡¨ç°
        print("\n" + "-" * 80)
        print("ğŸ“Š ç±»ä¼¼ä¿¡å·å†å²è¡¨ç°:")
        print("-" * 80)

        hist = result['historical_performance']
        print(f"æ ·æœ¬æ•°é‡: {hist['similar_signals']} ä¸ª")
        print(f"èƒœç‡: {hist['win_rate']}")
        print(f"å¹³å‡ç›ˆåˆ©: {hist['avg_profit']}")
        print(f"å¹³å‡äºæŸ: {hist['avg_loss']}")
        print(f"æœŸæœ›å€¼: {hist['expectancy']}")
        print(f"æœ€å¤§è¿ç»­äºæŸ: {hist['max_consecutive_losses']} æ¬¡")

        # 4. é£é™©æç¤º
        print("\n" + "-" * 80)
        print("âš ï¸ é£é™©æç¤º:")
        print("-" * 80)
        print(result['risk_warning'])

        # 5. å…³é”®ä»·ä½
        print("\n" + "-" * 80)
        print("ğŸ¯ å…³é”®ä»·ä½:")
        print("-" * 80)

        viz = result['visualization']['key_levels']
        print(f"å½“å‰ä»·æ ¼: {viz['current_price']:.4f}")
        print(f"æ”¯æ’‘ä½: {viz['support']:.4f}")
        print(f"é˜»åŠ›ä½: {viz['resistance']:.4f}")
        print(f"å»ºè®®æ­¢æŸ: {viz['stop_loss']:.4f} ({((viz['stop_loss']/viz['current_price']-1)*100):.2f}%)")
        print(f"å»ºè®®æ­¢ç›ˆ: {viz['take_profit']:.4f} ({((viz['take_profit']/viz['current_price']-1)*100):.2f}%)")

        print("\n" + "=" * 80 + "\n")

    def quiz_user(self, symbol: str):
        """æµ‹éªŒç”¨æˆ·ç†è§£ç¨‹åº¦"""

        print(f"\nğŸ“ ç†è§£æµ‹éªŒ: {symbol}")
        print("-" * 80)

        # å…ˆè®©ç”¨æˆ·è‡ªå·±åˆ†æ
        print("è¯·å…ˆè‡ªå·±åˆ†æè¿™ä¸ªäº¤æ˜“æœºä¼šï¼Œç„¶åæŒ‰å›è½¦æŸ¥çœ‹ç³»ç»Ÿåˆ†æ...")
        input()

        # æ˜¾ç¤ºç³»ç»Ÿåˆ†æ
        result = self.explain_signal(symbol)

        # æé—®
        print("\nâ“ é—®é¢˜:")
        print("1. ä½ è®¤ä¸ºè¿™ä¸ªä¿¡å·çš„ä¸»è¦ä¼˜åŠ¿æ˜¯ä»€ä¹ˆï¼Ÿ")
        user_answer_1 = input("ä½ çš„ç­”æ¡ˆ: ")

        print("\n2. ä½ è®¤ä¸ºè¿™ä¸ªä¿¡å·çš„ä¸»è¦é£é™©æ˜¯ä»€ä¹ˆï¼Ÿ")
        user_answer_2 = input("ä½ çš„ç­”æ¡ˆ: ")

        print("\n3. å¦‚æœä½ å¼€ä»“ï¼Œä½ ä¼šè®¾ç½®å¤šå°‘æ­¢æŸï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ")
        user_answer_3 = input("ä½ çš„ç­”æ¡ˆ: ")

        # ä¿å­˜ç”¨æˆ·å›ç­”ç”¨äºåç»­åˆ†æ
        self._save_quiz_result(symbol, result, {
            'q1': user_answer_1,
            'q2': user_answer_2,
            'q3': user_answer_3
        })

        print("\nâœ… æµ‹éªŒå®Œæˆï¼ä½ çš„ç­”æ¡ˆå·²ä¿å­˜ï¼Œå¯ä»¥åœ¨åç»­å›é¡¾ä¸­å¯¹æ¯”å®é™…ç»“æœã€‚")

    def compare_with_user(self, symbol: str):
        """è®©ç”¨æˆ·å…ˆåˆ†æï¼Œç„¶åå¯¹æ¯”ç³»ç»Ÿåˆ†æ"""

        print(f"\nğŸ¤” å¯¹æ¯”ç»ƒä¹ : {symbol}")
        print("-" * 80)
        print("è¯·å…ˆè‡ªå·±å¯¹è¿™ä¸ªäº¤æ˜“æœºä¼šæ‰“åˆ†ï¼ˆ0-100ï¼‰ï¼Œå¹¶è¯´æ˜ç†ç”±ã€‚")
        print()

        user_score = float(input("ä½ çš„è¯„åˆ†ï¼ˆ0-100ï¼‰: "))
        user_reason = input("ä½ çš„ç†ç”±: ")

        print("\nâ³ æ­£åœ¨è®¡ç®—ç³»ç»Ÿè¯„åˆ†...")
        time.sleep(1)

        result = self.brain.should_trade(symbol)
        system_score = result['score']

        print(f"\nğŸ“Š ç»“æœå¯¹æ¯”:")
        print("-" * 80)
        print(f"ä½ çš„è¯„åˆ†: {user_score:.1f}")
        print(f"ç³»ç»Ÿè¯„åˆ†: {system_score:.1f}")
        print(f"å·®å¼‚: {abs(user_score - system_score):.1f} åˆ†")

        if abs(user_score - system_score) < 10:
            print("âœ… éå¸¸æ¥è¿‘ï¼ä½ å¯¹å¸‚åœºçš„ç†è§£å’Œç³»ç»Ÿä¸€è‡´ã€‚")
        elif abs(user_score - system_score) < 20:
            print("âš ï¸ æœ‰ä¸€å®šå·®å¼‚ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹åŸå› ...")
        else:
            print("âŒ å·®å¼‚è¾ƒå¤§ï¼Œéœ€è¦æ·±å…¥åˆ†æ...")

        print("\nä½ çš„ç†ç”±:")
        print(f"  {user_reason}")

        print("\nç³»ç»Ÿçš„ç†ç”±:")
        self._print_detailed_explanation(result)

        # å¼•å¯¼åæ€
        print("\nğŸ’­ åæ€é—®é¢˜:")
        print("1. ä½ é—æ¼äº†å“ªäº›ç³»ç»Ÿè€ƒè™‘çš„å› ç´ ï¼Ÿ")
        print("2. ä½ è¿‡åº¦å…³æ³¨äº†å“ªäº›å› ç´ ï¼Ÿ")
        print("3. ä¸‹æ¬¡åˆ†ææ—¶ï¼Œä½ ä¼šå¦‚ä½•æ”¹è¿›ï¼Ÿ")

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == '__main__':
    brain = SmartDecisionBrain(db_config, exchange)
    learning = LearningMode(brain)

    # è¯¦ç»†è§£é‡Šä¿¡å·
    learning.explain_signal('WIF/USDT')

    # æµ‹éªŒç”¨æˆ·
    learning.quiz_user('BCH/USDT')

    # å¯¹æ¯”ç»ƒä¹ 
    learning.compare_with_user('SOL/USDT')
```

#### 2.3 äº¤æ˜“åå¤ç›˜ç³»ç»Ÿ

```python
# æ–°å¢ï¼šå¤ç›˜ç³»ç»Ÿ (app/services/trade_review.py)

class TradeReviewSystem:
    """äº¤æ˜“å¤ç›˜ç³»ç»Ÿ - å¸®åŠ©ç”¨æˆ·ä»æ¯æ¬¡äº¤æ˜“ä¸­å­¦ä¹ """

    def __init__(self, db_config: dict):
        self.db_config = db_config

    def review_trade(self, trade_id: int):
        """å¤ç›˜å•æ¬¡äº¤æ˜“"""

        trade = self.get_trade_detail(trade_id)

        print("\n" + "=" * 80)
        print(f"ğŸ“‹ äº¤æ˜“å¤ç›˜ #{trade_id}")
        print("=" * 80 + "\n")

        # 1. åŸºæœ¬ä¿¡æ¯
        print("åŸºæœ¬ä¿¡æ¯:")
        print(f"  å¸ç§: {trade['symbol']}")
        print(f"  æ–¹å‘: {trade['side']}")
        print(f"  å¼€ä»“æ—¶é—´: {trade['entry_time']}")
        print(f"  å¹³ä»“æ—¶é—´: {trade['exit_time']}")
        print(f"  æŒä»“æ—¶é•¿: {trade['duration']}")

        # 2. å¼€ä»“æ—¶çš„å†³ç­–
        print("\nå¼€ä»“å†³ç­–:")
        print(f"  ç³»ç»Ÿè¯„åˆ†: {trade['entry_signal']['score']:.1f}")
        print(f"  è¯„åˆ†æ˜ç»†: {trade['entry_signal']['breakdown']}")
        print(f"  å†å²èƒœç‡: {trade['entry_signal']['historical_performance']['win_rate']}")

        # 3. å®é™…ç»“æœ
        print("\nå®é™…ç»“æœ:")
        profit_pct = (trade['exit_price'] - trade['entry_price']) / trade['entry_price'] * 100
        result_emoji = "âœ…" if profit_pct > 0 else "âŒ"
        print(f"  {result_emoji} ç›ˆäº: {profit_pct:+.2f}%")
        print(f"  å…¥åœºä»·: {trade['entry_price']:.4f}")
        print(f"  å‡ºåœºä»·: {trade['exit_price']:.4f}")
        print(f"  æœ€é«˜ä»·: {trade['highest_price']:.4f} ({((trade['highest_price']/trade['entry_price']-1)*100):+.2f}%)")
        print(f"  æœ€ä½ä»·: {trade['lowest_price']:.4f} ({((trade['lowest_price']/trade['entry_price']-1)*100):+.2f}%)")

        # 4. å¹³ä»“åŸå› åˆ†æ
        print("\nå¹³ä»“åŸå› :")
        exit_reason = trade['exit_reason']

        if exit_reason == 'STOP_LOSS':
            print("  âŒ è§¦å‘æ­¢æŸ")
            print(f"     æ­¢æŸä½: {trade['stop_loss']:.4f}")
            print(f"     äºæŸ: {profit_pct:.2f}%")
        elif exit_reason == 'TAKE_PROFIT':
            print("  âœ… è§¦å‘æ­¢ç›ˆ")
            print(f"     æ­¢ç›ˆä½: {trade['take_profit']:.4f}")
            print(f"     ç›ˆåˆ©: {profit_pct:.2f}%")
        elif exit_reason == 'BREAKOUT_REVERSE':
            print("  ğŸ”„ ç ´ä½åå‘å¹³ä»“")
            print(f"     è§¦å‘æ—¶æœº: {trade['exit_trigger']}")
        elif exit_reason == 'MANUAL':
            print("  ğŸ‘¤ æ‰‹åŠ¨å¹³ä»“")

        # 5. å…³é”®å­¦ä¹ ç‚¹
        print("\nğŸ’¡ å…³é”®å­¦ä¹ ç‚¹:")

        learnings = []

        # è¯„åˆ†æ˜¯å¦å‡†ç¡®ï¼Ÿ
        expected_result = "ç›ˆåˆ©" if trade['entry_signal']['score'] >= 50 else "å¯èƒ½äºæŸ"
        actual_result = "ç›ˆåˆ©" if profit_pct > 0 else "äºæŸ"

        if (expected_result == "ç›ˆåˆ©" and profit_pct > 0) or (expected_result == "å¯èƒ½äºæŸ" and profit_pct < 0):
            learnings.append("âœ… ç³»ç»Ÿè¯„åˆ†ä¸å®é™…ç»“æœä¸€è‡´ï¼ŒéªŒè¯äº†è¯„åˆ†ç³»ç»Ÿçš„æœ‰æ•ˆæ€§")
        else:
            learnings.append("âŒ ç³»ç»Ÿè¯„åˆ†ä¸å®é™…ç»“æœä¸ä¸€è‡´ï¼Œéœ€è¦åˆ†æåŸå› :")
            learnings.append(f"   é¢„æœŸ: {expected_result}, å®é™…: {actual_result}")

            # åˆ†æåŸå› 
            if trade.get('unexpected_event'):
                learnings.append(f"   å¯èƒ½åŸå› : {trade['unexpected_event']} (çªå‘äº‹ä»¶)")
            else:
                learnings.append("   å¯èƒ½åŸå› : å¸‚åœºçŸ­æœŸæ³¢åŠ¨ï¼Œæˆ–è¯„åˆ†å‚æ•°éœ€è¦è°ƒæ•´")

        # æ­¢æŸ/æ­¢ç›ˆæ˜¯å¦åˆç†ï¼Ÿ
        if exit_reason == 'STOP_LOSS':
            if abs(trade['lowest_price'] - trade['entry_price']) / trade['entry_price'] > 0.02:
                learnings.append("âš ï¸ ä»·æ ¼è¿œè¶…æ­¢æŸä½æ‰è§¦å‘ï¼Œå¯èƒ½æ­¢æŸè®¾ç½®è¿‡ç´§æˆ–æ‰§è¡Œå»¶è¿Ÿ")
            else:
                learnings.append("âœ… æ­¢æŸåŠæ—¶ï¼Œä¿æŠ¤äº†èµ„é‡‘")

        if exit_reason == 'TAKE_PROFIT':
            potential_profit = (trade['highest_price'] - trade['entry_price']) / trade['entry_price']
            actual_profit = profit_pct / 100

            if potential_profit > actual_profit * 1.5:
                learnings.append(f"âš ï¸ æœ€é«˜æ›¾æ¶¨åˆ°{potential_profit*100:.2f}%ï¼Œæ­¢ç›ˆä½({actual_profit*100:.2f}%)å¯èƒ½è¿‡æ—©")
            else:
                learnings.append("âœ… æ­¢ç›ˆè®¾ç½®åˆç†ï¼ŒæˆåŠŸé”å®šåˆ©æ¶¦")

        # ç ´ä½åˆ¤æ–­æ˜¯å¦æ­£ç¡®ï¼Ÿ
        if 'breakout_boost' in trade['entry_signal']['breakdown']:
            boost = trade['entry_signal']['breakdown']['breakout_boost']['score']
            if boost != 0:
                if (boost > 0 and profit_pct > 0) or (boost < 0 and profit_pct < 0):
                    learnings.append(f"âœ… ç ´ä½åˆ¤æ–­æ­£ç¡® (åŠ æƒ{boost:+.0f}åˆ†)ï¼Œç ´ä½ç³»ç»Ÿæœ‰æ•ˆ")
                else:
                    learnings.append(f"âŒ ç ´ä½åˆ¤æ–­å¤±è¯¯ (åŠ æƒ{boost:+.0f}åˆ†)ï¼Œå¯èƒ½æ˜¯å‡ç ´ä½")

        for i, learning in enumerate(learnings, 1):
            print(f"  {i}. {learning}")

        # 6. æ”¹è¿›å»ºè®®
        print("\nğŸ¯ æ”¹è¿›å»ºè®®:")

        suggestions = []

        if exit_reason == 'STOP_LOSS' and trade['entry_signal']['historical_performance']['win_rate'] < 0.5:
            suggestions.append("è¿™ç±»ä¿¡å·å†å²èƒœç‡è¾ƒä½ï¼Œå»ºè®®æé«˜å¼€ä»“é˜ˆå€¼æˆ–è·³è¿‡æ­¤ç±»ä¿¡å·")

        if abs(trade['lowest_price'] - trade['entry_price']) / trade['entry_price'] < 0.005:
            suggestions.append("ä»·æ ¼å‡ ä¹ç«‹å³åå‘ï¼Œå¯èƒ½å…¥åœºæ—¶æœºä¸ä½³ï¼Œå»ºè®®ç­‰å¾…æ›´æ˜ç¡®çš„ç¡®è®¤ä¿¡å·")

        if potential_profit > actual_profit * 2:
            suggestions.append("åˆ©æ¶¦å›åè¾ƒå¤šï¼Œå»ºè®®ä½¿ç”¨ç§»åŠ¨æ­¢ç›ˆæˆ–åˆ†æ‰¹æ­¢ç›ˆç­–ç•¥")

        if len(suggestions) == 0:
            suggestions.append("âœ… æ­¤æ¬¡äº¤æ˜“æ‰§è¡Œè‰¯å¥½ï¼Œç»§ç»­ä¿æŒ")

        for i, suggestion in enumerate(suggestions, 1):
            print(f"  {i}. {suggestion}")

        print("\n" + "=" * 80 + "\n")

    def weekly_review(self):
        """æ¯å‘¨å¤ç›˜"""

        print("\n" + "=" * 80)
        print("ğŸ“… æœ¬å‘¨äº¤æ˜“å¤ç›˜")
        print("=" * 80 + "\n")

        trades = self.get_weekly_trades()

        # 1. æ•´ä½“ç»Ÿè®¡
        total_trades = len(trades)
        winning_trades = len([t for t in trades if t['profit'] > 0])
        win_rate = winning_trades / total_trades if total_trades > 0 else 0

        total_profit = sum([t['profit'] for t in trades])
        avg_profit = total_profit / total_trades if total_trades > 0 else 0

        print("æ•´ä½“ç»Ÿè®¡:")
        print(f"  äº¤æ˜“æ¬¡æ•°: {total_trades}")
        print(f"  èƒœç‡: {win_rate*100:.1f}% ({winning_trades}/{total_trades})")
        print(f"  æ€»ç›ˆäº: {total_profit:.2f} USDT ({avg_profit:+.2f} USDT/ç¬”)")

        # 2. æœ€ä½³/æœ€å·®äº¤æ˜“
        if trades:
            best_trade = max(trades, key=lambda t: t['profit'])
            worst_trade = min(trades, key=lambda t: t['profit'])

            print(f"\næœ€ä½³äº¤æ˜“:")
            print(f"  {best_trade['symbol']} {best_trade['side']}")
            print(f"  ç›ˆåˆ©: +{best_trade['profit']:.2f} USDT ({best_trade['profit_pct']:+.2f}%)")

            print(f"\næœ€å·®äº¤æ˜“:")
            print(f"  {worst_trade['symbol']} {worst_trade['side']}")
            print(f"  äºæŸ: {worst_trade['profit']:.2f} USDT ({worst_trade['profit_pct']:.2f}%)")

        # 3. æŒ‰å¸ç§ç»Ÿè®¡
        print("\næŒ‰å¸ç§ç»Ÿè®¡:")
        symbol_stats = {}
        for trade in trades:
            symbol = trade['symbol']
            if symbol not in symbol_stats:
                symbol_stats[symbol] = {'count': 0, 'profit': 0, 'wins': 0}

            symbol_stats[symbol]['count'] += 1
            symbol_stats[symbol]['profit'] += trade['profit']
            if trade['profit'] > 0:
                symbol_stats[symbol]['wins'] += 1

        for symbol, stats in sorted(symbol_stats.items(), key=lambda x: x[1]['profit'], reverse=True):
            wr = stats['wins'] / stats['count'] * 100
            print(f"  {symbol}: {stats['count']}ç¬”, èƒœç‡{wr:.0f}%, ç›ˆäº{stats['profit']:+.2f} USDT")

        # 4. ç³»ç»Ÿè¯„åˆ†å‡†ç¡®æ€§
        print("\nç³»ç»Ÿè¯„åˆ†å‡†ç¡®æ€§:")
        correct_predictions = 0
        for trade in trades:
            score = trade['entry_signal']['score']
            profit = trade['profit']

            if (score >= 50 and profit > 0) or (score < 50 and profit < 0):
                correct_predictions += 1

        accuracy = correct_predictions / total_trades * 100 if total_trades > 0 else 0
        print(f"  é¢„æµ‹å‡†ç¡®ç‡: {accuracy:.1f}% ({correct_predictions}/{total_trades})")

        # 5. æœ¬å‘¨æ•™è®­
        print("\nğŸ’¡ æœ¬å‘¨å…³é”®æ•™è®­:")
        # ... è‡ªåŠ¨ç”Ÿæˆæ•™è®­æ€»ç»“ ...

        print("\n" + "=" * 80 + "\n")
```

### ğŸ¯ é¢„æœŸæ•ˆæœ

1. **å¯¹æŠ—é»‘ç®±æ•ˆåº”**ï¼š
   - âœ… ç”¨æˆ·å®Œå…¨ç†è§£æ¯ä¸ªè¯„åˆ†ç»´åº¦çš„å«ä¹‰
   - âœ… çŸ¥é“65åˆ†æ˜¯å¦‚ä½•è®¡ç®—å‡ºæ¥çš„
   - âœ… äº†è§£ç±»ä¼¼ä¿¡å·çš„å†å²è¡¨ç°

2. **ä¿ƒè¿›å­¦ä¹ æˆé•¿**ï¼š
   - âœ… äº¤äº’å¼å­¦ä¹ æ¨¡å¼åŸ¹å…»ç‹¬ç«‹åˆ¤æ–­èƒ½åŠ›
   - âœ… å¯¹æ¯”ç»ƒä¹ è®©ç”¨æˆ·å‘ç°è‡ªå·±çš„ç›²ç‚¹
   - âœ… å¤ç›˜ç³»ç»Ÿå¸®åŠ©ä»æ¯æ¬¡äº¤æ˜“ä¸­å­¦ä¹ 

3. **æé«˜ä¿¡ä»»åº¦**ï¼š
   - âœ… é€æ˜åŒ–å†³ç­–ï¼Œç”¨æˆ·ä¸å†ç›²ç›®ä¿¡ä»»
   - âœ… å±•ç¤ºå†å²è¡¨ç°ï¼Œè®¾å®šåˆç†é¢„æœŸ
   - âœ… é£é™©æç¤ºï¼Œé™ä½è¿‡åº¦è‡ªä¿¡

4. **äººæœºåä½œ**ï¼š
   - âœ… ç³»ç»Ÿæ˜¯"å¯¼å¸ˆ"ï¼Œä¸åªæ˜¯"å·¥å…·"
   - âœ… ä¿ç•™äººç±»åˆ¤æ–­ï¼Œè€Œéå®Œå…¨ä¾èµ–ç®—æ³•

---

## é—®é¢˜3ï¼šç¼ºä¹æƒ…ç»ªç®¡ç†å’Œå¿ƒç†æ”¯æŒ â­â­â­â­

### ç°çŠ¶åˆ†æ

å½“å‰ç³»ç»Ÿåªå¤„ç†å†³ç­–é€»è¾‘ï¼Œå®Œå…¨æ²¡æœ‰æƒ…ç»ªç®¡ç†åŠŸèƒ½ï¼š
- ç”¨æˆ·è¿ç»­äºæŸæ—¶ï¼Œæ²¡æœ‰å†·é™æœŸæœºåˆ¶
- ç”¨æˆ·ç„¦è™‘è¿‡åº¦äº¤æ˜“æ—¶ï¼Œæ²¡æœ‰é¢„è­¦
- ç”¨æˆ·æƒ…ç»ªå´©æºƒæ—¶ï¼Œæ²¡æœ‰å¿ƒç†æ”¯æŒèµ„æº

**å¿ƒç†å­¦é£é™©**ï¼š
- æƒ…ç»ªè¢«è½¬ç§»ï¼ˆä»å¸‚åœºåˆ°ç³»ç»Ÿï¼‰ï¼Œä½†æœªè¢«è§£å†³
- ç¼ºä¹å¿ƒç†éŸ§æ€§åŸ¹å…»
- é•¿æœŸå¯èƒ½å¯¼è‡´æƒ…ç»ªè€—ç«­å’Œå€¦æ€ 

### ğŸ’¡ è§£å†³æ–¹æ¡ˆ3ï¼šæƒ…ç»ªç›‘æµ‹ä¸å¿ƒç†æ”¯æŒç³»ç»Ÿ

#### 3.1 æƒ…ç»ªç›‘æµ‹æ¨¡å—

```python
# æ–°å¢ï¼šæƒ…ç»ªç›‘æµ‹ç³»ç»Ÿ (app/services/emotional_monitor.py)

class EmotionalMonitor:
    """æƒ…ç»ªç›‘æµ‹ç³»ç»Ÿ - æ£€æµ‹ç”¨æˆ·çš„æƒ…ç»ªåŒ–äº¤æ˜“è¡Œä¸º"""

    def __init__(self, db_config: dict):
        self.db_config = db_config

    def analyze_trading_behavior(self, user_id: int) -> dict:
        """åˆ†æç”¨æˆ·äº¤æ˜“è¡Œä¸ºï¼Œæ£€æµ‹æƒ…ç»ªåŒ–æ¨¡å¼"""

        # 1. è·å–æœ€è¿‘äº¤æ˜“
        recent_trades = self.get_recent_trades(user_id, days=7)
        today_trades = self.get_today_trades(user_id)

        # 2. è®¡ç®—åŸºå‡†è¡Œä¸º
        baseline = self.calculate_baseline(user_id, days=30)

        # 3. æ£€æµ‹å¼‚å¸¸è¡Œä¸º
        alerts = []

        # æ£€æµ‹1ï¼šè¿‡åº¦äº¤æ˜“ (ç„¦è™‘/FOMO)
        if len(today_trades) > baseline['avg_daily_trades'] * 2:
            alerts.append({
                'type': 'OVERTRADING',
                'severity': 'HIGH',
                'message': f"æ‚¨ä»Šå¤©å·²äº¤æ˜“{len(today_trades)}æ¬¡ï¼Œè¿œè¶…å¹³å¸¸çš„{baseline['avg_daily_trades']:.0f}æ¬¡",
                'emotion': 'ç„¦è™‘/FOMO',
                'suggestion': 'å»ºè®®æš‚åœäº¤æ˜“ï¼Œä¼‘æ¯1å°æ—¶åå†å†³ç­–'
            })

        # æ£€æµ‹2ï¼šæŠ¥å¤æ€§äº¤æ˜“ (æ„¤æ€’)
        if len(recent_trades) >= 2:
            last_trade = recent_trades[-1]
            second_last = recent_trades[-2]

            if last_trade['profit'] < 0 and (last_trade['timestamp'] - second_last['timestamp']) < 300:
                # äºæŸå5åˆ†é’Ÿå†…ç«‹å³å¼€æ–°ä»“
                alerts.append({
                    'type': 'REVENGE_TRADING',
                    'severity': 'CRITICAL',
                    'message': 'æ£€æµ‹åˆ°æ‚¨åœ¨äºæŸåç«‹å³å¼€ä»“ï¼Œè¿™å¯èƒ½æ˜¯æŠ¥å¤æ€§äº¤æ˜“',
                    'emotion': 'æ„¤æ€’/ä¸ç”˜å¿ƒ',
                    'suggestion': 'å¼ºçƒˆå»ºè®®æš‚åœäº¤æ˜“è‡³å°‘30åˆ†é’Ÿï¼Œæ·±å‘¼å¸ï¼Œå†·é™åå†å†³ç­–'
                })

        # æ£€æµ‹3ï¼šè¿‡åº¦ç›‘æ§ (ç„¦è™‘)
        if user_behavior['login_frequency'] > baseline['avg_login_frequency'] * 3:
            alerts.append({
                'type': 'EXCESSIVE_MONITORING',
                'severity': 'MEDIUM',
                'message': f"æ‚¨ä»Šå¤©ç™»å½•{user_behavior['login_frequency']}æ¬¡ï¼Œè¿œè¶…å¹³å¸¸",
                'emotion': 'ç„¦è™‘',
                'suggestion': 'è¿‡åº¦ç›‘æ§ä¼šå¢åŠ ç„¦è™‘ï¼Œå»ºè®®è®¾ç½®æ­¢æŸåï¼Œæ”¾å¿ƒç¦»å¼€'
            })

        # æ£€æµ‹4ï¼šè¿ç»­äºæŸåçš„ææƒ§ (ä¸æ•¢å¼€ä»“)
        consecutive_losses = self.get_consecutive_losses(recent_trades)
        if consecutive_losses >= 3:
            days_since_last_trade = self.days_since_last_trade(user_id)

            if days_since_last_trade >= 3:
                alerts.append({
                    'type': 'FEAR_PARALYSIS',
                    'severity': 'MEDIUM',
                    'message': f'æ‚¨å·²è¿ç»­äºæŸ{consecutive_losses}æ¬¡ï¼Œå¹¶ä¸”{days_since_last_trade}å¤©æœªäº¤æ˜“',
                    'emotion': 'ææƒ§',
                    'suggestion': 'è¿™å¯èƒ½æ˜¯è¿‡åº¦ææƒ§çš„è¡¨ç°ã€‚å»ºè®®å°ä»“ä½å°è¯•ï¼Œé‡å»ºä¿¡å¿ƒ'
                })

        # æ£€æµ‹5ï¼šé‡ä»“èµŒåš (è´ªå©ª/ç»æœ›)
        for trade in today_trades:
            if trade['position_size'] > baseline['avg_position_size'] * 2:
                alerts.append({
                    'type': 'HEAVY_POSITION',
                    'severity': 'CRITICAL',
                    'message': f"{trade['symbol']}ä»“ä½({trade['position_size']})æ˜¯å¹³å¸¸çš„2å€ä»¥ä¸Š",
                    'emotion': 'è´ªå©ªæˆ–ç»æœ›',
                    'suggestion': 'é‡ä»“éå¸¸å±é™©ï¼Œå»ºè®®ç«‹å³å‡ä»“è‡³æ­£å¸¸æ°´å¹³'
                })

        return {
            'alerts': alerts,
            'emotional_state': self.estimate_emotional_state(alerts),
            'recommendation': self.generate_recommendation(alerts)
        }

    def estimate_emotional_state(self, alerts: list) -> str:
        """ä¼°è®¡ç”¨æˆ·æƒ…ç»ªçŠ¶æ€"""

        if not alerts:
            return 'CALM'  # å¹³é™

        severity_counts = {
            'CRITICAL': len([a for a in alerts if a['severity'] == 'CRITICAL']),
            'HIGH': len([a for a in alerts if a['severity'] == 'HIGH']),
            'MEDIUM': len([a for a in alerts if a['severity'] == 'MEDIUM'])
        }

        if severity_counts['CRITICAL'] > 0:
            return 'HIGHLY_EMOTIONAL'  # é«˜åº¦æƒ…ç»ªåŒ–
        elif severity_counts['HIGH'] > 0:
            return 'EMOTIONAL'  # æƒ…ç»ªåŒ–
        elif severity_counts['MEDIUM'] > 0:
            return 'SLIGHTLY_EMOTIONAL'  # è½»åº¦æƒ…ç»ªåŒ–
        else:
            return 'CALM'

    def generate_recommendation(self, alerts: list) -> dict:
        """ç”Ÿæˆè¡ŒåŠ¨å»ºè®®"""

        if not alerts:
            return {'action': 'CONTINUE', 'message': 'âœ… äº¤æ˜“çŠ¶æ€è‰¯å¥½ï¼Œç»§ç»­ä¿æŒ'}

        critical_alerts = [a for a in alerts if a['severity'] == 'CRITICAL']

        if critical_alerts:
            return {
                'action': 'MANDATORY_BREAK',
                'duration': 3600,  # 1å°æ—¶
                'message': 'ğŸ›‘ æ£€æµ‹åˆ°ä¸¥é‡æƒ…ç»ªåŒ–äº¤æ˜“ï¼Œå¼ºåˆ¶å†·é™æœŸ1å°æ—¶',
                'exercises': [
                    'æ·±å‘¼å¸10æ¬¡ (4ç§’å¸æ°”ï¼Œ7ç§’æ†‹æ°”ï¼Œ8ç§’å‘¼æ°”)',
                    'ç¦»å¼€å±å¹•ï¼Œæ•£æ­¥15åˆ†é’Ÿ',
                    'å†™ä¸‹å½“å‰æ„Ÿå—ï¼šæˆ‘æ„Ÿåˆ°...',
                    'é—®è‡ªå·±ï¼šè¿™ç¬”äº¤æ˜“æ˜¯ç†æ€§çš„å—ï¼Ÿ'
                ]
            }
        else:
            return {
                'action': 'SUGGESTED_BREAK',
                'duration': 900,  # 15åˆ†é’Ÿ
                'message': 'âš ï¸ æ£€æµ‹åˆ°è½»åº¦æƒ…ç»ªåŒ–ï¼Œå»ºè®®ä¼‘æ¯15åˆ†é’Ÿ',
                'exercises': [
                    'æ·±å‘¼å¸5æ¬¡',
                    'å–æ¯æ°´ï¼Œèµ°åŠ¨ä¸€ä¸‹',
                    'å›é¡¾äº¤æ˜“è®¡åˆ’ï¼Œç¡®è®¤æ˜¯å¦åç¦»'
                ]
            }

    def enforce_cooldown(self, user_id: int, duration: int):
        """å¼ºåˆ¶å†·é™æœŸ - åœ¨å†·é™æœŸå†…ç¦æ­¢äº¤æ˜“"""

        cooldown_until = datetime.now() + timedelta(seconds=duration)

        # ä¿å­˜åˆ°æ•°æ®åº“
        query = """
            INSERT INTO cooldown_periods (user_id, start_time, end_time, reason)
            VALUES (%s, NOW(), %s, 'Emotional trading detected')
        """
        self.db.execute(query, (user_id, cooldown_until))

        logger.warning(f"ğŸ›‘ ç”¨æˆ·{user_id}è¿›å…¥å¼ºåˆ¶å†·é™æœŸï¼Œè‡³{cooldown_until}")

        return {
            'cooldown': True,
            'until': cooldown_until,
            'remaining_seconds': duration
        }

    def is_in_cooldown(self, user_id: int) -> dict:
        """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦åœ¨å†·é™æœŸ"""

        query = """
            SELECT end_time
            FROM cooldown_periods
            WHERE user_id = %s AND end_time > NOW()
            ORDER BY end_time DESC
            LIMIT 1
        """

        result = self.db.execute(query, (user_id,))

        if result:
            remaining = (result['end_time'] - datetime.now()).total_seconds()
            return {
                'in_cooldown': True,
                'remaining_seconds': int(remaining),
                'message': f"æ‚¨è¿˜åœ¨å†·é™æœŸï¼Œå‰©ä½™{int(remaining/60)}åˆ†é’Ÿ"
            }
        else:
            return {'in_cooldown': False}
```

#### 3.2 é›†æˆåˆ°äº¤æ˜“æµç¨‹

```python
# ä¿®æ”¹ should_trade æ–¹æ³•
class SmartDecisionBrain:

    def __init__(self, db_config: dict, exchange=None):
        # ... åŸæœ‰ä»£ç  ...

        # æ–°å¢ï¼šæƒ…ç»ªç›‘æµ‹å™¨
        self.emotional_monitor = EmotionalMonitor(db_config)
        self.user_id = 1  # å®é™…åº”ä»é…ç½®æˆ–å‚æ•°è·å–

    def should_trade(self, symbol: str) -> dict:
        """æ™ºèƒ½äº¤æ˜“å†³ç­–ï¼ˆé›†æˆæƒ…ç»ªç›‘æµ‹ï¼‰"""

        # ğŸ†• 1. æ£€æŸ¥å†·é™æœŸ
        cooldown_status = self.emotional_monitor.is_in_cooldown(self.user_id)
        if cooldown_status['in_cooldown']:
            return {
                'decision': False,
                'reason': cooldown_status['message'],
                'cooldown': True,
                'remaining_seconds': cooldown_status['remaining_seconds']
            }

        # ğŸ†• 2. æƒ…ç»ªç›‘æµ‹
        emotional_analysis = self.emotional_monitor.analyze_trading_behavior(self.user_id)

        if emotional_analysis['emotional_state'] == 'HIGHLY_EMOTIONAL':
            # å¼ºåˆ¶å†·é™æœŸ
            recommendation = emotional_analysis['recommendation']
            if recommendation['action'] == 'MANDATORY_BREAK':
                self.emotional_monitor.enforce_cooldown(self.user_id, recommendation['duration'])

                return {
                    'decision': False,
                    'reason': recommendation['message'],
                    'emotional_alerts': emotional_analysis['alerts'],
                    'exercises': recommendation['exercises'],
                    'forced_cooldown': True
                }

        # 3. æ­£å¸¸å†³ç­–æµç¨‹
        result = self._normal_trade_evaluation(symbol)

        # ğŸ†• 4. é™„åŠ æƒ…ç»ªæç¤º
        if emotional_analysis['alerts']:
            result['emotional_warning'] = {
                'state': emotional_analysis['emotional_state'],
                'alerts': emotional_analysis['alerts'],
                'recommendation': emotional_analysis['recommendation']
            }

        return result
```

#### 3.3 å¿ƒç†æ”¯æŒèµ„æºåº“

```python
# æ–°å¢ï¼šå¿ƒç†æ”¯æŒèµ„æº (app/services/psychological_support.py)

class PsychologicalSupport:
    """å¿ƒç†æ”¯æŒèµ„æºåº“"""

    @staticmethod
    def get_anxiety_management() -> dict:
        """ç„¦è™‘ç®¡ç†æŠ€å·§"""
        return {
            'title': 'åº”å¯¹äº¤æ˜“ç„¦è™‘',
            'techniques': [
                {
                    'name': '4-7-8å‘¼å¸æ³•',
                    'description': 'å¸æ°”4ç§’ï¼Œæ†‹æ°”7ç§’ï¼Œå‘¼æ°”8ç§’ï¼Œé‡å¤4æ¬¡',
                    'benefit': 'æ¿€æ´»å‰¯äº¤æ„Ÿç¥ç»ï¼Œå¿«é€Ÿé™ä½ç„¦è™‘'
                },
                {
                    'name': '5-4-3-2-1æ¥åœ°æ³•',
                    'description': 'è¯´å‡º5æ ·çœ‹è§çš„ï¼Œ4æ ·è§¦æ‘¸çš„ï¼Œ3æ ·å¬åˆ°çš„ï¼Œ2æ ·é—»åˆ°çš„ï¼Œ1æ ·å°åˆ°çš„',
                    'benefit': 'å°†æ³¨æ„åŠ›æ‹‰å›ç°å®ï¼Œç¦»å¼€ç„¦è™‘æ€ç»´'
                },
                {
                    'name': 'æ‹…å¿§æ—¶é—´è®¾å®š',
                    'description': 'æ¯å¤©è®¾å®š15åˆ†é’Ÿ"æ‹…å¿§æ—¶é—´"ï¼Œå…¶ä»–æ—¶é—´æ¨è¿Ÿæ‹…å¿§',
                    'benefit': 'é™åˆ¶ç„¦è™‘æ—¶é—´ï¼Œé˜²æ­¢å…¨å¤©ç„¦è™‘'
                },
                {
                    'name': 'è®¤çŸ¥é‡è¯„',
                    'description': 'é—®è‡ªå·±ï¼š1)è¯æ®æ˜¯ä»€ä¹ˆï¼Ÿ2)æœ€åæƒ…å†µæ˜¯ä»€ä¹ˆï¼Ÿæˆ‘èƒ½åº”å¯¹å—ï¼Ÿ',
                    'benefit': 'ç†æ€§è¯„ä¼°ï¼Œè€Œéç¾éš¾åŒ–'
                }
            ],
            'when_to_use': 'æ„Ÿåˆ°å¿ƒè·³åŠ é€Ÿã€å‡ºæ±—ã€è¿‡åº¦æ‹…å¿ƒæ—¶'
        }

    @staticmethod
    def get_anger_management() -> dict:
        """æ„¤æ€’ç®¡ç†æŠ€å·§"""
        return {
            'title': 'åº”å¯¹äº¤æ˜“æ„¤æ€’',
            'techniques': [
                {
                    'name': 'æš‚åœè§„åˆ™',
                    'description': 'æ„Ÿåˆ°æ„¤æ€’æ—¶ï¼Œç«‹å³æš‚åœï¼Œæ•°åˆ°10ï¼Œæ·±å‘¼å¸',
                    'benefit': 'é˜²æ­¢å†²åŠ¨å†³ç­–'
                },
                {
                    'name': 'è¯†åˆ«çœŸæ­£éœ€æ±‚',
                    'description': 'æ„¤æ€’èƒŒåé€šå¸¸æ˜¯æŒ«è´¥æˆ–ææƒ§ï¼Œé—®ï¼š"æˆ‘çœŸæ­£éœ€è¦ä»€ä¹ˆï¼Ÿ"',
                    'benefit': 'æ‰¾åˆ°çœŸæ­£é—®é¢˜ï¼Œè€Œéå‘æ³„'
                },
                {
                    'name': 'èº«ä½“é‡Šæ”¾',
                    'description': 'è·‘æ­¥ã€æ‰“æ‹³å‡»è¢‹ã€å†™æ„¤æ€’ä¿¡(ä¸å‘é€)',
                    'benefit': 'å®‰å…¨é‡Šæ”¾æ„¤æ€’èƒ½é‡'
                },
                {
                    'name': 'æ—¶é—´è§†è§’',
                    'description': 'é—®è‡ªå·±ï¼š10åˆ†é’Ÿ/10ä¸ªæœˆ/10å¹´åï¼Œè¿™è¿˜é‡è¦å—ï¼Ÿ',
                    'benefit': 'æ‹‰é•¿æ—¶é—´çº¿ï¼Œé™ä½æ„¤æ€’'
                }
            ],
            'when_to_use': 'äºæŸåæ„Ÿåˆ°æ„¤æ€’ã€æƒ³æŠ¥å¤å¸‚åœºæ—¶'
        }

    @staticmethod
    def get_fomo_management() -> dict:
        """FOMOç®¡ç†æŠ€å·§"""
        return {
            'title': 'åº”å¯¹FOMO(å®³æ€•é”™è¿‡)',
            'techniques': [
                {
                    'name': 'æœºä¼šæ— é™åŸåˆ™',
                    'description': 'æé†’è‡ªå·±ï¼šå¸‚åœºæ¯å¤©éƒ½æœ‰æœºä¼šï¼Œé”™è¿‡ä¸€æ¬¡ä¸ä¼šæ€æ ·',
                    'benefit': 'é™ä½ç´§è¿«æ„Ÿ'
                },
                {
                    'name': 'æˆæœ¬è®¡ç®—',
                    'description': 'è®¡ç®—è¿½é«˜çš„æ½œåœ¨äºæŸï¼Œè€Œéåªçœ‹æ½œåœ¨ç›ˆåˆ©',
                    'benefit': 'ç†æ€§è¯„ä¼°é£é™©'
                },
                {
                    'name': 'åå‘æ€è€ƒ',
                    'description': 'é—®ï¼šå¦‚æœæˆ‘ç°åœ¨å¼€ä»“ï¼Œæ˜å¤©è·Œäº†æ€ä¹ˆåŠï¼Ÿ',
                    'benefit': 'è€ƒè™‘ä¸‹è¡Œé£é™©'
                },
                {
                    'name': 'è®°å½•é”™è¿‡çš„"æœºä¼š"',
                    'description': 'è®°å½•ä½ FOMOä½†æ²¡åšçš„äº¤æ˜“ï¼Œä¸€å‘¨åå›çœ‹ï¼Œå¤šæ•°å¯èƒ½å·²ç»å›è½',
                    'benefit': 'éªŒè¯FOMOé€šå¸¸æ˜¯é”™è¯¯çš„'
                }
            ],
            'when_to_use': 'çœ‹åˆ°åˆ«äººèµšé’±ï¼Œæ„Ÿåˆ°"æˆ‘ä¹Ÿè¦ä¹°"çš„å†²åŠ¨æ—¶'
        }

    @staticmethod
    def get_loss_coping() -> dict:
        """äºæŸåº”å¯¹æŠ€å·§"""
        return {
            'title': 'å¦‚ä½•åº”å¯¹äºæŸ',
            'techniques': [
                {
                    'name': 'æ¥çº³æƒ…ç»ª',
                    'description': 'å…è®¸è‡ªå·±æ„Ÿåˆ°å¤±æœ›ã€æ²®ä¸§ï¼Œè¿™æ˜¯æ­£å¸¸çš„',
                    'benefit': 'å‹æŠ‘æƒ…ç»ªåè€Œä¼šæ”¾å¤§ç—›è‹¦'
                },
                {
                    'name': 'é‡æ–°æ¡†æ¶',
                    'description': 'è¿™ä¸æ˜¯"å¤±è´¥"ï¼Œè€Œæ˜¯"å­¦è´¹"ï¼Œæˆ‘å­¦åˆ°äº†ä»€ä¹ˆï¼Ÿ',
                    'benefit': 'ä»å¨èƒè½¬ä¸ºå­¦ä¹ æœºä¼š'
                },
                {
                    'name': 'ç™¾åˆ†æ¯”æ€ç»´',
                    'description': 'å…³æ³¨ç™¾åˆ†æ¯”è€Œéç»å¯¹é‡‘é¢ï¼šäº500 vs è´¦æˆ·äº2%',
                    'benefit': 'é™ä½æŸå¤±åŒæ¶çš„ç—›è‹¦'
                },
                {
                    'name': 'é•¿æœŸè§†è§’',
                    'description': 'çœ‹30å¤©/90å¤©æ€»ç›ˆäºï¼Œè€Œéå•æ¬¡äºæŸ',
                    'benefit': 'é¿å…è¢«å•æ¬¡äºæŸå‡»å®'
                }
            ],
            'when_to_use': 'äºæŸåæ„Ÿåˆ°ç—›è‹¦ã€è‡ªæˆ‘å¦å®šæ—¶'
        }

    @staticmethod
    def get_daily_routine() -> dict:
        """æ¯æ—¥å¿ƒç†å¥åº·ä¾‹è¡Œ"""
        return {
            'title': 'äº¤æ˜“è€…æ¯æ—¥å¿ƒç†å¥åº·ä¾‹è¡Œ',
            'morning': [
                'ç¡çœ å……è¶³(7-9å°æ—¶)ï¼Ÿ',
                'åƒæ—©é¤ï¼Œè¡¥å……èƒ½é‡',
                'å†¥æƒ³10åˆ†é’Ÿï¼Œæ¸…ç©ºå¤´è„‘',
                'å›é¡¾äº¤æ˜“è®¡åˆ’ï¼Œè€Œéç«‹å³çœ‹ç›˜',
                'é—®è‡ªå·±ï¼šä»Šå¤©çš„æƒ…ç»ªçŠ¶æ€å¦‚ä½•(1-10åˆ†)ï¼Ÿ'
            ],
            'during_trading': [
                'æ¯å°æ—¶ç¦»å¼€å±å¹•5åˆ†é’Ÿ',
                'è®¾ç½®æ­¢æŸåï¼Œä¸è¿‡åº¦ç›‘æ§',
                'è§‰å¯Ÿæƒ…ç»ªï¼šæ„Ÿåˆ°ç„¦è™‘/è´ªå©ª/æ„¤æ€’æ—¶æš‚åœ',
                'è¡¥å……æ°´åˆ†ï¼Œé¿å…å’–å•¡å› è¿‡é‡',
                'è®°å½•äº¤æ˜“ç†ç”±ï¼Œè€Œéå†²åŠ¨å¼€ä»“'
            ],
            'evening': [
                'å¤ç›˜ä»Šå¤©çš„äº¤æ˜“(5-10åˆ†é’Ÿ)',
                'è®°å½•3ä»¶å¥½äº‹(å³ä½¿äºæŸ)',
                'å†™ä¸‹æ˜å¤©çš„ç›®æ ‡å’Œç­–ç•¥',
                'é™åˆ¶å±å¹•æ—¶é—´ï¼Œç¡å‰1å°æ—¶ä¸çœ‹ç›˜',
                'é—®è‡ªå·±ï¼šä»Šå¤©æˆ‘ä»äº¤æ˜“ä¸­å­¦åˆ°ä»€ä¹ˆï¼Ÿ'
            ]
        }

    @staticmethod
    def show_support_menu():
        """æ˜¾ç¤ºå¿ƒç†æ”¯æŒèœå•"""
        print("\n" + "=" * 80)
        print("ğŸ§  å¿ƒç†æ”¯æŒèµ„æº")
        print("=" * 80 + "\n")

        print("1. åº”å¯¹äº¤æ˜“ç„¦è™‘")
        print("2. åº”å¯¹äº¤æ˜“æ„¤æ€’")
        print("3. åº”å¯¹FOMO(å®³æ€•é”™è¿‡)")
        print("4. å¦‚ä½•åº”å¯¹äºæŸ")
        print("5. æ¯æ—¥å¿ƒç†å¥åº·ä¾‹è¡Œ")
        print("6. è¿”å›")

        choice = input("\nè¯·é€‰æ‹© (1-6): ")

        if choice == '1':
            resource = PsychologicalSupport.get_anxiety_management()
        elif choice == '2':
            resource = PsychologicalSupport.get_anger_management()
        elif choice == '3':
            resource = PsychologicalSupport.get_fomo_management()
        elif choice == '4':
            resource = PsychologicalSupport.get_loss_coping()
        elif choice == '5':
            resource = PsychologicalSupport.get_daily_routine()
        else:
            return

        # æ˜¾ç¤ºèµ„æºå†…å®¹
        print("\n" + "=" * 80)
        print(f"ğŸ“š {resource['title']}")
        print("=" * 80 + "\n")

        if 'techniques' in resource:
            for i, technique in enumerate(resource['techniques'], 1):
                print(f"{i}. {technique['name']}")
                print(f"   æ–¹æ³•: {technique['description']}")
                print(f"   æ•ˆæœ: {technique['benefit']}\n")

            print(f"ğŸ’¡ ä½¿ç”¨æ—¶æœº: {resource['when_to_use']}")
        else:
            for key, items in resource.items():
                if key != 'title':
                    print(f"\n{key.upper()}:")
                    for item in items:
                        print(f"  â˜ {item}")

        input("\næŒ‰å›è½¦è¿”å›...")
        PsychologicalSupport.show_support_menu()
```

### ğŸ¯ é¢„æœŸæ•ˆæœ

1. **åŠæ—¶æƒ…ç»ªå¹²é¢„**ï¼š
   - âœ… è‡ªåŠ¨æ£€æµ‹å¼‚å¸¸äº¤æ˜“è¡Œä¸ºï¼ˆè¿‡åº¦äº¤æ˜“ã€æŠ¥å¤æ€§äº¤æ˜“ï¼‰
   - âœ… å¼ºåˆ¶å†·é™æœŸé˜²æ­¢æƒ…ç»ªåŒ–å†³ç­–
   - âœ… æä¾›å³æ—¶å¿ƒç†æŠ€å·§

2. **åŸ¹å…»æƒ…ç»ªè§‰å¯Ÿ**ï¼š
   - âœ… ç”¨æˆ·å¼€å§‹æ³¨æ„è‡ªå·±çš„æƒ…ç»ªçŠ¶æ€
   - âœ… å­¦ä¼šåœ¨æƒ…ç»ªæ¿€åŠ¨æ—¶æš‚åœ
   - âœ… å»ºç«‹æƒ…ç»ªç®¡ç†èƒ½åŠ›

3. **å¿ƒç†å¥åº·æ”¯æŒ**ï¼š
   - âœ… æä¾›ç§‘å­¦çš„å¿ƒç†æŠ€å·§èµ„æº
   - âœ… å»ºç«‹æ¯æ—¥å¥åº·ä¾‹è¡Œ
   - âœ… é™ä½æƒ…ç»ªè€—ç«­é£é™©

4. **é•¿æœŸå¯æŒç»­æ€§**ï¼š
   - âœ… äº¤æ˜“è€…ä¸åªä¾èµ–ç®—æ³•ï¼Œä¹Ÿå‘å±•å¿ƒç†éŸ§æ€§
   - âœ… é™ä½å› æƒ…ç»ªå´©æºƒè€Œæ”¾å¼ƒäº¤æ˜“çš„é£é™©

---

## å®æ–½ä¼˜å…ˆçº§å»ºè®®

æ ¹æ®å½±å“ç¨‹åº¦å’Œå®æ–½éš¾åº¦ï¼Œå»ºè®®æŒ‰ä»¥ä¸‹é¡ºåºå®æ–½ï¼š

### é˜¶æ®µ1ï¼šåŸºç¡€é€æ˜åŒ– (1-2å‘¨)
- âœ… è¯¦ç»†è¯„åˆ†è§£é‡Š (è§£å†³æ–¹æ¡ˆ2.1)
- âœ… å†å²è¡¨ç°ç»Ÿè®¡ (è§£å†³æ–¹æ¡ˆ2.1)
- âœ… é£é™©æç¤ºç”Ÿæˆ (è§£å†³æ–¹æ¡ˆ2.1)

### é˜¶æ®µ2ï¼šæƒ…ç»ªä¿æŠ¤æœºåˆ¶ (1-2å‘¨)
- âœ… æƒ…ç»ªç›‘æµ‹æ¨¡å— (è§£å†³æ–¹æ¡ˆ3.1)
- âœ… å¼ºåˆ¶å†·é™æœŸ (è§£å†³æ–¹æ¡ˆ3.1)
- âœ… å¿ƒç†æ”¯æŒèµ„æºåº“ (è§£å†³æ–¹æ¡ˆ3.3)

### é˜¶æ®µ3ï¼šç™½åå•åŠ¨æ€åŒ– (2-3å‘¨)
- âœ… ç™½åå•è¯„åˆ†ç³»ç»Ÿ (è§£å†³æ–¹æ¡ˆ1.1)
- âœ… åŠ¨æ€ç­–ç•¥è°ƒæ•´ (è§£å†³æ–¹æ¡ˆ1.2)
- âœ… å®šæ—¶ä»»åŠ¡ä¸ç›‘æ§ (è§£å†³æ–¹æ¡ˆ1.3)

### é˜¶æ®µ4ï¼šæ·±åº¦å­¦ä¹ åŠŸèƒ½ (2-3å‘¨)
- âœ… äº¤äº’å¼å­¦ä¹ æ¨¡å¼ (è§£å†³æ–¹æ¡ˆ2.2)
- âœ… äº¤æ˜“å¤ç›˜ç³»ç»Ÿ (è§£å†³æ–¹æ¡ˆ2.3)
- âœ… å¯¹æ¯”ç»ƒä¹ åŠŸèƒ½ (è§£å†³æ–¹æ¡ˆ2.2)

---

## é¢„æœŸç»¼åˆæ•ˆæœ

å®æ–½è¿™äº›ä¼˜åŒ–åï¼Œè¶…çº§å¤§è„‘å°†ä»ï¼š

**å½“å‰**: çº¯ç®—æ³•å†³ç­–å·¥å…· (è®¤çŸ¥åå·®å¯¹æŠ—9/10, å­¦ä¹ æ”¯æŒ5/10, æƒ…ç»ªç®¡ç†6/10)

**å‡çº§ä¸º**: æ™ºèƒ½äº¤æ˜“æ•™ç»ƒç³»ç»Ÿ (è®¤çŸ¥åå·®å¯¹æŠ—9/10, å­¦ä¹ æ”¯æŒ8/10, æƒ…ç»ªç®¡ç†8/10)

**æ ¸å¿ƒå˜åŒ–**:
1. **ä»é»‘ç®±åˆ°é€æ˜**ï¼šç”¨æˆ·å®Œå…¨ç†è§£æ¯ä¸ªå†³ç­–
2. **ä»å·¥å…·åˆ°å¯¼å¸ˆ**ï¼šç³»ç»Ÿä¸åªç»™ç­”æ¡ˆï¼Œè¿˜æ•™æ–¹æ³•
3. **ä»ç†æ€§åˆ°å…¨äºº**ï¼šä¸åªå¤„ç†å†³ç­–ï¼Œä¹Ÿå…³æ³¨æƒ…ç»ª
4. **ä»é™æ€åˆ°åŠ¨æ€**ï¼šå‚æ•°å’Œç­–ç•¥æŒç»­ä¼˜åŒ–
5. **ä»ä¾èµ–åˆ°æˆé•¿**ï¼šç”¨æˆ·èƒ½åŠ›æå‡ï¼Œè€Œéé€€åŒ–

**å¿ƒç†å­¦è¯„åˆ†æå‡**ï¼š
- æ€»ä½“è¯„åˆ†: 6.6/10 â†’ **8.2/10**
- å­¦ä¹ ä¸æˆé•¿æ”¯æŒ: 5/10 â†’ **8/10**
- æƒ…ç»ªç®¡ç†æ”¯æŒ: 6/10 â†’ **8/10**
- å¿ƒç†éŸ§æ€§åŸ¹å…»: 4/10 â†’ **7/10**
- é•¿æœŸå¯æŒç»­æ€§: 6/10 â†’ **8/10**

---

**æ–‡æ¡£å®Œæˆæ—¥æœŸ**: 2026-02-09
**é¢„è®¡å®æ–½å‘¨æœŸ**: 6-10å‘¨
**æŠ€æœ¯éš¾åº¦**: ä¸­ç­‰ï¼ˆä¸»è¦æ˜¯æ•°æ®åº“æŸ¥è¯¢å’Œå‰ç«¯å±•ç¤ºï¼‰
**å¿ƒç†å­¦æ”¶ç›Š**: æé«˜ï¼ˆè§£å†³äº†æ ¸å¿ƒçš„é»‘ç®±ã€ä¾èµ–ã€æƒ…ç»ªé—®é¢˜ï¼‰
