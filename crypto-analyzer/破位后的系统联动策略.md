# ç ´ä½åçš„ç³»ç»Ÿè”åŠ¨ç­–ç•¥

## æ ¸å¿ƒç†å¿µ

**ç ´ä½ä¸ä»…æ˜¯å¼€ä»“ä¿¡å·ï¼Œæ›´åº”è¯¥è§¦å‘æ•´ä¸ªäº¤æ˜“ç³»ç»Ÿçš„è”åŠ¨å“åº”**

---

## ğŸ¯ ç ´ä½åçš„ä¸‰å¤§ç³»ç»ŸåŠ¨ä½œ

### 1. åŒå‘ä¿¡å·åŠ æƒ (å¢å¼ºå¼€ä»“)
### 2. åå‘æŒä»“å¹³ä»“ (åŠæ—¶æ­¢æŸ)
### 3. åå‘ä¿¡å·é™æƒ (é¿å…é€†åŠ¿)

---

## ğŸ“Š å®Œæ•´è”åŠ¨æœºåˆ¶

```
Big4ç ´ä½æ£€æµ‹
      â†“
  æ–¹å‘: SHORT
      â†“
ç³»ç»Ÿè”åŠ¨å“åº”:
      â†“
â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           â”‚         â”‚         â”‚
â–¼           â–¼         â–¼         â–¼
åŒå‘ä¿¡å·    åå‘æŒä»“  åå‘ä¿¡å·  é£æ§è°ƒæ•´
åŠ æƒ+30åˆ†   ç«‹å³å¹³ä»“  é™æƒ-50åˆ†  æé«˜ä»“ä½
```

---

## 1ï¸âƒ£ åŒå‘ä¿¡å·åŠ æƒ

### åŸç†

```
Big4ç ´ä½å‘ä¸‹ â†’ å¸‚åœºè¿›å…¥åšç©ºè¶‹åŠ¿
             â†’ æ‰€æœ‰åšç©ºä¿¡å·å¯ä¿¡åº¦æé«˜
             â†’ ç»™åšç©ºä¿¡å·é¢å¤–åŠ åˆ†
```

### å®ç°é€»è¾‘

```python
class BreakoutSignalBooster:
    """ç ´ä½ä¿¡å·åŠ æƒå™¨"""

    def __init__(self):
        self.big4_direction = None  # 'LONG' | 'SHORT' | 'NEUTRAL'
        self.big4_strength = 0      # 0-100
        self.breakout_time = None
        self.expiry_hours = 4       # ç ´ä½ä¿¡å·æœ‰æ•ˆæœŸ4å°æ—¶

    def update_big4_breakout(self, direction, strength):
        """
        æ›´æ–°Big4ç ´ä½çŠ¶æ€

        Args:
            direction: ç ´ä½æ–¹å‘ ('LONG' | 'SHORT')
            strength: ç ´ä½å¼ºåº¦ (0-100)
        """
        self.big4_direction = direction
        self.big4_strength = strength
        self.breakout_time = datetime.now()

        logger.info(f"[ç ´ä½åŠ æƒ] Big4ç ´ä½æ–¹å‘: {direction}, å¼ºåº¦: {strength}")

    def is_breakout_active(self):
        """æ£€æŸ¥ç ´ä½ä¿¡å·æ˜¯å¦ä»ç„¶æœ‰æ•ˆ"""
        if not self.breakout_time:
            return False

        elapsed = (datetime.now() - self.breakout_time).total_seconds() / 3600
        return elapsed < self.expiry_hours

    def calculate_boost_score(self, signal_direction):
        """
        è®¡ç®—ä¿¡å·åŠ æƒåˆ†æ•°

        Args:
            signal_direction: ä¿¡å·æ–¹å‘ ('LONG' | 'SHORT')

        Returns:
            int: åŠ æƒåˆ†æ•° (-50 åˆ° +50)
        """
        if not self.is_breakout_active():
            return 0  # ç ´ä½ä¿¡å·å·²å¤±æ•ˆ

        # åŒå‘ä¿¡å·åŠ åˆ†
        if signal_direction == self.big4_direction:
            # æ ¹æ®Big4å¼ºåº¦å†³å®šåŠ åˆ†
            if self.big4_strength >= 90:
                boost = 50  # æå¼ºç ´ä½ï¼Œ+50åˆ†
            elif self.big4_strength >= 80:
                boost = 40  # å¼ºç ´ä½ï¼Œ+40åˆ†
            elif self.big4_strength >= 70:
                boost = 30  # ä¸­ç­‰ç ´ä½ï¼Œ+30åˆ†
            else:
                boost = 20  # å¼±ç ´ä½ï¼Œ+20åˆ†

            logger.info(f"[ç ´ä½åŠ æƒ] åŒå‘ä¿¡å· {signal_direction} åŠ æƒ +{boost}åˆ†")
            return boost

        # åå‘ä¿¡å·æ‰£åˆ†
        else:
            # æ ¹æ®Big4å¼ºåº¦å†³å®šæ‰£åˆ†
            if self.big4_strength >= 90:
                penalty = -50  # æå¼ºç ´ä½ï¼Œ-50åˆ†
            elif self.big4_strength >= 80:
                penalty = -40  # å¼ºç ´ä½ï¼Œ-40åˆ†
            elif self.big4_strength >= 70:
                penalty = -30  # ä¸­ç­‰ç ´ä½ï¼Œ-30åˆ†
            else:
                penalty = -20  # å¼±ç ´ä½ï¼Œ-20åˆ†

            logger.warning(f"[ç ´ä½åŠ æƒ] åå‘ä¿¡å· {signal_direction} é™æƒ {penalty}åˆ†")
            return penalty

# é›†æˆåˆ°å†³ç­–ç³»ç»Ÿ
class SmartDecisionBrainWithBreakout:
    """å¸¦ç ´ä½åŠ æƒçš„æ™ºèƒ½å†³ç­–å¤§è„‘"""

    def __init__(self):
        self.booster = BreakoutSignalBooster()

    def calculate_signal_score(self, symbol, signal_direction):
        """
        è®¡ç®—ä¿¡å·è¯„åˆ†

        Args:
            symbol: äº¤æ˜“å¯¹
            signal_direction: ä¿¡å·æ–¹å‘

        Returns:
            int: æ€»è¯„åˆ†
        """
        # åŸæœ‰è¯„åˆ†é€»è¾‘
        base_score = self.calculate_base_score(symbol)  # 0-100åˆ†

        # ç ´ä½åŠ æƒ
        boost_score = self.booster.calculate_boost_score(signal_direction)

        # æ€»åˆ†
        total_score = base_score + boost_score

        logger.info(f"[è¯„åˆ†] {symbol} {signal_direction}")
        logger.info(f"  åŸºç¡€åˆ†: {base_score}")
        logger.info(f"  ç ´ä½åŠ æƒ: {boost_score:+d}")
        logger.info(f"  æ€»åˆ†: {total_score}")

        return total_score

    def calculate_base_score(self, symbol):
        """åŸæœ‰çš„è¯„åˆ†é€»è¾‘"""
        score = 0

        # Big4è¶‹åŠ¿æ£€æµ‹ (20åˆ†)
        score += analyze_big4_trend()

        # æŠ€æœ¯æŒ‡æ ‡ (20åˆ†)
        score += analyze_technical_indicators()

        # æ”¯æ’‘é˜»åŠ› (30åˆ†)
        score += analyze_support_resistance()

        # æˆäº¤é‡åˆ†æ (15åˆ†)
        score += analyze_volume()

        # èµ„é‡‘æµå‘ (15åˆ†)
        score += analyze_money_flow()

        return score
```

### å®ä¾‹æ¼”ç¤º

```python
# Big4ç ´ä½æ£€æµ‹
big4_result = big4_detector.detect_market_direction()

if big4_result['direction'] == 'SHORT' and big4_result['strength'] >= 80:
    # æ›´æ–°ç ´ä½åŠ æƒå™¨
    booster.update_big4_breakout('SHORT', big4_result['strength'])

# è¯„ä¼°æŸä¸ªå¸ç§çš„ä¿¡å·
symbol = 'DOGE/USDT'

# æƒ…å†µ1: è¯¥å¸ç§ä¹Ÿæ˜¯åšç©ºä¿¡å·
score_short = brain.calculate_signal_score(symbol, 'SHORT')
# è¾“å‡º:
#   åŸºç¡€åˆ†: 65
#   ç ´ä½åŠ æƒ: +40  (Big4å¼ºåº¦80åˆ†)
#   æ€»åˆ†: 105 â†’ å¼ºçƒˆåšç©ºä¿¡å·ï¼

# æƒ…å†µ2: è¯¥å¸ç§æ˜¯åšå¤šä¿¡å·
score_long = brain.calculate_signal_score(symbol, 'LONG')
# è¾“å‡º:
#   åŸºç¡€åˆ†: 70
#   ç ´ä½åŠ æƒ: -40  (ä¸Big4ç›¸å)
#   æ€»åˆ†: 30 â†’ ä¸å»ºè®®åšå¤šï¼
```

---

## 2ï¸âƒ£ åå‘æŒä»“ç«‹å³å¹³ä»“

### åŸç†

```
Big4ç ´ä½å‘ä¸‹ â†’ å¸‚åœºè¶‹åŠ¿å‘ä¸‹
             â†’ æŒæœ‰çš„å¤šå•å¤„äºå±é™©
             â†’ ç«‹å³å¹³ä»“æ­¢æŸ
```

### å®ç°é€»è¾‘

```python
class BreakoutPositionManager:
    """ç ´ä½æŒä»“ç®¡ç†å™¨"""

    def __init__(self):
        self.positions = {}  # å½“å‰æŒä»“

    def handle_big4_breakout(self, direction, strength):
        """
        å¤„ç†Big4ç ´ä½

        Args:
            direction: ç ´ä½æ–¹å‘ ('LONG' | 'SHORT')
            strength: ç ´ä½å¼ºåº¦ (0-100)
        """
        logger.info(f"[ç ´ä½å¤„ç†] Big4ç ´ä½ {direction}, å¼ºåº¦ {strength}")

        # 1. ç«‹å³å¹³æ‰åå‘æŒä»“
        closed_positions = self.close_opposite_positions(direction, strength)

        # 2. è°ƒæ•´åŒå‘æŒä»“æ­¢æŸ
        adjusted_positions = self.adjust_same_direction_stops(direction, strength)

        return {
            'closed': closed_positions,
            'adjusted': adjusted_positions
        }

    def close_opposite_positions(self, breakout_direction, strength):
        """
        å¹³æ‰åå‘æŒä»“

        Args:
            breakout_direction: ç ´ä½æ–¹å‘
            strength: ç ´ä½å¼ºåº¦

        Returns:
            list: å·²å¹³ä»“ä½åˆ—è¡¨
        """
        closed = []

        for symbol, position in list(self.positions.items()):
            # åˆ¤æ–­æ˜¯å¦åå‘
            is_opposite = (
                (breakout_direction == 'SHORT' and position['side'] == 'LONG') or
                (breakout_direction == 'LONG' and position['side'] == 'SHORT')
            )

            if not is_opposite:
                continue

            # æ ¹æ®ç ´ä½å¼ºåº¦å†³å®šæ˜¯å¦å¹³ä»“
            should_close = False
            close_reason = ""

            if strength >= 90:
                # æå¼ºç ´ä½ï¼Œæ— æ¡ä»¶å¹³ä»“
                should_close = True
                close_reason = "Big4æå¼ºç ´ä½ï¼Œå¼ºåˆ¶å¹³ä»“"

            elif strength >= 80:
                # å¼ºç ´ä½ï¼ŒäºæŸä»“ä½å¹³ä»“
                if position['unrealized_pnl'] < 0:
                    should_close = True
                    close_reason = "Big4å¼ºç ´ä½ï¼ŒäºæŸä»“ä½æ­¢æŸ"

            elif strength >= 70:
                # ä¸­ç­‰ç ´ä½ï¼Œå¤§å¹…äºæŸä»“ä½å¹³ä»“
                if position['unrealized_pnl'] < -position['margin'] * 0.05:
                    should_close = True
                    close_reason = "Big4ç ´ä½ï¼Œå¤§å¹…äºæŸæ­¢æŸ"

            if should_close:
                # æ‰§è¡Œå¹³ä»“
                order = self.close_position(symbol, position, close_reason)
                closed.append({
                    'symbol': symbol,
                    'position': position,
                    'order': order,
                    'reason': close_reason
                })

                logger.warning(f"[å¼ºåˆ¶å¹³ä»“] {symbol} {position['side']}: {close_reason}")

        return closed

    def adjust_same_direction_stops(self, breakout_direction, strength):
        """
        è°ƒæ•´åŒå‘æŒä»“çš„æ­¢æŸ

        Args:
            breakout_direction: ç ´ä½æ–¹å‘
            strength: ç ´ä½å¼ºåº¦

        Returns:
            list: è°ƒæ•´åçš„æŒä»“
        """
        adjusted = []

        for symbol, position in self.positions.items():
            # åˆ¤æ–­æ˜¯å¦åŒå‘
            is_same = position['side'] == breakout_direction

            if not is_same:
                continue

            # æ ¹æ®ç ´ä½å¼ºåº¦è°ƒæ•´æ­¢æŸ
            if strength >= 90:
                # æå¼ºç ´ä½ï¼Œæ”¾å®½æ­¢æŸï¼Œè®©åˆ©æ¶¦å¥”è·‘
                new_stop_pct = 0.015  # 1.5%
                reason = "Big4æå¼ºç ´ä½ï¼Œæ”¾å®½æ­¢æŸ"

            elif strength >= 80:
                # å¼ºç ´ä½ï¼Œé€‚åº¦æ”¾å®½
                new_stop_pct = 0.012  # 1.2%
                reason = "Big4å¼ºç ´ä½ï¼Œé€‚åº¦æ”¾å®½æ­¢æŸ"

            else:
                # ä¸­ç­‰ç ´ä½ï¼Œä¿æŒåŸæ­¢æŸ
                continue

            # æ›´æ–°æ­¢æŸ
            old_stop = position['stop_loss']
            new_stop = self.calculate_new_stop_loss(
                position['entry_price'],
                position['side'],
                new_stop_pct
            )

            # åªåœ¨æ–°æ­¢æŸæ›´å®½æ¾æ—¶æ‰è°ƒæ•´
            if self.is_stop_more_loose(position['side'], old_stop, new_stop):
                position['stop_loss'] = new_stop
                position['stop_loss_reason'] = reason

                adjusted.append({
                    'symbol': symbol,
                    'old_stop': old_stop,
                    'new_stop': new_stop,
                    'reason': reason
                })

                logger.info(f"[è°ƒæ•´æ­¢æŸ] {symbol} {position['side']}: {old_stop} â†’ {new_stop}")

        return adjusted

    def close_position(self, symbol, position, reason):
        """å¹³ä»“"""
        order = exchange.create_order(
            symbol=symbol,
            side='SELL' if position['side'] == 'LONG' else 'BUY',
            type='MARKET',
            quantity=position['quantity'],
            reduce_only=True
        )

        # è®°å½•å¹³ä»“åŸå› 
        self.save_close_reason(order['id'], reason)

        # ä»æŒä»“åˆ—è¡¨ç§»é™¤
        del self.positions[symbol]

        return order
```

### å®ä¾‹æ¼”ç¤º

```python
# å½“å‰æŒä»“
position_manager.positions = {
    'DOGE/USDT': {'side': 'LONG', 'unrealized_pnl': -50, 'margin': 1000},
    'SHIB/USDT': {'side': 'LONG', 'unrealized_pnl': 30, 'margin': 800},
    'PEPE/USDT': {'side': 'SHORT', 'unrealized_pnl': 100, 'margin': 1200},
}

# Big4ç ´ä½å‘ä¸‹
result = position_manager.handle_big4_breakout('SHORT', strength=85)

# è¾“å‡º:
# [å¼ºåˆ¶å¹³ä»“] DOGE/USDT LONG: Big4å¼ºç ´ä½ï¼ŒäºæŸä»“ä½æ­¢æŸ
# [å¼ºåˆ¶å¹³ä»“] SHIB/USDT LONG: Big4å¼ºç ´ä½ï¼ŒäºæŸä»“ä½æ­¢æŸ  (å¯é€‰)
# [è°ƒæ•´æ­¢æŸ] PEPE/USDT SHORT: 0.000010 â†’ 0.000012 (æ”¾å®½æ­¢æŸ)

print(result)
# {
#     'closed': [
#         {'symbol': 'DOGE/USDT', 'reason': 'Big4å¼ºç ´ä½ï¼ŒäºæŸä»“ä½æ­¢æŸ'},
#         {'symbol': 'SHIB/USDT', 'reason': 'Big4å¼ºç ´ä½ï¼ŒäºæŸä»“ä½æ­¢æŸ'}
#     ],
#     'adjusted': [
#         {'symbol': 'PEPE/USDT', 'old_stop': 0.000010, 'new_stop': 0.000012}
#     ]
# }
```

---

## 3ï¸âƒ£ åå‘ä¿¡å·é™æƒ

### åŸç†

```
Big4ç ´ä½å‘ä¸‹ â†’ åšå¤šä¿¡å·ä¸å¯é 
             â†’ å³ä½¿æŠ€æœ¯æŒ‡æ ‡æ˜¾ç¤ºåšå¤š
             â†’ ä¹Ÿè¦å¤§å¹…é™æƒæˆ–è·³è¿‡
```

### å®ç°é€»è¾‘

```python
class SignalFilter:
    """ä¿¡å·è¿‡æ»¤å™¨"""

    def __init__(self, booster):
        self.booster = booster

    def should_skip_signal(self, signal_direction, signal_score):
        """
        åˆ¤æ–­æ˜¯å¦åº”è¯¥è·³è¿‡è¯¥ä¿¡å·

        Args:
            signal_direction: ä¿¡å·æ–¹å‘
            signal_score: ä¿¡å·è¯„åˆ†ï¼ˆå·²åŒ…å«åŠ æƒï¼‰

        Returns:
            bool, str: (æ˜¯å¦è·³è¿‡, åŸå› )
        """
        # æ£€æŸ¥Big4ç ´ä½çŠ¶æ€
        if not self.booster.is_breakout_active():
            return False, None  # æ— ç ´ä½ï¼Œæ­£å¸¸å¤„ç†

        big4_direction = self.booster.big4_direction
        big4_strength = self.booster.big4_strength

        # åŒå‘ä¿¡å·ï¼šæ”¾è¡Œ
        if signal_direction == big4_direction:
            return False, None

        # åå‘ä¿¡å·ï¼šæ ¹æ®å¼ºåº¦åˆ¤æ–­
        if big4_strength >= 90:
            # æå¼ºç ´ä½ï¼Œç›´æ¥è·³è¿‡åå‘ä¿¡å·
            return True, f"Big4æå¼º{big4_direction}ç ´ä½ï¼Œç¦æ­¢{signal_direction}ä¿¡å·"

        elif big4_strength >= 80:
            # å¼ºç ´ä½ï¼Œè¯„åˆ†ä¸è¶³ç›´æ¥è·³è¿‡
            if signal_score < 90:
                return True, f"Big4å¼º{big4_direction}ç ´ä½ï¼Œ{signal_direction}ä¿¡å·è¯„åˆ†ä¸è¶³"

        elif big4_strength >= 70:
            # ä¸­ç­‰ç ´ä½ï¼Œè¯„åˆ†ä¸è¶³è·³è¿‡
            if signal_score < 80:
                return True, f"Big4{big4_direction}ç ´ä½ï¼Œ{signal_direction}ä¿¡å·è¯„åˆ†ä¸è¶³"

        return False, None

# é›†æˆåˆ°ä¿¡å·ç”Ÿæˆ
class SignalGenerator:
    """ä¿¡å·ç”Ÿæˆå™¨"""

    def __init__(self):
        self.booster = BreakoutSignalBooster()
        self.filter = SignalFilter(self.booster)
        self.brain = SmartDecisionBrainWithBreakout()
        self.brain.booster = self.booster

    def generate_signals(self, symbols):
        """
        ç”Ÿæˆäº¤æ˜“ä¿¡å·

        Args:
            symbols: å¸ç§åˆ—è¡¨

        Returns:
            list: æœ‰æ•ˆä¿¡å·åˆ—è¡¨
        """
        valid_signals = []

        for symbol in symbols:
            # åˆ¤æ–­æ–¹å‘
            signal_direction = self.determine_direction(symbol)

            if not signal_direction:
                continue

            # è®¡ç®—è¯„åˆ†ï¼ˆåŒ…å«ç ´ä½åŠ æƒï¼‰
            score = self.brain.calculate_signal_score(symbol, signal_direction)

            # è¿‡æ»¤å™¨æ£€æŸ¥
            should_skip, reason = self.filter.should_skip_signal(signal_direction, score)

            if should_skip:
                logger.warning(f"[è·³è¿‡ä¿¡å·] {symbol} {signal_direction}: {reason}")
                continue

            # æœ‰æ•ˆä¿¡å·
            valid_signals.append({
                'symbol': symbol,
                'direction': signal_direction,
                'score': score
            })

        return valid_signals
```

### å®ä¾‹æ¼”ç¤º

```python
# Big4ç ´ä½å‘ä¸‹ï¼Œå¼ºåº¦85
booster.update_big4_breakout('SHORT', 85)

# ä¿¡å·ç”Ÿæˆ
generator = SignalGenerator()
signals = generator.generate_signals(['DOGE/USDT', 'SHIB/USDT', 'PEPE/USDT'])

# å¤„ç†è¿‡ç¨‹:
# DOGE/USDT:
#   æ–¹å‘: LONG
#   åŸºç¡€åˆ†: 75
#   ç ´ä½åŠ æƒ: -40 (åå‘)
#   æ€»åˆ†: 35
#   è¿‡æ»¤å™¨: è·³è¿‡ (Big4å¼ºSHORTç ´ä½ï¼ŒLONGä¿¡å·è¯„åˆ†ä¸è¶³)
#
# SHIB/USDT:
#   æ–¹å‘: SHORT
#   åŸºç¡€åˆ†: 70
#   ç ´ä½åŠ æƒ: +40 (åŒå‘)
#   æ€»åˆ†: 110
#   è¿‡æ»¤å™¨: é€šè¿‡ âœ“
#
# PEPE/USDT:
#   æ–¹å‘: LONG
#   åŸºç¡€åˆ†: 95
#   ç ´ä½åŠ æƒ: -40 (åå‘)
#   æ€»åˆ†: 55
#   è¿‡æ»¤å™¨: è·³è¿‡ (Big4å¼ºSHORTç ´ä½ï¼ŒLONGä¿¡å·è¯„åˆ†ä¸è¶³)

print(signals)
# [
#     {'symbol': 'SHIB/USDT', 'direction': 'SHORT', 'score': 110}
# ]
```

---

## ğŸ”„ å®Œæ•´ç³»ç»Ÿæµç¨‹

```python
class BreakoutAwareTradeSystem:
    """ç ´ä½æ„ŸçŸ¥äº¤æ˜“ç³»ç»Ÿ"""

    def __init__(self):
        self.big4_detector = Big4DirectionDetector()
        self.booster = BreakoutSignalBooster()
        self.position_manager = BreakoutPositionManager()
        self.signal_generator = SignalGenerator()
        self.signal_generator.booster = self.booster
        self.signal_generator.brain.booster = self.booster

    def run(self):
        """è¿è¡Œä¸»å¾ªç¯"""
        while True:
            # 1. æ£€æµ‹Big4ç ´ä½
            market = self.big4_detector.detect_market_direction()

            if market['direction'] != 'NEUTRAL' and market['strength'] >= 70:
                logger.info(f"\n{'='*60}")
                logger.info(f"Big4ç ´ä½æ£€æµ‹: {market['direction']}, å¼ºåº¦: {market['strength']}")
                logger.info(f"{'='*60}")

                # 2. æ›´æ–°ç ´ä½åŠ æƒå™¨
                self.booster.update_big4_breakout(
                    market['direction'],
                    market['strength']
                )

                # 3. å¤„ç†ç°æœ‰æŒä»“
                position_result = self.position_manager.handle_big4_breakout(
                    market['direction'],
                    market['strength']
                )

                logger.info(f"\n[æŒä»“å¤„ç†]")
                logger.info(f"  å¹³ä»“: {len(position_result['closed'])} ä¸ª")
                logger.info(f"  è°ƒæ•´æ­¢æŸ: {len(position_result['adjusted'])} ä¸ª")

            # 4. ç”Ÿæˆæ–°ä¿¡å·ï¼ˆè‡ªåŠ¨åº”ç”¨ç ´ä½åŠ æƒï¼‰
            signals = self.signal_generator.generate_signals(
                get_tradable_symbols()
            )

            logger.info(f"\n[ä¿¡å·ç”Ÿæˆ]")
            logger.info(f"  æœ‰æ•ˆä¿¡å·: {len(signals)} ä¸ª")

            for sig in signals[:5]:
                logger.info(f"  {sig['symbol']} {sig['direction']}: {sig['score']}åˆ†")

            # 5. æ‰§è¡Œäº¤æ˜“
            self.execute_trades(signals)

            # 6. ç­‰å¾…ä¸‹ä¸€æ¬¡æ£€æµ‹
            time.sleep(60)  # æ¯åˆ†é’Ÿæ£€æµ‹ä¸€æ¬¡

    def execute_trades(self, signals):
        """æ‰§è¡Œäº¤æ˜“"""
        for sig in signals:
            if sig['score'] >= 80:
                # å¼€ä»“
                order = self.open_position(sig)
                logger.info(f"[å¼€ä»“] {sig['symbol']} {sig['direction']}: {order}")
```

---

## ğŸ“Š ä¸è§¦åº•åå¼¹/è§é¡¶åè½¬çš„å¯¹æ¯”

### ç›¸ä¼¼ä¹‹å¤„

| ç‰¹å¾ | ç ´ä½ | è§¦åº•åå¼¹ | è§é¡¶åè½¬ |
|------|------|---------|---------|
| **åŒå‘åŠ æƒ** | âœ“ åšç©ºä¿¡å·+30åˆ† | âœ“ åšå¤šä¿¡å·+30åˆ† | âœ“ åšç©ºä¿¡å·+30åˆ† |
| **åå‘å¹³ä»“** | âœ“ å¹³æ‰å¤šå• | âœ“ å¹³æ‰ç©ºå• | âœ“ å¹³æ‰å¤šå• |
| **åå‘é™æƒ** | âœ“ åšå¤šä¿¡å·-50åˆ† | âœ“ åšç©ºä¿¡å·-50åˆ† | âœ“ åšå¤šä¿¡å·-50åˆ† |

### ç»Ÿä¸€å®ç°

```python
class MarketSignalHandler:
    """å¸‚åœºä¿¡å·å¤„ç†å™¨ï¼ˆç»Ÿä¸€å¤„ç†ç ´ä½/è§¦åº•/è§é¡¶ï¼‰"""

    def handle_market_signal(self, signal_type, direction, strength):
        """
        å¤„ç†å¸‚åœºä¿¡å·

        Args:
            signal_type: 'BREAKOUT' | 'BOTTOM_BOUNCE' | 'TOP_REVERSAL'
            direction: 'LONG' | 'SHORT'
            strength: 0-100

        Returns:
            dict: å¤„ç†ç»“æœ
        """
        logger.info(f"\n[å¸‚åœºä¿¡å·] {signal_type} {direction}, å¼ºåº¦ {strength}")

        # 1. æ›´æ–°åŠ æƒå™¨
        self.booster.update_signal(signal_type, direction, strength)

        # 2. å¤„ç†æŒä»“ï¼ˆå¹³åå‘ï¼Œè°ƒåŒå‘ï¼‰
        position_result = self.position_manager.handle_signal(
            direction,
            strength
        )

        # 3. è°ƒæ•´ä¿¡å·è¯„åˆ†
        # åç»­ç”Ÿæˆçš„ä¿¡å·ä¼šè‡ªåŠ¨åº”ç”¨åŠ æƒ

        return {
            'signal_type': signal_type,
            'direction': direction,
            'strength': strength,
            'closed_positions': position_result['closed'],
            'adjusted_positions': position_result['adjusted']
        }

# ä½¿ç”¨
handler = MarketSignalHandler()

# ç ´ä½
handler.handle_market_signal('BREAKOUT', 'SHORT', 85)

# è§¦åº•åå¼¹
handler.handle_market_signal('BOTTOM_BOUNCE', 'LONG', 90)

# è§é¡¶åè½¬
handler.handle_market_signal('TOP_REVERSAL', 'SHORT', 80)
```

---

## ğŸ“ é…ç½®å‚æ•°

```python
# ç ´ä½åŠ æƒé…ç½®
BREAKOUT_BOOST_CONFIG = {
    'same_direction': {
        'strength_90+': 50,   # æå¼ºç ´ä½ï¼ŒåŒå‘+50åˆ†
        'strength_80_90': 40, # å¼ºç ´ä½ï¼ŒåŒå‘+40åˆ†
        'strength_70_80': 30, # ä¸­ç­‰ç ´ä½ï¼ŒåŒå‘+30åˆ†
        'strength_60_70': 20  # å¼±ç ´ä½ï¼ŒåŒå‘+20åˆ†
    },
    'opposite_direction': {
        'strength_90+': -50,   # æå¼ºç ´ä½ï¼Œåå‘-50åˆ†
        'strength_80_90': -40, # å¼ºç ´ä½ï¼Œåå‘-40åˆ†
        'strength_70_80': -30, # ä¸­ç­‰ç ´ä½ï¼Œåå‘-30åˆ†
        'strength_60_70': -20  # å¼±ç ´ä½ï¼Œåå‘-20åˆ†
    },
    'expiry_hours': 4  # ç ´ä½ä¿¡å·æœ‰æ•ˆæœŸ4å°æ—¶
}

# æŒä»“å¤„ç†é…ç½®
POSITION_HANDLE_CONFIG = {
    'force_close': {
        'strength_90+': 'all_opposite',        # æå¼ºç ´ä½ï¼Œå¹³æ‰æ‰€æœ‰åå‘
        'strength_80_90': 'losing_opposite',   # å¼ºç ´ä½ï¼Œå¹³æ‰äºæŸåå‘
        'strength_70_80': 'heavy_losing'       # ä¸­ç­‰ç ´ä½ï¼Œå¹³æ‰å¤§å¹…äºæŸ
    },
    'adjust_stop': {
        'strength_90+': 0.015,  # æå¼ºç ´ä½ï¼Œæ”¾å®½æ­¢æŸåˆ°1.5%
        'strength_80_90': 0.012 # å¼ºç ´ä½ï¼Œæ”¾å®½æ­¢æŸåˆ°1.2%
    }
}

# ä¿¡å·è¿‡æ»¤é…ç½®
SIGNAL_FILTER_CONFIG = {
    'strength_90+': 'block_all_opposite',    # æå¼ºç ´ä½ï¼Œç¦æ­¢æ‰€æœ‰åå‘
    'strength_80_90': 'block_weak_opposite', # å¼ºç ´ä½ï¼Œç¦æ­¢å¼±åå‘(<90åˆ†)
    'strength_70_80': 'warn_opposite'        # ä¸­ç­‰ç ´ä½ï¼Œè­¦å‘Šåå‘(<80åˆ†)
}
```

---

## ğŸ¯ æ€»ç»“

### ç ´ä½è”åŠ¨ä¸‰åŸåˆ™

1. **åŒå‘åŠ å¼º**
   - åŒæ–¹å‘ä¿¡å·é¢å¤–åŠ åˆ†
   - é¼“åŠ±é¡ºåŠ¿è€Œä¸º
   - æé«˜å¼€ä»“æ¦‚ç‡

2. **åå‘æ¸…ç†**
   - ç«‹å³å¹³æ‰åå‘æŒä»“
   - åŠæ—¶æ­¢æŸï¼Œé¿å…æ‰©å¤§æŸå¤±
   - ä¿æŠ¤è´¦æˆ·å®‰å…¨

3. **åå‘é™åˆ¶**
   - åå‘ä¿¡å·å¤§å¹…é™æƒ
   - é¿å…é€†åŠ¿å¼€ä»“
   - å‡å°‘é”™è¯¯äº¤æ˜“

### ä¸å…¶ä»–ä¿¡å·çš„ç»Ÿä¸€

ç ´ä½ã€è§¦åº•åå¼¹ã€è§é¡¶åè½¬æœ¬è´¨ä¸Šéƒ½æ˜¯å¸‚åœºè¶‹åŠ¿ä¿¡å·ï¼Œåº”è¯¥ç”¨ç»Ÿä¸€çš„æœºåˆ¶å¤„ç†ï¼š
- åŒå‘åŠ æƒ
- åå‘å¹³ä»“
- åå‘é™æƒ

### å…³é”®å‚æ•°

- ç ´ä½å¼ºåº¦ >= 90: æå¼ºä¿¡å·ï¼Œæ— æ¡ä»¶æ‰§è¡Œ
- ç ´ä½å¼ºåº¦ 80-90: å¼ºä¿¡å·ï¼Œéƒ¨åˆ†æ‰§è¡Œ
- ç ´ä½å¼ºåº¦ 70-80: ä¸­ç­‰ä¿¡å·ï¼Œè°¨æ…æ‰§è¡Œ
- ç ´ä½æœ‰æ•ˆæœŸ: 4å°æ—¶
