# 破位信号收敛机制

## 核心问题

**破位信号不能长时间持续，必须有收敛和失效机制**

---

## 🚨 当前问题

### 问题场景

```
08:00 Big4破位向下 → 生成做空信号
08:05 继续做空信号
08:10 继续做空信号
08:15 继续做空信号
...
10:00 还在做空信号？ ❌

问题:
1. 破位是瞬间事件，不应该持续2小时
2. 长时间发信号会导致过度开仓
3. 可能在破位后的反弹中开仓，造成损失
```

### 为什么需要收敛

```
破位的本质:
- 是一个"事件"，不是"状态"
- 发生时间很短（5-15分钟）
- 之后市场进入新的平衡

如果不收敛:
- 会在反弹时还发做空信号
- 会在整理时还发破位信号
- 导致错误交易
```

---

## ✅ 解决方案

### 1. 时间窗口限制

```python
class BreakoutSignalWithExpiry:
    """带失效时间的破位信号"""

    def __init__(self):
        self.big4_breakout = None
        self.breakout_time = None
        self.expiry_duration = 4 * 3600  # 4小时失效

    def update_breakout(self, direction, strength):
        """
        更新破位信号

        Args:
            direction: 破位方向
            strength: 破位强度
        """
        self.big4_breakout = {
            'direction': direction,
            'strength': strength,
            'time': datetime.now()
        }
        self.breakout_time = datetime.now()

        logger.info(f"[破位信号] {direction} 强度{strength}, 有效期4小时")

    def is_active(self):
        """
        检查破位信号是否仍然有效

        Returns:
            bool: 是否有效
        """
        if not self.breakout_time:
            return False

        elapsed = (datetime.now() - self.breakout_time).total_seconds()

        if elapsed > self.expiry_duration:
            logger.warning(f"[破位失效] 信号已过期({elapsed/3600:.1f}小时)")
            return False

        return True

    def get_remaining_time(self):
        """获取剩余有效时间"""
        if not self.breakout_time:
            return 0

        elapsed = (datetime.now() - self.breakout_time).total_seconds()
        remaining = max(0, self.expiry_duration - elapsed)

        return remaining

# 使用
signal = BreakoutSignalWithExpiry()

# 08:00 破位
signal.update_breakout('SHORT', 95)

# 08:30 检查
if signal.is_active():
    print("破位信号有效")  # ✓

# 12:30 检查（4.5小时后）
if signal.is_active():
    print("破位信号有效")  # ✗ 已失效
```

### 2. 开仓次数限制

```python
class BreakoutOpeningLimiter:
    """破位开仓次数限制器"""

    def __init__(self):
        self.breakout_sessions = {}  # 记录每次破位

    def start_breakout_session(self, direction, strength):
        """
        开始新的破位会话

        Args:
            direction: 破位方向
            strength: 破位强度
        """
        session_id = f"{direction}_{int(datetime.now().timestamp())}"

        # 根据强度决定最大开仓次数
        if strength >= 90:
            max_openings = 5  # 极强破位，允许5次
        elif strength >= 80:
            max_openings = 4  # 强破位，允许4次
        elif strength >= 70:
            max_openings = 3  # 中等破位，允许3次
        else:
            max_openings = 2  # 弱破位，允许2次

        self.breakout_sessions[session_id] = {
            'direction': direction,
            'strength': strength,
            'start_time': datetime.now(),
            'max_openings': max_openings,
            'opened_count': 0,
            'opened_symbols': []
        }

        logger.info(f"[破位会话] {session_id} 开始, 最多允许{max_openings}次开仓")

        return session_id

    def can_open_position(self, session_id, symbol):
        """
        检查是否可以开仓

        Args:
            session_id: 会话ID
            symbol: 币种

        Returns:
            bool, str: (是否可以, 原因)
        """
        if session_id not in self.breakout_sessions:
            return False, "会话不存在"

        session = self.breakout_sessions[session_id]

        # 检查是否已达上限
        if session['opened_count'] >= session['max_openings']:
            return False, f"已达开仓上限({session['max_openings']})"

        # 检查是否已开过该币种
        if symbol in session['opened_symbols']:
            return False, f"{symbol}已开仓"

        # 检查时间（破位后30分钟内）
        elapsed = (datetime.now() - session['start_time']).total_seconds()
        if elapsed > 30 * 60:
            return False, f"破位已过去{elapsed/60:.0f}分钟，超过30分钟窗口"

        return True, "可以开仓"

    def record_opening(self, session_id, symbol):
        """记录开仓"""
        if session_id in self.breakout_sessions:
            session = self.breakout_sessions[session_id]
            session['opened_count'] += 1
            session['opened_symbols'].append(symbol)

            remaining = session['max_openings'] - session['opened_count']
            logger.info(f"[开仓记录] {symbol}, 剩余{remaining}次机会")

# 使用
limiter = BreakoutOpeningLimiter()

# 08:00 Big4破位
session_id = limiter.start_breakout_session('SHORT', 85)
# 最多允许4次开仓

# 08:01 开仓DOGE
can_open, reason = limiter.can_open_position(session_id, 'DOGE/USDT')
if can_open:
    open_position('DOGE/USDT')
    limiter.record_opening(session_id, 'DOGE/USDT')
    # 剩余3次

# 08:05 开仓SHIB
can_open, reason = limiter.can_open_position(session_id, 'SHIB/USDT')
if can_open:
    open_position('SHIB/USDT')
    limiter.record_opening(session_id, 'SHIB/USDT')
    # 剩余2次

# ... 继续开仓

# 08:30 尝试开仓第6个
can_open, reason = limiter.can_open_position(session_id, 'UNI/USDT')
# 返回: False, "已达开仓上限(4)"
```

### 3. 价格回归检测

```python
class BreakoutReversalDetector:
    """破位反转检测器"""

    def __init__(self):
        self.breakout_level = None
        self.breakout_direction = None

    def set_breakout(self, level, direction):
        """
        设置破位信息

        Args:
            level: 破位价位
            direction: 破位方向
        """
        self.breakout_level = level
        self.breakout_direction = direction

    def check_reversal(self, current_price):
        """
        检查是否发生反转（价格回到破位点）

        Args:
            current_price: 当前价格

        Returns:
            bool: 是否反转
        """
        if not self.breakout_level:
            return False

        if self.breakout_direction == 'DOWN':
            # 向下破位后，价格反弹回破位点上方
            if current_price > self.breakout_level * 1.01:
                logger.warning(f"[破位反转] 价格{current_price}回到破位点{self.breakout_level}上方")
                return True

        elif self.breakout_direction == 'UP':
            # 向上破位后，价格回落到破位点下方
            if current_price < self.breakout_level * 0.99:
                logger.warning(f"[破位反转] 价格{current_price}回到破位点{self.breakout_level}下方")
                return True

        return False

# 使用
detector = BreakoutReversalDetector()

# 08:00 BTC破位向下，破位点62,233
detector.set_breakout(62233, 'DOWN')

# 08:30 价格反弹到63,000
if detector.check_reversal(63000):
    # 63,000 > 62,233 * 1.01 (62,855)
    # 触发反转，停止发破位信号
    stop_breakout_signals()
```

### 4. 趋势延续验证

```python
class TrendContinuationValidator:
    """趋势延续验证器"""

    def __init__(self):
        self.breakout_price = None
        self.breakout_direction = None
        self.breakout_time = None

    def set_breakout(self, price, direction):
        """设置破位信息"""
        self.breakout_price = price
        self.breakout_direction = direction
        self.breakout_time = datetime.now()

    def is_trend_continuing(self, current_price):
        """
        检查趋势是否延续

        Args:
            current_price: 当前价格

        Returns:
            bool: 趋势是否延续
        """
        if not self.breakout_price:
            return False

        if self.breakout_direction == 'DOWN':
            # 向下破位后，价格应该持续走低
            # 如果当前价格比破位价格高2%，说明趋势结束
            if current_price > self.breakout_price * 1.02:
                logger.info(f"[趋势结束] 向下破位后价格反弹超2%")
                return False

        elif self.breakout_direction == 'UP':
            # 向上破位后，价格应该持续走高
            if current_price < self.breakout_price * 0.98:
                logger.info(f"[趋势结束] 向上破位后价格回落超2%")
                return False

        return True

# 使用
validator = TrendContinuationValidator()

# 08:00 破位，BTC最低59,800
validator.set_breakout(59800, 'DOWN')

# 08:30 BTC反弹到62,000
if not validator.is_trend_continuing(62000):
    # 62,000 > 59,800 * 1.02 (60,996)
    # 趋势已结束，停止发信号
    stop_breakout_signals()
```

---

## 🔄 完整收敛机制

### 综合判断

```python
class BreakoutSignalManager:
    """破位信号管理器（带收敛机制）"""

    def __init__(self):
        self.signal_with_expiry = BreakoutSignalWithExpiry()
        self.opening_limiter = BreakoutOpeningLimiter()
        self.reversal_detector = BreakoutReversalDetector()
        self.trend_validator = TrendContinuationValidator()

        self.current_session = None

    def trigger_breakout(self, direction, strength, breakout_price):
        """
        触发破位信号

        Args:
            direction: 破位方向
            strength: 破位强度
            breakout_price: 破位价格
        """
        logger.info(f"\n{'='*60}")
        logger.info(f"[破位触发] {direction} 强度{strength} 价格{breakout_price}")
        logger.info(f"{'='*60}")

        # 1. 设置信号失效时间
        self.signal_with_expiry.update_breakout(direction, strength)

        # 2. 创建开仓限制会话
        self.current_session = self.opening_limiter.start_breakout_session(
            direction,
            strength
        )

        # 3. 设置反转检测
        self.reversal_detector.set_breakout(breakout_price, direction)

        # 4. 设置趋势验证
        self.trend_validator.set_breakout(breakout_price, direction)

    def should_generate_signal(self, symbol, current_price):
        """
        判断是否应该生成破位信号

        Args:
            symbol: 币种
            current_price: 当前价格

        Returns:
            bool, str: (是否生成, 原因)
        """
        # 检查1: 信号是否失效
        if not self.signal_with_expiry.is_active():
            return False, "破位信号已失效"

        # 检查2: 是否已达开仓上限
        can_open, reason = self.opening_limiter.can_open_position(
            self.current_session,
            symbol
        )
        if not can_open:
            return False, reason

        # 检查3: 是否发生价格反转
        if self.reversal_detector.check_reversal(current_price):
            return False, "价格已反转，破位失效"

        # 检查4: 趋势是否延续
        if not self.trend_validator.is_trend_continuing(current_price):
            return False, "趋势已结束"

        # 通过所有检查
        remaining_time = self.signal_with_expiry.get_remaining_time()
        return True, f"破位信号有效 (剩余{remaining_time/60:.0f}分钟)"

    def record_opening(self, symbol):
        """记录开仓"""
        self.opening_limiter.record_opening(self.current_session, symbol)

# 使用示例
manager = BreakoutSignalManager()

# 08:00 Big4破位
manager.trigger_breakout('SHORT', 85, 59800)

# 08:05 尝试生成DOGE信号
should_gen, reason = manager.should_generate_signal('DOGE/USDT', 60000)
if should_gen:
    generate_signal('DOGE/USDT', 'SHORT')
    manager.record_opening('DOGE/USDT')
    print(f"✓ 生成信号: {reason}")
else:
    print(f"✗ 跳过信号: {reason}")

# 08:10 价格反弹到62,000
should_gen, reason = manager.should_generate_signal('SHIB/USDT', 62000)
# 返回: False, "价格已反转，破位失效"

# 12:30 (4.5小时后)
should_gen, reason = manager.should_generate_signal('PEPE/USDT', 60500)
# 返回: False, "破位信号已失效"
```

---

## 📊 收敛规则总结

### 时间维度

| 条件 | 收敛时间 | 说明 |
|------|---------|------|
| 最大有效期 | 4小时 | 超过4小时自动失效 |
| 开仓窗口 | 30分钟 | 超过30分钟不再开新仓 |
| 趋势验证 | 实时 | 价格反转立即失效 |

### 数量维度

| 破位强度 | 最大开仓次数 |
|---------|------------|
| >= 90 | 5次 |
| 80-90 | 4次 |
| 70-80 | 3次 |
| < 70 | 2次 |

### 价格维度

| 条件 | 阈值 | 说明 |
|------|------|------|
| 价格反转 | ±1% | 价格回到破位点附近 |
| 趋势终止 | ±2% | 价格反向移动超过2% |

---

## 🎯 实战示例

### 场景1: 正常收敛

```python
# 08:00 Big4破位向下
manager.trigger_breakout('SHORT', 85, 59800)
# 设置: 4小时有效期, 最多4次开仓, 30分钟窗口

# 08:01 DOGE 开仓 ✓ (第1次)
should_gen, reason = manager.should_generate_signal('DOGE/USDT', 60000)
# True, "破位信号有效 (剩余239分钟)"

# 08:05 SHIB 开仓 ✓ (第2次)
should_gen, reason = manager.should_generate_signal('SHIB/USDT', 59500)
# True, "破位信号有效 (剩余235分钟)"

# 08:10 PEPE 开仓 ✓ (第3次)
should_gen, reason = manager.should_generate_signal('PEPE/USDT', 59200)
# True, "破位信号有效 (剩余230分钟)"

# 08:15 ARB 开仓 ✓ (第4次)
should_gen, reason = manager.should_generate_signal('ARB/USDT', 58900)
# True, "破位信号有效 (剩余225分钟)"

# 08:20 MATIC 尝试开仓 ✗ (达到上限)
should_gen, reason = manager.should_generate_signal('MATIC/USDT', 58700)
# False, "已达开仓上限(4)"

# 08:35 LINK 尝试开仓 ✗ (超过窗口)
should_gen, reason = manager.should_generate_signal('LINK/USDT', 58500)
# False, "破位已过去35分钟，超过30分钟窗口"

结果: 成功开4个仓，之后自动收敛
```

### 场景2: 价格反转收敛

```python
# 08:00 Big4破位向下
manager.trigger_breakout('SHORT', 85, 59800)

# 08:05 DOGE 开仓 ✓
should_gen, reason = manager.should_generate_signal('DOGE/USDT', 60000)
# True

# 08:10 价格快速反弹到62,000
should_gen, reason = manager.should_generate_signal('SHIB/USDT', 62000)
# False, "价格已反转，破位失效"
# (62,000 > 59,800 * 1.02 = 60,996)

结果: 只开1个仓，价格反转后立即停止
```

### 场景3: 趋势终止收敛

```python
# 08:00 Big4破位向下
manager.trigger_breakout('SHORT', 85, 59800)

# 08:05 DOGE 开仓 ✓
# 08:10 SHIB 开仓 ✓

# 08:20 价格反弹到61,000
should_gen, reason = manager.should_generate_signal('PEPE/USDT', 61000)
# False, "趋势已结束"
# (61,000 > 59,800 * 1.02 = 60,996)

结果: 开2个仓后，趋势结束，停止信号
```

---

## 📝 配置建议

### 保守型

```python
CONVERGENCE_CONFIG_CONSERVATIVE = {
    'max_duration': 2 * 3600,      # 2小时失效
    'opening_window': 15 * 60,     # 15分钟窗口
    'max_openings_90+': 3,         # 极强破位最多3次
    'max_openings_80_90': 2,       # 强破位最多2次
    'reversal_threshold': 0.01,    # 1%反转
    'trend_end_threshold': 0.015   # 1.5%趋势结束
}
```

### 平衡型（推荐）

```python
CONVERGENCE_CONFIG_BALANCED = {
    'max_duration': 4 * 3600,      # 4小时失效
    'opening_window': 30 * 60,     # 30分钟窗口
    'max_openings_90+': 5,         # 极强破位最多5次
    'max_openings_80_90': 4,       # 强破位最多4次
    'max_openings_70_80': 3,       # 中等破位最多3次
    'reversal_threshold': 0.01,    # 1%反转
    'trend_end_threshold': 0.02    # 2%趋势结束
}
```

### 激进型

```python
CONVERGENCE_CONFIG_AGGRESSIVE = {
    'max_duration': 6 * 3600,      # 6小时失效
    'opening_window': 45 * 60,     # 45分钟窗口
    'max_openings_90+': 7,         # 极强破位最多7次
    'max_openings_80_90': 5,       # 强破位最多5次
    'reversal_threshold': 0.015,   # 1.5%反转
    'trend_end_threshold': 0.025   # 2.5%趋势结束
}
```

---

## 🎯 总结

### 收敛的四大维度

1. **时间收敛**
   - 最大有效期: 4小时
   - 开仓窗口: 30分钟
   - 超时自动失效

2. **数量收敛**
   - 根据强度限制开仓次数
   - 极强5次，强4次，中3次
   - 达到上限自动停止

3. **价格收敛**
   - 价格反转到破位点: 立即失效
   - 趋势反向移动2%: 停止信号
   - 动态监控价格变化

4. **逻辑收敛**
   - 每个币种只开1次
   - 同方向最多5个仓位
   - 总资金使用率80%

### 核心原则

**破位是事件，不是状态**
- 发生时快速响应
- 结束后及时收敛
- 避免过度交易

**多重保护机制**
- 时间限制
- 数量限制
- 价格验证
- 趋势确认

**自动化管理**
- 无需人工干预
- 系统自动收敛
- 降低操作风险
