# ç ´ä½ç³»ç»Ÿå¿«é€Ÿå¼€å§‹æŒ‡å—

## 5åˆ†é’Ÿå¿«é€Ÿä¸Šæ‰‹

### 1. åˆå§‹åŒ–ç³»ç»Ÿ

```python
from app.services.smart_decision_brain import SmartDecisionBrain
import ccxt

# åˆ›å»ºäº¤æ˜“æ‰€å®ä¾‹
exchange = ccxt.binance({
    'apiKey': 'your_api_key',
    'secret': 'your_secret',
    'options': {'defaultType': 'future'}
})

# æ•°æ®åº“é…ç½®
db_config = {
    'host': 'localhost',
    'port': 3306,
    'user': 'root',
    'password': 'your_password',
    'database': 'binance-data'
}

# åˆå§‹åŒ–å†³ç­–å¤§è„‘ï¼ˆè‡ªåŠ¨å¯ç”¨ç ´ä½ç³»ç»Ÿï¼‰
brain = SmartDecisionBrain(db_config, exchange=exchange)
```

### 2. æ£€æµ‹ç ´ä½

```python
# è·å–å½“å‰æŒä»“
current_positions = {
    'DOGE/USDT': {
        'side': 'LONG',
        'entry_price': 0.08,
        'quantity': 10000,
        'margin': 800,
        'unrealized_pnl': -50,
        'stop_loss': 0.079
    }
}

# æ£€æµ‹ç ´ä½
result = brain.check_breakout(current_positions)

if result['has_breakout']:
    market = result['market']
    print(f"ğŸ”¥ ç ´ä½è­¦å‘Šï¼")
    print(f"æ–¹å‘: {market['direction']}")
    print(f"å¼ºåº¦: {market['strength']}")

    # æŸ¥çœ‹æŒä»“å¤„ç†
    pos_result = result['position_result']
    if pos_result['closed']:
        print(f"å·²å¹³ä»“: {len(pos_result['closed'])}ä¸ª")
```

### 3. ä½¿ç”¨ç ´ä½åŠ æƒè¯„åˆ†

```python
# æ–¹å¼1: å®Œå…¨è‡ªåŠ¨ï¼ˆåªåšLONGï¼‰
result = brain.should_trade('WIF/USDT')

# æ–¹å¼2: æŒ‡å®šè¯„åˆ†å’Œæ–¹å‘
result = brain.should_trade(
    symbol='DOGE/USDT',
    base_score=75,
    signal_direction='SHORT'
)

if result['decision']:
    print(f"âœ… å¼€ä»“ä¿¡å·")
    print(f"æ€»åˆ†: {result['score']}")
    print(f"åŸºç¡€åˆ†: {result['base_score']}")
    print(f"ç ´ä½åŠ æƒ: {result['breakout_boost']:+d}")

    # æ‰§è¡Œäº¤æ˜“
    execute_order(result)
```

### 4. æŸ¥çœ‹ç ´ä½çŠ¶æ€

```python
status = brain.get_breakout_status()

if status['active']:
    conv = status['convergence']
    print(f"ç ´ä½æ´»åŠ¨ä¸­:")
    print(f"  æ–¹å‘: {status['market']['direction']}")
    print(f"  å¼ºåº¦: {status['market']['strength']}")
    print(f"  å·²å¼€ä»“: {conv['opened_count']}/{conv['max_openings']}")
    print(f"  å‰©ä½™æ—¶é—´: {conv['remaining_window']/60:.0f}åˆ†é’Ÿ")
```

## å®Œæ•´äº¤æ˜“å¾ªç¯ç¤ºä¾‹

```python
import time
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

def trading_loop(brain):
    """ä¸»äº¤æ˜“å¾ªç¯"""

    while True:
        try:
            # 1. è·å–å½“å‰æŒä»“
            current_positions = get_current_positions()

            # 2. æ£€æµ‹ç ´ä½ï¼ˆæ¯5åˆ†é’Ÿï¼‰
            breakout_result = brain.check_breakout(current_positions)

            if breakout_result['has_breakout']:
                market = breakout_result['market']
                logger.warning(
                    f"ğŸ”¥ Big4ç ´ä½: {market['direction']} "
                    f"å¼ºåº¦{market['strength']:.1f}"
                )

                # æŒä»“å·²è‡ªåŠ¨å¤„ç†
                pos_result = breakout_result['position_result']
                logger.info(
                    f"å¹³ä»“{len(pos_result['closed'])}ä¸ª, "
                    f"è°ƒæ•´{len(pos_result['adjusted'])}ä¸ª"
                )

            # 3. æ‰«æäº¤æ˜“æœºä¼š
            opportunities = scan_opportunities(brain)

            # 4. æ‰§è¡Œäº¤æ˜“
            for opp in opportunities:
                if should_execute(opp):
                    execute_trade(opp)

            # 5. ç­‰å¾…ä¸‹ä¸€è½®
            time.sleep(300)  # 5åˆ†é’Ÿ

        except Exception as e:
            logger.error(f"äº¤æ˜“å¾ªç¯é”™è¯¯: {e}", exc_info=True)
            time.sleep(60)


def get_current_positions():
    """è·å–å½“å‰æŒä»“"""
    # ä»äº¤æ˜“æ‰€æˆ–æ•°æ®åº“è·å–æŒä»“
    positions = {}

    # ç¤ºä¾‹æ•°æ®
    # positions['SYMBOL/USDT'] = {
    #     'side': 'LONG',
    #     'entry_price': 100.0,
    #     'quantity': 10,
    #     'margin': 1000,
    #     'unrealized_pnl': 50.0,
    #     'stop_loss': 95.0
    # }

    return positions


def scan_opportunities(brain):
    """æ‰«æäº¤æ˜“æœºä¼š"""
    opportunities = []

    # ç™½åå•å¸ç§
    watch_list = brain.whitelist_long

    for symbol in watch_list:
        try:
            # ä½¿ç”¨ç ´ä½åŠ æƒè¯„åˆ†
            result = brain.should_trade(symbol)

            if result['decision']:
                opportunities.append({
                    'symbol': symbol,
                    'score': result['score'],
                    'direction': result['direction'],
                    'breakout_boost': result.get('breakout_boost', 0),
                    'trade_params': result['trade_params']
                })

        except Exception as e:
            logger.error(f"{symbol} æ‰«æå¤±è´¥: {e}")

    # æŒ‰è¯„åˆ†æ’åº
    opportunities.sort(key=lambda x: x['score'], reverse=True)

    return opportunities


def should_execute(opportunity):
    """åˆ¤æ–­æ˜¯å¦åº”è¯¥æ‰§è¡Œäº¤æ˜“"""

    # æ£€æŸ¥1: è¯„åˆ†æ˜¯å¦è¶³å¤Ÿé«˜
    if opportunity['score'] < 30:
        return False

    # æ£€æŸ¥2: æ˜¯å¦æœ‰ç ´ä½åŠ æƒ
    has_breakout_boost = opportunity['breakout_boost'] > 0

    # æ£€æŸ¥3: é£é™©æ§åˆ¶
    # - æ£€æŸ¥å¯ç”¨èµ„é‡‘
    # - æ£€æŸ¥æŒä»“æ•°é‡
    # - æ£€æŸ¥å½“æ—¥äº¤æ˜“æ¬¡æ•°

    return True


def execute_trade(opportunity):
    """æ‰§è¡Œäº¤æ˜“"""
    logger.info(
        f"æ‰§è¡Œäº¤æ˜“: {opportunity['symbol']} "
        f"{opportunity['direction']} "
        f"è¯„åˆ†{opportunity['score']}"
    )

    # å®é™…äº¤æ˜“é€»è¾‘
    # ...


if __name__ == '__main__':
    # åˆå§‹åŒ–
    brain = SmartDecisionBrain(db_config, exchange=exchange)

    # å¯åŠ¨äº¤æ˜“å¾ªç¯
    trading_loop(brain)
```

## å¸¸è§é—®é¢˜

### Q1: å¦‚ä½•çŸ¥é“å½“å‰æ˜¯å¦æœ‰ç ´ä½ï¼Ÿ

```python
status = brain.get_breakout_status()
if status['active']:
    print("å½“å‰æœ‰ç ´ä½ä¿¡å·")
else:
    print("å½“å‰æ— ç ´ä½")
```

### Q2: ç ´ä½ä¿¡å·ä¼šæŒç»­å¤šä¹…ï¼Ÿ

ç ´ä½ä¿¡å·æœ‰ä¸¤ä¸ªæ—¶é—´é™åˆ¶ï¼š
- **å¼€ä»“çª—å£**ï¼š30åˆ†é’Ÿï¼ˆåªåœ¨è¿™ä¸ªçª—å£å†…ç”Ÿæˆæ–°ä¿¡å·ï¼‰
- **æœ€å¤§æœ‰æ•ˆæœŸ**ï¼š4å°æ—¶ï¼ˆè¶…è¿‡åå®Œå…¨å¤±æ•ˆï¼‰

```python
status = brain.get_breakout_status()
if status['active']:
    conv = status['convergence']
    print(f"å‰©ä½™å¼€ä»“çª—å£: {conv['remaining_window']/60:.0f}åˆ†é’Ÿ")
    print(f"å‰©ä½™æœ‰æ•ˆæœŸ: {conv['remaining_time']/3600:.1f}å°æ—¶")
```

### Q3: å¦‚ä½•è°ƒæ•´ç ´ä½å‚æ•°ï¼Ÿ

ç ´ä½ç³»ç»Ÿçš„å‚æ•°åœ¨åˆå§‹åŒ–æ—¶é…ç½®ï¼š

```python
from app.services.breakout_convergence import BreakoutConvergence

# è‡ªå®šä¹‰æ”¶æ•›å‚æ•°
custom_config = {
    'max_duration': 6 * 3600,      # 6å°æ—¶ï¼ˆè€Œé4å°æ—¶ï¼‰
    'opening_window': 45 * 60,     # 45åˆ†é’Ÿï¼ˆè€Œé30åˆ†é’Ÿï¼‰
    'max_openings_90+': 7,         # æœ€å¤š7æ¬¡ï¼ˆè€Œé5æ¬¡ï¼‰
    'reversal_threshold': 0.015,   # 1.5%åè½¬ï¼ˆè€Œé1%ï¼‰
}

# åˆ›å»ºè‡ªå®šä¹‰ç ´ä½ç³»ç»Ÿ
from app.services.breakout_system import BreakoutSystem
breakout_system = BreakoutSystem(exchange, convergence_config=custom_config)

# å°†è‡ªå®šä¹‰ç ´ä½ç³»ç»Ÿä¼ ç»™brain
brain.breakout_system = breakout_system
```

### Q4: å¦‚ä½•ç¦ç”¨ç ´ä½ç³»ç»Ÿï¼Ÿ

åˆå§‹åŒ–æ—¶ä¸ä¼ å…¥exchangeå³å¯ï¼š

```python
# ä¸å¯ç”¨ç ´ä½ç³»ç»Ÿ
brain = SmartDecisionBrain(db_config)

# æ£€æŸ¥ç ´ä½ç³»ç»ŸçŠ¶æ€
if brain.breakout_system is None:
    print("ç ´ä½ç³»ç»Ÿæœªå¯ç”¨")
```

### Q5: ç ´ä½æ£€æµ‹å¤±è´¥æ€ä¹ˆåŠï¼Ÿ

ç ´ä½æ£€æµ‹å¯èƒ½å› ä¸ºç½‘ç»œã€äº¤æ˜“æ‰€APIç­‰åŸå› å¤±è´¥ï¼š

```python
result = brain.check_breakout(current_positions)

if 'error' in result:
    logger.error(f"ç ´ä½æ£€æµ‹å¤±è´¥: {result['error']}")
    # ä½¿ç”¨é™çº§æ–¹æ¡ˆï¼Œä¸å½±å“æ­£å¸¸äº¤æ˜“
```

### Q6: å¦‚ä½•æµ‹è¯•ç ´ä½ç³»ç»Ÿï¼Ÿ

ä½¿ç”¨æä¾›çš„æµ‹è¯•è„šæœ¬ï¼š

```bash
# å•å…ƒæµ‹è¯•ï¼ˆä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®ï¼‰
python test_breakout_system.py

# é›†æˆæµ‹è¯•ï¼ˆå®Œæ•´æµç¨‹ï¼‰
python test_breakout_integration.py
```

### Q7: ç ´ä½ä¿¡å·ä¼šè¦†ç›–åŸæœ‰ä¿¡å·å—ï¼Ÿ

ä¸ä¼šã€‚ç ´ä½ç³»ç»Ÿåªæ˜¯**åŠ æƒ**ï¼Œä¸ä¼šå®Œå…¨è¦†ç›–ï¼š

- **åŒå‘ä¿¡å·**ï¼šåŸè¯„åˆ† + ç ´ä½åŠ æƒï¼ˆ+20~+50ï¼‰
- **åå‘ä¿¡å·**ï¼šåŸè¯„åˆ† + ç ´ä½æƒ©ç½šï¼ˆ-20~-50ï¼‰

å¦‚æœåŸè¯„åˆ†å¾ˆé«˜ï¼ˆå¦‚90+ï¼‰ï¼Œå³ä½¿æ˜¯åå‘ä¿¡å·ä¹Ÿå¯èƒ½é€šè¿‡ã€‚

### Q8: å¤šä¸ªç ´ä½æ€ä¹ˆå¤„ç†ï¼Ÿ

ç ´ä½ç³»ç»Ÿä½¿ç”¨**ä¼šè¯æœºåˆ¶**ï¼Œä¸€æ¬¡åªæœ‰ä¸€ä¸ªæ´»åŠ¨ç ´ä½ï¼š

1. æ£€æµ‹åˆ°æ–°ç ´ä½ â†’ ç»“æŸæ—§ä¼šè¯ â†’ å¯åŠ¨æ–°ä¼šè¯
2. æ–°ç ´ä½æ–¹å‘ä¸æ—§ç ´ä½ç›¸åŒ â†’ æ›´æ–°å¼ºåº¦
3. æ–°ç ´ä½æ–¹å‘ä¸æ—§ç ´ä½ç›¸å â†’ å®Œå…¨æ›¿æ¢

## è°ƒè¯•æŠ€å·§

### æŸ¥çœ‹è¯¦ç»†æ—¥å¿—

```python
import logging

# è®¾ç½®ç ´ä½ç³»ç»Ÿæ—¥å¿—çº§åˆ«
logging.getLogger('app.services.big4_breakout_detector').setLevel(logging.DEBUG)
logging.getLogger('app.services.breakout_signal_booster').setLevel(logging.DEBUG)
logging.getLogger('app.services.breakout_position_manager').setLevel(logging.DEBUG)
logging.getLogger('app.services.breakout_convergence').setLevel(logging.DEBUG)
```

### æŸ¥çœ‹ç ´ä½è¯¦æƒ…

```python
result = brain.check_breakout(current_positions)

if result['has_breakout']:
    market = result['market']

    # æŸ¥çœ‹æ¯ä¸ªBig4å¸ç§çš„è¯„åˆ†
    for symbol, detail in market['details'].items():
        if detail['is_valid']:
            print(f"{symbol}:")
            print(f"  è¯„åˆ†: {detail['score']}")
            print(f"  æ–¹å‘: {detail['direction']}")
            print(f"  ç‰¹å¾1: {detail['features']['breakout_24h']}")
            print(f"  ç‰¹å¾2: {detail['features']['candle_pattern']}")
            print(f"  ç‰¹å¾3: {detail['features']['volume_surge']}")
```

### æ‰‹åŠ¨è§¦å‘ç ´ä½ï¼ˆæµ‹è¯•ç”¨ï¼‰

```python
# ä»…ç”¨äºæµ‹è¯•ï¼ä¸è¦åœ¨ç”Ÿäº§ç¯å¢ƒä½¿ç”¨
brain.breakout_system.booster.update_breakout('SHORT', 85, 60000)
brain.breakout_system.convergence.start_breakout_session('SHORT', 85, 60000)

print("æ‰‹åŠ¨è§¦å‘ç ´ä½: SHORT å¼ºåº¦85")
```

## æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. å‡å°‘Kçº¿æŸ¥è¯¢

```python
# ç¼“å­˜Kçº¿æ•°æ®ï¼Œé¿å…é‡å¤æŸ¥è¯¢
from functools import lru_cache
from datetime import datetime, timedelta

@lru_cache(maxsize=100)
def get_klines_cached(symbol, timeframe, cache_time):
    """å¸¦ç¼“å­˜çš„Kçº¿æŸ¥è¯¢ï¼ˆæ¯5åˆ†é’Ÿæ›´æ–°ä¸€æ¬¡ï¼‰"""
    return exchange.fetch_ohlcv(symbol, timeframe, limit=288)

# ä½¿ç”¨æ—¶ä¼ å…¥å½“å‰æ—¶é—´ï¼ˆå–æ•´åˆ°5åˆ†é’Ÿï¼‰
current_time = int(datetime.now().timestamp() / 300) * 300
klines = get_klines_cached('BTC/USDT', '5m', current_time)
```

### 2. å¼‚æ­¥æ£€æµ‹

```python
import asyncio

async def check_breakout_async(brain, positions):
    """å¼‚æ­¥ç ´ä½æ£€æµ‹"""
    loop = asyncio.get_event_loop()
    result = await loop.run_in_executor(
        None,
        brain.check_breakout,
        positions
    )
    return result

# åœ¨ä¸»å¾ªç¯ä¸­ä½¿ç”¨
result = await check_breakout_async(brain, current_positions)
```

### 3. æ‰¹é‡è¯„åˆ†

```python
# å¹¶è¡Œè¯„åˆ†å¤šä¸ªå¸ç§
from concurrent.futures import ThreadPoolExecutor

def score_symbol(symbol):
    return brain.should_trade(symbol)

with ThreadPoolExecutor(max_workers=10) as executor:
    results = list(executor.map(score_symbol, watch_list))
```

## ä¸‹ä¸€æ­¥

1. âœ… é˜…è¯» [ç ´ä½ç³»ç»Ÿé›†æˆæ–‡æ¡£.md](ç ´ä½ç³»ç»Ÿé›†æˆæ–‡æ¡£.md) äº†è§£è¯¦ç»†é…ç½®
2. âœ… æŸ¥çœ‹ [ç ´ä½ç³»ç»Ÿå®ç°æ€»ç»“.md](ç ´ä½ç³»ç»Ÿå®ç°æ€»ç»“.md) äº†è§£ç³»ç»Ÿæ¶æ„
3. âœ… è¿è¡Œæµ‹è¯•è„šæœ¬éªŒè¯ç³»ç»ŸåŠŸèƒ½
4. âœ… åœ¨æ¨¡æ‹Ÿç¯å¢ƒæµ‹è¯•1-2å‘¨
5. âœ… å°èµ„é‡‘å®ç›˜éªŒè¯
6. âœ… é€æ­¥å¢åŠ ä»“ä½

ç¥äº¤æ˜“é¡ºåˆ©ï¼ğŸš€
