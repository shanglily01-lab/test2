# ç ´ä½ä¿¡å·æ·±åº¦åˆ†æ - åˆçº¦äº¤æ˜“

## æ¦‚è¿°

ç ´ä½ï¼ˆBreakout/Breakdownï¼‰æ˜¯æŠ€æœ¯åˆ†æä¸­æœ€å…³é”®çš„ä¿¡å·ä¹‹ä¸€ï¼Œä»£è¡¨ä»·æ ¼çªç ´å…³é”®çš„æ”¯æ’‘ä½æˆ–é˜»åŠ›ä½ï¼Œå¾€å¾€é¢„ç¤ºç€è¶‹åŠ¿çš„å»¶ç»­æˆ–åè½¬ã€‚

**æœ¬æ–‡æ¡£èšç„¦äºåˆçº¦äº¤æ˜“ï¼ˆFuturesï¼‰çš„ç ´ä½ä¿¡å·å®ç°ä¸ä¼˜åŒ–ã€‚**

---

## ğŸ¯ ç ´ä½çš„å®šä¹‰

### å‘ä¸Šç ´ä½ (Breakout)
**å®šä¹‰**: ä»·æ ¼å‘ä¸Šçªç ´é˜»åŠ›ä½ï¼Œè¿›å…¥æ–°çš„ä»·æ ¼åŒºé—´

**å…³é”®è¦ç´ **:
1. **é˜»åŠ›ä½**: å†å²é«˜ç‚¹ã€å¸ƒæ—ä¸Šè½¨ã€å¿ƒç†ä»·ä½
2. **çªç ´ç¡®è®¤**: å®ä½“Kçº¿æ”¶ç›˜ä»·ç«™ä¸Šé˜»åŠ›ä½
3. **æˆäº¤é‡æ”¾å¤§**: é‡ä»·é½å‡ï¼ŒéªŒè¯çªç ´æœ‰æ•ˆæ€§
4. **å›æµ‹ç¡®è®¤**: çªç ´åå›è¸©ä¸ç ´ï¼Œå½¢æˆæ–°çš„æ”¯æ’‘

**ç¤ºæ„å›¾**:
```
ä»·æ ¼çªç ´é˜»åŠ›ä½
    â†‘
    â”‚     â•±â•²    â† çªç ´æˆåŠŸ
    â”‚    â•±  â•²
â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â† é˜»åŠ›ä½ï¼ˆçªç ´å‰ï¼‰
    â”‚  â•±      â•²
    â”‚ â•±        â†“ â† å›æµ‹æ”¯æ’‘ï¼ˆçªç ´åï¼‰
    â”‚â•±
```

### å‘ä¸‹ç ´ä½ (Breakdown)
**å®šä¹‰**: ä»·æ ¼å‘ä¸‹è·Œç ´æ”¯æ’‘ä½ï¼Œè¿›å…¥æ–°çš„ä¸‹è·Œç©ºé—´

**å…³é”®è¦ç´ **:
1. **æ”¯æ’‘ä½**: å†å²ä½ç‚¹ã€å¸ƒæ—ä¸‹è½¨ã€é‡è¦æ•´æ•°ä½
2. **è·Œç ´ç¡®è®¤**: å®ä½“Kçº¿æ”¶ç›˜ä»·è·Œç ´æ”¯æ’‘ä½
3. **æˆäº¤é‡æ”¾å¤§**: ææ…Œæ€§æŠ›å”®ï¼Œé‡èƒ½å¢å¤§
4. **åå¼¹æ— åŠ›**: è·Œç ´ååå¼¹è‡³åŸæ”¯æ’‘ä½å³é‡é˜»

**ç¤ºæ„å›¾**:
```
    â•±â•²
   â•±  â•²  â† åå¼¹è‡³åŸæ”¯æ’‘é‡é˜»
  â•±    â•²â†“
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â† æ”¯æ’‘ä½ï¼ˆè·Œç ´å‰ï¼‰
      â•²  â†“
       â•² â”‚  â† ç ´ä½ä¸‹è·Œ
        â•²â”‚
         â†“
```

---

## ğŸ’¡ å½“å‰ç³»ç»Ÿçš„ç ´ä½ä¿¡å·å®ç°ï¼ˆåˆçº¦äº¤æ˜“ï¼‰

### ç°æœ‰å®ç°åˆ†æ

#### 1. æ”¯æ’‘é˜»åŠ›è¯†åˆ« (smart_decision_brain.py)
**æ–‡ä»¶**: [smart_decision_brain.py:228](app/services/smart_decision_brain.py#L228)

**æ ¸å¿ƒé€»è¾‘**:
```python
def analyze_support_resistance(klines_1h):
    """åˆ†ææ”¯æ’‘é˜»åŠ›å’Œç›ˆäºæ¯” (30åˆ†)"""

    recent = klines_1h[-100:]  # æœ€è¿‘100æ ¹1H Kçº¿
    current = klines_1h[-1]['close']

    highs = [k['high'] for k in recent]
    lows = [k['low'] for k in recent]

    # æ‰¾é˜»åŠ›ä½ = å½“å‰ä»·ä¸Šæ–¹çš„æœ€è¿‘é«˜ç‚¹
    resistance_candidates = [h for h in highs if h > current]
    resistance = min(resistance_candidates) if resistance_candidates else max(highs)

    # æ‰¾æ”¯æ’‘ä½ = å½“å‰ä»·ä¸‹æ–¹çš„æœ€è¿‘ä½ç‚¹
    support_candidates = [l for l in lows if l < current]
    support = max(support_candidates) if support_candidates else min(lows)

    # è®¡ç®—ç›ˆäºæ¯”
    upside = (resistance - current) / current * 100
    downside = (current - support) / current * 100
    risk_reward = upside / downside if downside > 0 else 0

    # è¯„åˆ†
    if risk_reward >= 2:
        score = 30  # æä½³ç›ˆäºæ¯”
    elif risk_reward >= 1.5:
        score = 15  # è‰¯å¥½ç›ˆäºæ¯”
    else:
        score = -10  # ç›ˆäºæ¯”ä¸è¶³

    return score, reasons, {
        'resistance': resistance,
        'support': support,
        'risk_reward': risk_reward
    }
```

**ç‰¹ç‚¹**:
- âœ… åŸºäºæœ€è¿‘100æ ¹1H Kçº¿
- âœ… è®¡ç®—ç›ˆäºæ¯”ä½œä¸ºè¯„åˆ†ä¾æ®
- âŒ **é—®é¢˜**ï¼šåªæ‰¾æœ€è¿‘ä¸€ä¸ªé«˜ä½ç‚¹ï¼Œå¿½ç•¥é‡è¦å†å²ä½
- âŒ **é—®é¢˜**ï¼šæ²¡æœ‰è€ƒè™‘å¤šæ¬¡è§¦åŠçš„å¼ºæ”¯æ’‘/é˜»åŠ›

---

#### 2. ç ´ä½å…¥åœºé€»è¾‘ (smart_entry_executor.py)
**æ–‡ä»¶**: [smart_entry_executor.py:240](app/services/smart_entry_executor.py#L240)

**åšå¤šç ´ä½æ¡ä»¶**:
```python
def should_enter_now(signal, new_side, current_price, baseline):
    """åˆ¤æ–­æ˜¯å¦åº”è¯¥ç«‹å³å…¥åœº"""

    if new_side == 'LONG':
        # æ¡ä»¶3: ä»·æ ¼è·Œç ´åŸºçº¿æœ€ä½ä»· â†’ ç ´ä½åšå¤š
        if current_price <= baseline['min_price'] * 0.999:
            return True, f"çªç ´åŸºçº¿æœ€ä½ä»·({baseline['min_price']:.6f})"

        # æ¡ä»¶4: å¼ºä¸Šæ¶¨è¶‹åŠ¿ + ä»·æ ¼å·²å‡è‡³p75ä»¥ä¸Š
        if baseline['trend']['direction'] == 'up' and baseline['trend']['strength'] > 0.7:
            if current_price >= baseline['p75']:
                return True, f"å¼ºä¸Šæ¶¨è¶‹åŠ¿ï¼Œé¿å…é”™è¿‡"
```

**åšç©ºç ´ä½æ¡ä»¶**:
```python
    else:  # SHORT
        # æ¡ä»¶3: ä»·æ ¼çªç ´åŸºçº¿æœ€é«˜ä»· â†’ ç ´ä½åšç©º
        if current_price >= baseline['max_price'] * 1.001:
            return True, f"çªç ´åŸºçº¿æœ€é«˜ä»·({baseline['max_price']:.6f})"

        # æ¡ä»¶4: å¼ºä¸‹è·Œè¶‹åŠ¿ + ä»·æ ¼å·²è·Œè‡³p25ä»¥ä¸‹
        if baseline['trend']['direction'] == 'down' and baseline['trend']['strength'] > 0.7:
            if current_price <= baseline['p25']:
                return True, f"å¼ºä¸‹è·Œè¶‹åŠ¿ï¼Œé¿å…é”™è¿‡"
```

**ç‰¹ç‚¹**:
- âœ… ä½¿ç”¨**åŸºçº¿ä»·æ ¼**ï¼ˆ15åˆ†é’Ÿé‡‡æ ·çš„min/maxï¼‰
- âœ… ç»“åˆ**è¶‹åŠ¿å¼ºåº¦**åˆ¤æ–­
- âœ… ä½¿ç”¨**ç™¾åˆ†ä½æ•°**ï¼ˆp25/p75ï¼‰é¿å…é”™è¿‡æœºä¼š
- âŒ **é—®é¢˜**ï¼šç ´ä½ç¡®è®¤ä¸å……åˆ†ï¼ˆå•æ¬¡çªç ´å³å…¥åœºï¼‰
- âŒ **é—®é¢˜**ï¼šæ²¡æœ‰é‡èƒ½éªŒè¯

---

## ğŸ” å½“å‰å®ç°çš„é—®é¢˜ä¸æ”¹è¿›ç©ºé—´

### âŒ é—®é¢˜1: æ”¯æ’‘é˜»åŠ›è¯†åˆ«è¿‡äºç®€å•

**å½“å‰é€»è¾‘**ï¼ˆæ¥è‡ªsmart_decision_brain.pyï¼‰:
```python
def analyze_support_resistance(klines_1h):
    highs = [k['high'] for k in klines]
    lows = [k['low'] for k in klines]

    # é˜»åŠ›ä½ = å½“å‰ä»·ä¸Šæ–¹çš„æœ€è¿‘é«˜ç‚¹
    resistance_candidates = [h for h in highs if h > current]
    resistance = min(resistance_candidates)

    # æ”¯æ’‘ä½ = å½“å‰ä»·ä¸‹æ–¹çš„æœ€è¿‘ä½ç‚¹
    support_candidates = [l for l in lows if l < current]
    support = max(support_candidates)
```

**é—®é¢˜**:
- âŒ åªæ‰¾æœ€è¿‘çš„é«˜ä½ç‚¹ï¼Œå¿½ç•¥äº†**é‡è¦çš„å†å²å…³é”®ä½**
- âŒ æ²¡æœ‰è€ƒè™‘**å¤šæ¬¡è§¦åŠ**å½¢æˆçš„å¼ºæ”¯æ’‘/é˜»åŠ›
- âŒ æ²¡æœ‰è€ƒè™‘**æ•´æ•°å…³å£**ï¼ˆå¦‚10000ã€50000ç­‰å¿ƒç†ä»·ä½ï¼‰
- âŒ æ²¡æœ‰**æ—¶é—´ç»´åº¦**ï¼ˆè¿‘æœŸçš„ç‚¹æ›´é‡è¦ï¼‰

**æ”¹è¿›æ–¹æ¡ˆ**:
```python
def find_key_support_resistance(klines, current_price):
    """è¯†åˆ«å…³é”®æ”¯æ’‘é˜»åŠ›ä½"""

    # 1. æ‰¾åˆ°æ‰€æœ‰é«˜ä½ç‚¹
    highs = find_local_peaks(klines, 'high')
    lows = find_local_troughs(klines, 'low')

    # 2. èšç±»åˆ†æï¼ˆä»·æ ¼æ¥è¿‘çš„ç‚¹å½’ä¸ºä¸€ç»„ï¼‰
    resistance_clusters = cluster_price_levels(
        [h for h in highs if h['price'] > current_price],
        tolerance=0.01  # 1%è¯¯å·®èŒƒå›´å†…ç®—åŒä¸€é˜»åŠ›ä½
    )

    support_clusters = cluster_price_levels(
        [l for l in lows if l['price'] < current_price],
        tolerance=0.01
    )

    # 3. è®¡ç®—å¼ºåº¦ï¼ˆè§¦åŠæ¬¡æ•° Ã— æ—¶é—´è¡°å‡ï¼‰
    for cluster in resistance_clusters:
        cluster['strength'] = sum([
            1.0 / (1 + days_ago * 0.1)  # è¶Šè¿‘çš„ç‚¹æƒé‡è¶Šå¤§
            for point in cluster['points']
        ])

    # 4. è€ƒè™‘æ•´æ•°å…³å£
    round_numbers = find_round_numbers(current_price)

    # 5. è¿”å›æœ€å¼ºçš„æ”¯æ’‘é˜»åŠ›ä½
    key_resistance = max(resistance_clusters, key=lambda x: x['strength'])
    key_support = max(support_clusters, key=lambda x: x['strength'])

    return key_resistance, key_support, round_numbers
```

---

### âŒ é—®é¢˜2: ç ´ä½ç¡®è®¤ä¸å……åˆ†

**å½“å‰é€»è¾‘**:
```python
# åªåˆ¤æ–­ä»·æ ¼æ˜¯å¦é«˜äºä¸Šè½¨
if current_price > upper:
    score += 40
```

**é—®é¢˜**:
- âŒ å•æ ¹Kçº¿å°±åˆ¤å®šç ´ä½ï¼Œå®¹æ˜“å‡ºç°**å‡çªç ´**
- âŒ æ²¡æœ‰**æ”¶ç›˜ä»·ç¡®è®¤**ï¼ˆå°¾ç›˜æ‹‰å‡ä½†æ”¶ç›˜å›è½ï¼‰
- âŒ æ²¡æœ‰**æŒç»­æ€§éªŒè¯**ï¼ˆçªç ´åç«‹å³å›è½ï¼‰
- âŒ æ²¡æœ‰**å›æµ‹ç¡®è®¤**ï¼ˆçªç ´åå›è¸©æ”¯æ’‘ï¼‰

**æ”¹è¿›æ–¹æ¡ˆ**:
```python
def confirm_breakout(klines, resistance_level):
    """å¤šç»´åº¦ç¡®è®¤ç ´ä½"""

    current = klines[-1]
    prev = klines[-2]

    confirmations = 0
    reasons = []

    # 1. æ”¶ç›˜ä»·ç¡®è®¤ï¼ˆ30%æƒé‡ï¼‰
    if current['close'] > resistance_level:
        confirmations += 0.3
        reasons.append("æ”¶ç›˜ç«™ä¸Šé˜»åŠ›ä½")

    # 2. å®ä½“çªç ´ç¡®è®¤ï¼ˆ20%æƒé‡ï¼‰
    body_top = max(current['open'], current['close'])
    if body_top > resistance_level:
        confirmations += 0.2
        reasons.append("å®ä½“çªç ´")

    # 3. è¿ç»­ç¡®è®¤ï¼ˆ30%æƒé‡ï¼‰
    if prev['close'] > resistance_level * 0.99:  # å‰ä¸€æ ¹ä¹Ÿåœ¨é˜»åŠ›ä½é™„è¿‘
        confirmations += 0.3
        reasons.append("è¿ç»­ç«™ç¨³")

    # 4. å¼ºåŠ›çªç ´ï¼ˆ20%æƒé‡ï¼‰
    distance = (current['close'] - resistance_level) / resistance_level
    if distance > 0.02:  # çªç ´2%ä»¥ä¸Š
        confirmations += 0.2
        reasons.append(f"å¼ºåŠ›çªç ´{distance*100:.1f}%")

    # 5. å›æµ‹ç¡®è®¤ï¼ˆé¢å¤–åŠ åˆ†ï¼‰
    if len(klines) >= 5:
        # æ£€æŸ¥çªç ´åæ˜¯å¦æœ‰å›æµ‹
        recent_lows = [k['low'] for k in klines[-5:-1]]
        if any(low < resistance_level * 1.01 and low > resistance_level * 0.98
               for low in recent_lows):
            confirmations += 0.1
            reasons.append("å›æµ‹æˆåŠŸ")

    return confirmations, reasons
```

---

### âŒ é—®é¢˜3: æˆäº¤é‡åˆ†æå•ä¸€

**å½“å‰é€»è¾‘**:
```python
# åªçœ‹å½“å‰æˆäº¤é‡æ˜¯å¦æ”¾å¤§1.5å€
if current_volume > avg_volume * 1.5:
    score += 30
```

**é—®é¢˜**:
- âŒ æ²¡æœ‰åŒºåˆ†**å¢é‡ä¹°ç›˜**è¿˜æ˜¯**å¢é‡å–ç›˜**
- âŒ æ²¡æœ‰è€ƒè™‘**é‡èƒ½çš„æŒç»­æ€§**
- âŒ æ²¡æœ‰åˆ†æ**é‡ä»·èƒŒç¦»**
- âŒ æ²¡æœ‰å¯¹æ¯”**å†å²çªç ´çš„é‡èƒ½**

**æ”¹è¿›æ–¹æ¡ˆ**:
```python
def analyze_volume_breakout(klines, resistance_level):
    """é‡èƒ½åˆ†æ"""

    current = klines[-1]
    avg_volume_20 = sum([k['volume'] for k in klines[-20:-1]]) / 19

    score = 0
    reasons = []

    # 1. åŸºç¡€é‡èƒ½æ”¾å¤§ï¼ˆ30åˆ†ï¼‰
    volume_ratio = current['volume'] / avg_volume_20
    if volume_ratio > 2.0:
        score += 30
        reasons.append(f"å·¨é‡{volume_ratio:.1f}x")
    elif volume_ratio > 1.5:
        score += 20
        reasons.append(f"æ”¾é‡{volume_ratio:.1f}x")

    # 2. ä¹°å–åŠ›é‡åˆ†æï¼ˆ20åˆ†ï¼‰
    # ä¸Šæ¶¨å¹…åº¦ vs æˆäº¤é‡ = ä¹°ç›˜å¼ºåº¦
    price_change = (current['close'] - current['open']) / current['open']
    if price_change > 0:
        buying_pressure = price_change * volume_ratio
        if buying_pressure > 0.05:  # å¼ºåŠ›ä¹°ç›˜
            score += 20
            reasons.append("å¼ºåŠ›ä¹°ç›˜")

    # 3. æŒç»­æ”¾é‡ï¼ˆ20åˆ†ï¼‰
    recent_volumes = [k['volume'] for k in klines[-3:]]
    if all(v > avg_volume_20 * 1.2 for v in recent_volumes):
        score += 20
        reasons.append("æŒç»­æ”¾é‡")

    # 4. å†å²å¯¹æ¯”ï¼ˆ10åˆ†ï¼‰
    # å½“å‰é‡èƒ½æ˜¯å¦è¶…è¿‡å†å²çªç ´æ—¶çš„é‡èƒ½
    historical_breakouts = find_historical_breakouts(klines)
    if historical_breakouts:
        max_breakout_volume = max([b['volume'] for b in historical_breakouts])
        if current['volume'] > max_breakout_volume:
            score += 10
            reasons.append("è¶…å†å²çªç ´é‡")

    return score, reasons
```

---

### âŒ é—®é¢˜4: ç¼ºå°‘å‡çªç ´è¯†åˆ«

**å½“å‰é—®é¢˜**:
- æ²¡æœ‰è¯†åˆ«**ç‰›å¸‚é™·é˜±**ï¼ˆBull Trapï¼‰çš„æœºåˆ¶
- æ²¡æœ‰è¯†åˆ«**ç†Šå¸‚é™·é˜±**ï¼ˆBear Trapï¼‰çš„æœºåˆ¶

**æ”¹è¿›æ–¹æ¡ˆ**:
```python
def detect_false_breakout(klines, level, direction='up'):
    """è¯†åˆ«å‡çªç ´"""

    # å‡çªç ´ç‰¹å¾ï¼š
    # 1. çªç ´åç«‹å³å›è½
    # 2. æˆäº¤é‡ä¸è¶³
    # 3. é•¿ä¸Šå½±çº¿ï¼ˆå‘ä¸Šå‡çªç ´ï¼‰æˆ–é•¿ä¸‹å½±çº¿ï¼ˆå‘ä¸‹å‡çªç ´ï¼‰

    current = klines[-1]
    prev = klines[-2]

    false_signals = []

    if direction == 'up':
        # å‘ä¸Šå‡çªç ´æ£€æµ‹
        if current['high'] > level:
            # ç‰¹å¾1: æ”¶ç›˜ä»·è·Œå›é˜»åŠ›ä½ä¸‹æ–¹
            if current['close'] < level:
                false_signals.append("æ”¶ç›˜è·Œå›")

            # ç‰¹å¾2: é•¿ä¸Šå½±çº¿
            upper_shadow = current['high'] - max(current['open'], current['close'])
            body_size = abs(current['close'] - current['open'])
            if upper_shadow > body_size * 2:
                false_signals.append("é•¿ä¸Šå½±çº¿")

            # ç‰¹å¾3: é‡èƒ½ä¸è¶³
            avg_volume = sum([k['volume'] for k in klines[-20:-1]]) / 19
            if current['volume'] < avg_volume:
                false_signals.append("é‡èƒ½ä¸è¶³")

            # ç‰¹å¾4: ä¸‹ä¸€æ ¹ç«‹å³å›è½
            if len(klines) > 1:
                next_k = klines[-1]
                if next_k['close'] < level * 0.98:
                    false_signals.append("ç«‹å³å›è½")

    return len(false_signals) >= 2, false_signals
```

---

## ğŸš€ å¢å¼ºç‰ˆç ´ä½ä¿¡å·ç³»ç»Ÿè®¾è®¡

### æ¶æ„è®¾è®¡

```
ç ´ä½ä¿¡å·æ£€æµ‹ç³»ç»Ÿ
    â”‚
    â”œâ”€ 1. æ”¯æ’‘é˜»åŠ›è¯†åˆ«æ¨¡å—
    â”‚     â”œâ”€ å†å²é«˜ä½ç‚¹èšç±»
    â”‚     â”œâ”€ å¤šæ¬¡è§¦åŠå¼ºåŒ–
    â”‚     â”œâ”€ æ•´æ•°å…³å£æ£€æµ‹
    â”‚     â””â”€ æ—¶é—´è¡°å‡æƒé‡
    â”‚
    â”œâ”€ 2. ç ´ä½ç¡®è®¤æ¨¡å—
    â”‚     â”œâ”€ æ”¶ç›˜ä»·ç¡®è®¤
    â”‚     â”œâ”€ å®ä½“çªç ´ç¡®è®¤
    â”‚     â”œâ”€ è¿ç»­æ€§ç¡®è®¤
    â”‚     â”œâ”€ å¼ºåº¦ç¡®è®¤
    â”‚     â””â”€ å›æµ‹ç¡®è®¤
    â”‚
    â”œâ”€ 3. é‡èƒ½åˆ†ææ¨¡å—
    â”‚     â”œâ”€ é‡èƒ½å€æ•°
    â”‚     â”œâ”€ ä¹°å–åŠ›é‡
    â”‚     â”œâ”€ æŒç»­æ”¾é‡
    â”‚     â””â”€ å†å²å¯¹æ¯”
    â”‚
    â”œâ”€ 4. å‡çªç ´è¿‡æ»¤æ¨¡å—
    â”‚     â”œâ”€ ç‰›å¸‚é™·é˜±è¯†åˆ«
    â”‚     â”œâ”€ ç†Šå¸‚é™·é˜±è¯†åˆ«
    â”‚     â”œâ”€ ä¸Šä¸‹å½±çº¿åˆ†æ
    â”‚     â””â”€ é‡ä»·èƒŒç¦»æ£€æµ‹
    â”‚
    â””â”€ 5. ç»¼åˆè¯„åˆ†æ¨¡å—
          â”œâ”€ å¤šå› å­åŠ æƒ
          â”œâ”€ ç½®ä¿¡åº¦è®¡ç®—
          â””â”€ ä¿¡å·ç­‰çº§åˆ’åˆ†
```

---

## ğŸ“Š å¢å¼ºç‰ˆè¯„åˆ†ä½“ç³»

### æ»¡åˆ†ï¼š100åˆ†

#### 1. æ”¯æ’‘é˜»åŠ›æœ‰æ•ˆæ€§ï¼ˆ25åˆ†ï¼‰
- **å¼ºæ”¯æ’‘é˜»åŠ›ä½**ï¼ˆ25åˆ†ï¼‰ï¼šå¤šæ¬¡è§¦åŠï¼ˆ>=3æ¬¡ï¼‰ï¼Œæ—¶é—´è·¨åº¦é•¿
- **ä¸­ç­‰æ”¯æ’‘é˜»åŠ›ä½**ï¼ˆ15åˆ†ï¼‰ï¼š2æ¬¡è§¦åŠï¼Œè¿‘æœŸå½¢æˆ
- **å¼±æ”¯æ’‘é˜»åŠ›ä½**ï¼ˆ5åˆ†ï¼‰ï¼šå•æ¬¡é«˜ä½ç‚¹

#### 2. ç ´ä½ç¡®è®¤åº¦ï¼ˆ30åˆ†ï¼‰
- **æ”¶ç›˜ä»·ç¡®è®¤**ï¼ˆ10åˆ†ï¼‰ï¼šå®ä½“æ”¶ç›˜ä»·çªç ´
- **è¿ç»­ç¡®è®¤**ï¼ˆ10åˆ†ï¼‰ï¼šè¿ç»­2-3æ ¹Kçº¿ç«™ç¨³
- **å¼ºåŠ›çªç ´**ï¼ˆ5åˆ†ï¼‰ï¼šçªç ´å¹…åº¦>2%
- **å›æµ‹æˆåŠŸ**ï¼ˆ5åˆ†ï¼‰ï¼šçªç ´åå›è¸©ä¸ç ´

#### 3. é‡èƒ½æ”¯æŒåº¦ï¼ˆ25åˆ†ï¼‰
- **å·¨é‡çªç ´**ï¼ˆ25åˆ†ï¼‰ï¼šæˆäº¤é‡>2å€å‡é‡
- **æ”¾é‡çªç ´**ï¼ˆ15åˆ†ï¼‰ï¼šæˆäº¤é‡1.5-2å€å‡é‡
- **æŒç»­æ”¾é‡**ï¼ˆ+5åˆ†ï¼‰ï¼šè¿ç»­3æ ¹æ”¾é‡
- **è¶…å†å²é‡**ï¼ˆ+5åˆ†ï¼‰ï¼šè¶…è¿‡å†å²çªç ´é‡

#### 4. è¶‹åŠ¿é…åˆåº¦ï¼ˆ15åˆ†ï¼‰
- **è¶‹åŠ¿ä¸€è‡´**ï¼ˆ15åˆ†ï¼‰ï¼šçªç ´æ–¹å‘ä¸è¶‹åŠ¿ä¸€è‡´
- **è¶‹åŠ¿èƒŒç¦»**ï¼ˆ-10åˆ†ï¼‰ï¼šé€†è¶‹åŠ¿çªç ´

#### 5. å‡çªç ´é£é™©ï¼ˆ-20åˆ†ï¼‰
- **é•¿å½±çº¿**ï¼ˆ-10åˆ†ï¼‰ï¼šçªç ´åç•™é•¿å½±çº¿
- **é‡èƒ½ä¸è¶³**ï¼ˆ-5åˆ†ï¼‰ï¼šæˆäº¤é‡ä½äºå‡é‡
- **ç«‹å³å›è½**ï¼ˆ-5åˆ†ï¼‰ï¼šçªç ´åå¿«é€Ÿå›è½

### ä¿¡å·ç­‰çº§

```python
if score >= 80:
    level = "Açº§ - å¼ºçƒˆçªç ´"  # é«˜èƒœç‡ï¼Œå¤§èƒ†å¼€ä»“
elif score >= 60:
    level = "Bçº§ - æœ‰æ•ˆçªç ´"  # ä¸­ç­‰èƒœç‡ï¼Œæ­£å¸¸å¼€ä»“
elif score >= 40:
    level = "Cçº§ - å¼±çªç ´"    # ä½èƒœç‡ï¼Œå°ä»“ä½è¯•æ¢
else:
    level = "Dçº§ - æ— æ•ˆçªç ´"  # ä¸å¼€ä»“æˆ–è§‚æœ›
```

---

## ğŸ’¼ å®æˆ˜åº”ç”¨ç­–ç•¥

### åšå¤šç­–ç•¥ï¼ˆå‘ä¸Šç ´ä½ï¼‰

```python
def breakout_long_strategy(symbol):
    """å‘ä¸Šç ´ä½åšå¤šç­–ç•¥"""

    # 1. è¯†åˆ«å…³é”®é˜»åŠ›ä½
    resistance, support, round_numbers = find_key_levels(symbol)

    # 2. æ£€æµ‹ç ´ä½
    if current_price > resistance['price']:

        # 3. ç ´ä½ç¡®è®¤
        confirmation, reasons = confirm_breakout(klines, resistance['price'])

        if confirmation >= 0.6:  # 60%ç¡®è®¤åº¦

            # 4. é‡èƒ½éªŒè¯
            volume_score, vol_reasons = analyze_volume_breakout(klines, resistance['price'])

            if volume_score >= 15:  # è‡³å°‘ä¸­ç­‰æ”¾é‡

                # 5. å‡çªç ´è¿‡æ»¤
                is_false, false_reasons = detect_false_breakout(klines, resistance['price'], 'up')

                if not is_false:
                    # âœ… æ»¡è¶³æ‰€æœ‰æ¡ä»¶ï¼Œå¼€å¤šä»“

                    # æ­¢æŸï¼šç ´ä½å‰çš„é˜»åŠ›ä½ä¸‹æ–¹
                    stop_loss = resistance['price'] * 0.98

                    # æ­¢ç›ˆï¼šä¸‹ä¸€ä¸ªé˜»åŠ›ä½
                    next_resistance = find_next_resistance(resistance['price'])
                    take_profit = next_resistance['price']

                    return {
                        'action': 'LONG',
                        'entry': current_price,
                        'stop_loss': stop_loss,
                        'take_profit': take_profit,
                        'confidence': confirmation,
                        'reasons': reasons + vol_reasons
                    }

    return None
```

### åšç©ºç­–ç•¥ï¼ˆå‘ä¸‹ç ´ä½ï¼‰

```python
def breakdown_short_strategy(symbol):
    """å‘ä¸‹ç ´ä½åšç©ºç­–ç•¥"""

    # 1. è¯†åˆ«å…³é”®æ”¯æ’‘ä½
    resistance, support, round_numbers = find_key_levels(symbol)

    # 2. æ£€æµ‹ç ´ä½
    if current_price < support['price']:

        # 3. ç ´ä½ç¡®è®¤
        confirmation, reasons = confirm_breakdown(klines, support['price'])

        if confirmation >= 0.6:

            # 4. é‡èƒ½éªŒè¯ï¼ˆææ…Œæ€§æŠ›å”®ï¼‰
            volume_score, vol_reasons = analyze_volume_breakdown(klines, support['price'])

            if volume_score >= 15:

                # 5. å‡çªç ´è¿‡æ»¤
                is_false, false_reasons = detect_false_breakout(klines, support['price'], 'down')

                if not is_false:
                    # âœ… æ»¡è¶³æ‰€æœ‰æ¡ä»¶ï¼Œå¼€ç©ºä»“

                    # æ­¢æŸï¼šç ´ä½å‰çš„æ”¯æ’‘ä½ä¸Šæ–¹
                    stop_loss = support['price'] * 1.02

                    # æ­¢ç›ˆï¼šä¸‹ä¸€ä¸ªæ”¯æ’‘ä½
                    next_support = find_next_support(support['price'])
                    take_profit = next_support['price']

                    return {
                        'action': 'SHORT',
                        'entry': current_price,
                        'stop_loss': stop_loss,
                        'take_profit': take_profit,
                        'confidence': confirmation,
                        'reasons': reasons + vol_reasons
                    }

    return None
```

---

## ğŸ“ˆ ç ´ä½åçš„ä»“ä½ç®¡ç†

### ä»“ä½åˆ†é…ç­–ç•¥

```python
def calculate_position_size(breakout_score, confidence):
    """æ ¹æ®ç ´ä½è´¨é‡å†³å®šä»“ä½å¤§å°"""

    base_position = 100  # åŸºç¡€ä»“ä½100 USDT

    if breakout_score >= 80 and confidence >= 0.8:
        # Açº§çªç ´ï¼šæ»¡ä»“
        multiplier = 1.0
    elif breakout_score >= 60 and confidence >= 0.6:
        # Bçº§çªç ´ï¼š70%ä»“ä½
        multiplier = 0.7
    elif breakout_score >= 40 and confidence >= 0.5:
        # Cçº§çªç ´ï¼š30%ä»“ä½
        multiplier = 0.3
    else:
        # ä¸å¼€ä»“
        return 0

    return base_position * multiplier
```

### åŠ ä»“ç­–ç•¥

```python
def pyramid_strategy(position, current_price, entry_price, resistance):
    """é‡‘å­—å¡”åŠ ä»“"""

    # ç ´ä½åæ¯ä¸Šæ¶¨2%åŠ ä»“ä¸€æ¬¡
    profit_pct = (current_price - entry_price) / entry_price

    if profit_pct >= 0.02 and profit_pct < 0.04:
        # ç¬¬ä¸€æ¬¡åŠ ä»“ï¼š50%
        add_size = position['initial_size'] * 0.5
    elif profit_pct >= 0.04 and profit_pct < 0.06:
        # ç¬¬äºŒæ¬¡åŠ ä»“ï¼š25%
        add_size = position['initial_size'] * 0.25
    else:
        add_size = 0

    # æ­¢æŸç§»è‡³æˆæœ¬ä»·
    if profit_pct >= 0.02:
        new_stop_loss = entry_price

    return add_size, new_stop_loss
```

---

## ğŸ“ æ€»ç»“

### å…³é”®è¦ç‚¹

1. **æ”¯æ’‘é˜»åŠ›è¯†åˆ«**ï¼šå¤šæ¬¡è§¦åŠ > å•æ¬¡é«˜ä½ç‚¹
2. **ç ´ä½ç¡®è®¤**ï¼šå¤šç»´åº¦éªŒè¯ > å•Kçº¿åˆ¤æ–­
3. **é‡èƒ½åˆ†æ**ï¼šä¹°å–åŠ›é‡ > å•çº¯æˆäº¤é‡
4. **å‡çªç ´è¿‡æ»¤**ï¼šé•¿å½±çº¿ + é‡èƒ½ä¸è¶³ = å‡çªç ´
5. **ä»“ä½ç®¡ç†**ï¼šç ´ä½è´¨é‡å†³å®šä»“ä½å¤§å°

### æ”¹è¿›ä¼˜å…ˆçº§

1. **é«˜ä¼˜å…ˆçº§**ï¼šæ”¯æ’‘é˜»åŠ›è¯†åˆ«ï¼ˆèšç±»ç®—æ³•ï¼‰
2. **é«˜ä¼˜å…ˆçº§**ï¼šç ´ä½ç¡®è®¤æœºåˆ¶ï¼ˆå¤šç»´åº¦ï¼‰
3. **ä¸­ä¼˜å…ˆçº§**ï¼šé‡èƒ½åˆ†æå¢å¼ºï¼ˆä¹°å–åŠ›é‡ï¼‰
4. **ä¸­ä¼˜å…ˆçº§**ï¼šå‡çªç ´è¿‡æ»¤ï¼ˆç‰›ç†Šé™·é˜±ï¼‰
5. **ä½ä¼˜å…ˆçº§**ï¼šå›æµ‹ç¡®è®¤ï¼ˆéœ€è¦ç­‰å¾…ï¼‰

### å®ç°å»ºè®®

å»ºè®®åˆ›å»ºç‹¬ç«‹çš„ç ´ä½ä¿¡å·æ¨¡å—ï¼š
```
app/services/breakout_detector.py
    â”œâ”€ BreakoutDetectorç±»
    â”œâ”€ SupportResistanceFinderç±»
    â”œâ”€ VolumeAnalyzerç±»
    â”œâ”€ FalseBreakoutFilterç±»
    â””â”€ BreakoutScorerç±»
```

è¿™æ ·å¯ä»¥ä¸ç°æœ‰çš„smart_decision_brainé›†æˆï¼Œä½œä¸ºä¸€ä¸ªç‹¬ç«‹çš„é«˜æƒé‡ä¿¡å·æºã€‚
