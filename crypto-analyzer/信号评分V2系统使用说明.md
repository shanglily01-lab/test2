# 🎯 信号评分V2系统使用说明

## 📋 系统概述

信号评分V2系统是一个基于数据库预计算评分的智能信号过滤系统。它从MySQL数据库的`coin_kline_scores`表读取实时评分，根据可配置的阈值对交易信号进行过滤和质量评估。

### 核心特性

- ✅ **实时评分**: 从数据库读取每5分钟自动更新的K线评分
- ✅ **智能过滤**: 根据评分阈值自动过滤低质量信号
- ✅ **共振检查**: 支持代币评分与Big4评分联动验证
- ✅ **灵活配置**: 所有阈值和规则均可在config.yaml中配置
- ✅ **市场洞察**: 提供市场整体情绪分析和Top交易对查询

## 🚀 快速开始

### 1. 确保评分数据库已运行

```bash
# 检查MySQL评分调度是否正常
mysql -u root -p binance-data -e "SELECT COUNT(*) FROM coin_kline_scores;"

# 如果为0，则需要先设置评分系统（参考《共振评分系统使用说明.md》）
```

### 2. 配置评分过滤规则（config.yaml）

```yaml
signals:
  resonance_filter:
    enabled: true              # 启用评分过滤
    min_symbol_score: 15       # 代币最低评分（绝对值）
    min_big4_score: 10         # Big4最低评分（绝对值）
    require_same_direction: true  # 要求方向一致
    resonance_threshold: 25    # 共振总分阈值（绝对值之和）
```

### 3. 在代码中使用V2评分服务

```python
from app.services.signal_score_v2_service import SignalScoreV2Service
import yaml
import os

# 加载配置
with open('config.yaml', 'r', encoding='utf-8') as f:
    config = yaml.safe_load(f)

# 数据库配置
db_config = {
    'host': os.getenv('DB_HOST', 'localhost'),
    'port': int(os.getenv('DB_PORT', 3306)),
    'user': os.getenv('DB_USER', 'root'),
    'password': os.getenv('DB_PASSWORD', ''),
    'database': os.getenv('DB_NAME', 'binance-data')
}

# 获取评分配置
score_config = config.get('signals', {}).get('resonance_filter', {})

# 初始化服务
service = SignalScoreV2Service(db_config, score_config)

# 检查信号是否通过评分过滤
symbol = 'DOGE/USDT'
signal_direction = 'LONG'

result = service.check_score_filter(symbol, signal_direction)

if result['passed']:
    print(f"✅ {symbol} 信号通过过滤")
    print(f"原因: {result['reason']}")
    # 执行交易逻辑...
else:
    print(f"❌ {symbol} 信号未通过过滤")
    print(f"原因: {result['reason']}")
    # 跳过此信号

service.close()
```

## 📊 主要功能

### 1. 获取代币评分

```python
score = service.get_coin_score('BTC/USDT')

if score:
    print(f"总分: {score['total_score']}")
    print(f"1H评分: {score['h1_score']}")
    print(f"15M评分: {score['m15_score']}")
    print(f"方向: {score['direction']}")
    print(f"强度: {score['strength_level']}")
```

返回字段说明：
```python
{
    'symbol': 'BTC/USDT',
    'total_score': 40,           # 总分
    'main_score': 30,            # 主分（1H + 15M）
    'five_m_bonus': 10,          # 5M反向加分
    'h1_score': 10,              # 1H评分
    'h1_bullish_count': 6,       # 1H阳线数
    'h1_bearish_count': 4,       # 1H阴线数
    'h1_level': '弱多',          # 1H级别
    'm15_score': 20,             # 15M评分
    'm15_bullish_count': 7,      # 15M阳线数
    'm15_bearish_count': 3,      # 15M阴线数
    'm15_level': '中多',         # 15M级别
    'm5_bullish_count': 0,       # 5M阳线数
    'm5_bearish_count': 3,       # 5M阴线数
    'direction': 'LONG',         # 方向（LONG/SHORT/NEUTRAL）
    'strength_level': 'strong',  # 强度（strong/medium/weak）
    'reason': '...',             # 详细说明
    'updated_at': datetime(...)  # 更新时间
}
```

### 2. 检查信号评分过滤

```python
result = service.check_score_filter(symbol='DOGE/USDT', signal_direction='LONG')

print(f"通过: {result['passed']}")
print(f"原因: {result['reason']}")
print(f"代币评分: {result['coin_score']}")
print(f"Big4评分: {result['big4_score']}")
print(f"详细信息: {result['details']}")
```

过滤规则（按顺序检查）：

1. **代币评分达标**: `abs(coin_score) >= min_symbol_score`
2. **Big4评分达标**: `abs(big4_score) >= min_big4_score` （如果有Big4数据）
3. **方向一致**: `coin_direction == signal_direction` 且 `big4_direction == signal_direction`
4. **共振总分达标**: `abs(coin_score) + abs(big4_score) >= resonance_threshold`

### 3. 查询Top交易对

```python
# Top 10做多机会（强多，评分>=20）
long_symbols = service.get_top_scored_symbols(
    direction='LONG',
    min_score=20,
    limit=10
)

for s in long_symbols:
    print(f"{s['symbol']} - 总分: {s['total_score']}")

# Top 10做空机会（强空，评分>=20）
short_symbols = service.get_top_scored_symbols(
    direction='SHORT',
    min_score=20,
    limit=10
)
```

### 4. 市场情绪分析

```python
sentiment = service.get_market_sentiment()

print(f"市场情绪: {sentiment['sentiment']}")
print(f"总计: {sentiment['total']} 个交易对")
print(f"强多: {sentiment['long_strong']} 个")
print(f"中多: {sentiment['long_medium']} 个")
print(f"强空: {sentiment['short_strong']} 个")
print(f"中空: {sentiment['short_medium']} 个")
print(f"中性: {sentiment['neutral']} 个")
```

市场情绪判断：
- **强烈偏多**: 多头数量 > 空头数量 × 1.5
- **强烈偏空**: 空头数量 > 多头数量 × 1.5
- **偏多**: 多头数量 > 空头数量
- **偏空**: 空头数量 > 多头数量
- **均衡**: 多空接近

## ⚙️ 配置参数详解

### config.yaml 配置项

```yaml
signals:
  resonance_filter:
    # 总开关
    enabled: true              # true=启用评分过滤，false=关闭（所有信号直接通过）

    # 代币评分阈值
    min_symbol_score: 15       # 代币最低评分（绝对值）
                               # 建议: 15-25（15=宽松，25=严格）

    # Big4评分阈值
    min_big4_score: 10         # Big4最低评分（绝对值）
                               # 建议: 10-20（10=宽松，20=严格）

    # 方向匹配
    require_same_direction: true  # 是否要求代币、Big4、信号三者方向一致
                                  # true=严格模式，false=宽松模式

    # 共振阈值
    resonance_threshold: 25    # 代币评分 + Big4评分的绝对值之和
                               # 建议: 25-40（25=宽松，40=严格）
```

### 配置策略建议

#### 1. 激进策略（捕捉更多机会）

```yaml
resonance_filter:
  enabled: true
  min_symbol_score: 10        # 较低
  min_big4_score: 5           # 较低
  require_same_direction: false  # 不强制方向一致
  resonance_threshold: 15     # 较低
```

**适用场景**: 震荡市、寻找短线机会

#### 2. 平衡策略（推荐）

```yaml
resonance_filter:
  enabled: true
  min_symbol_score: 15        # 中等
  min_big4_score: 10          # 中等
  require_same_direction: true   # 强制方向一致
  resonance_threshold: 25     # 中等
```

**适用场景**: 日常交易、中线持仓

#### 3. 保守策略（严格筛选）

```yaml
resonance_filter:
  enabled: true
  min_symbol_score: 20        # 较高
  min_big4_score: 15          # 较高
  require_same_direction: true   # 强制方向一致
  resonance_threshold: 35     # 较高
```

**适用场景**: 趋势市、追求高胜率

## 📈 实战案例

### 案例1: 过滤低质量做多信号

```python
# 场景：收到DOGE/USDT做多信号
symbol = 'DOGE/USDT'
signal_direction = 'LONG'

result = service.check_score_filter(symbol, signal_direction)

# 结果：✅ 通过过滤
# 原因：DOGE/USDT评分40达标（>=15），方向LONG匹配
#
# 代币评分详情：
#   总分: +40 (主分:+30 + 5M:+10)
#   1H: +10分 (6阳4阴)
#   15M: +20分 (7阳3阴)
#   方向: LONG, 强度: strong

# ✅ 执行开仓
```

### 案例2: 拒绝低分信号

```python
# 场景：收到BTC/USDT做多信号
symbol = 'BTC/USDT'
signal_direction = 'LONG'

result = service.check_score_filter(symbol, signal_direction)

# 结果：❌ 未通过过滤
# 原因：BTC/USDT评分10不达标（需>=15）
#
# 代币评分详情：
#   总分: +10 (主分:+10 + 5M:+0)
#   1H: +0分 (5阳5阴)
#   15M: +10分 (6阳4阴)
#   方向: LONG, 强度: medium

# ❌ 跳过此信号
```

### 案例3: 方向不匹配

```python
# 场景：收到SOMI/USDT做空信号
symbol = 'SOMI/USDT'
signal_direction = 'SHORT'

result = service.check_score_filter(symbol, signal_direction)

# 结果：❌ 未通过过滤
# 原因：SOMI/USDT方向不匹配：评分方向LONG vs 信号SHORT
#
# 代币评分详情：
#   总分: +65 (强多)
#   方向: LONG
#
# 分析：虽然SOMI评分很高（65分），但是强多方向，
#       与做空信号相反，所以拒绝

# ❌ 跳过此信号（避免逆势）
```

## 🔍 集成到交易策略

### 在信号生成器中使用

```python
# app/analyzers/signal_generator.py

from app.services.signal_score_v2_service import SignalScoreV2Service

class SignalGenerator:
    def __init__(self, config):
        self.config = config

        # 初始化V2评分服务
        self.score_service = SignalScoreV2Service(
            db_config=self.get_db_config(),
            score_config=config.get('signals', {}).get('resonance_filter', {})
        )

    def generate_signal(self, symbol, technical_data, ...):
        # ... 原有的信号生成逻辑 ...

        # 生成初步信号
        action = self._determine_action(final_score)  # LONG/SHORT

        # V2评分过滤
        filter_result = self.score_service.check_score_filter(symbol, action)

        if not filter_result['passed']:
            logger.info(f"信号被V2评分过滤: {filter_result['reason']}")
            return {
                'action': 'HOLD',
                'confidence': 0,
                'reason': f"评分过滤: {filter_result['reason']}"
            }

        # 通过过滤，返回信号
        return {
            'action': action,
            'confidence': confidence,
            'score_info': filter_result,  # 附加评分信息
            ...
        }
```

### 在实盘交易中使用

```python
# 实盘下单前的最后检查
def execute_trade(symbol, direction, ...):
    # 最后一次评分检查（防止延迟导致的评分变化）
    score_service = SignalScoreV2Service(db_config, score_config)
    result = score_service.check_score_filter(symbol, direction)

    if not result['passed']:
        logger.warning(f"❌ 下单前评分检查未通过: {result['reason']}")
        return False

    # 评分通过，执行下单
    logger.info(f"✅ 评分检查通过: {result['reason']}")
    place_order(...)

    score_service.close()
```

## 🐛 故障排查

### 1. 没有评分数据

**症状**: `get_coin_score()` 返回 `None`

**原因**:
- `coin_kline_scores` 表为空
- MySQL定时任务未运行

**解决**:
```bash
# 检查表数据
mysql> SELECT COUNT(*) FROM coin_kline_scores;

# 如果为0，手动执行一次更新
mysql> CALL update_all_coin_scores();

# 检查定时任务
mysql> SHOW EVENTS;
mysql> SET GLOBAL event_scheduler = ON;
```

### 2. Big4评分缺失

**症状**: 日志显示 "Table 'big4_kline_scores' doesn't exist"

**原因**: Big4评分表未创建

**解决**:
- 如果不需要Big4共振检查，服务会自动降级为仅检查代币评分
- 如果需要Big4功能，需要创建对应的表和调度任务

### 3. 评分数据过期

**症状**: `updated_at` 时间很久以前

**原因**: MySQL定时任务停止

**解决**:
```sql
-- 检查最后更新时间
SELECT MAX(updated_at) FROM coin_kline_scores;

-- 启用定时任务
ALTER EVENT update_coin_scores_every_5min ENABLE;

-- 手动触发一次更新
CALL update_all_coin_scores();
```

## 📝 测试和验证

运行测试脚本：

```bash
# 完整测试
python test_signal_score_v2.py

# 只测试基本查询
python test_signal_score_v2.py --basic

# 只测试过滤功能
python test_signal_score_v2.py --filter
```

## 📌 总结

### V2评分系统 vs V1评分系统

| 特性 | V1（实时计算） | V2（预计算） |
|------|---------------|--------------|
| 计算方式 | 每次查询时实时计算 | MySQL每5分钟预计算 |
| 查询速度 | 慢（数秒） | 快（毫秒级） |
| 数据库压力 | 高 | 低 |
| 数据一致性 | 实时 | 5分钟延迟 |
| 适用场景 | 单个代币深度分析 | 批量信号过滤 |

### 优势

- ✅ **高性能**: 预计算 + 索引查询，毫秒级响应
- ✅ **低耦合**: 评分计算与信号生成分离
- ✅ **易扩展**: 配置化设计，易于调整策略
- ✅ **可追溯**: 所有评分有时间戳，可回溯分析

### 适用场景

- 实时信号过滤
- 批量交易对筛选
- 自动化交易决策
- 风险管理和质量控制
